<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>exodus3 API documentation</title>
<meta name="description" content="exodus.py v 1.20.12 (seacas-py3) is a python wrapper of some of the exodus library
(Python 3 Version) â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>exodus3</code></h1>
</header>
<section id="section-intro">
<p>exodus.py v 1.20.12 (seacas-py3) is a python wrapper of some of the exodus library
(Python 3 Version)</p>
<p>Exodus is a common database for multiple application codes (mesh
generators, analysis codes, visualization software, etc.) affording
flexibility and robustness for both
the application code developer and application code user. By using the
Exodus data model, a user inherits the flexibility of using a large
array of application codes (including vendor-supplied codes) which
access this common data file directly or via translators.</p>
<p>The uses of the Exodus data model include the following:</p>
<ul>
<li>
<p>problem definition &ndash; mesh generation, specification
of locations of boundary conditions and load application, specification
of material types.</p>
</li>
<li>
<p>simulation &ndash; model input and results output.</p>
</li>
<li>
<p>visualization &ndash; model verification, results postprocessing,
data interrogation, and analysis tracking.</p>
</li>
</ul>
<p>The data in Exodus files can be divided into three primary categories:
initialization data, model data, and results data.</p>
<ul>
<li>
<p>Initialization data includes sizing parameters (number of
nodes, number of elements, etc.), optional quality assurance
information (names of codes that have operated on the data),
and optional informational text.</p>
</li>
<li>
<p>The model is described by data which are static (do not change
through time). This data includes nodal coordinates, element
connectivity (node lists for each element), element attributes,
and node sets and side sets (used to aid in applying loading
conditions and boundary constraints).</p>
</li>
<li>
<p>The results are optional and include five types of variables &ndash; nodal,
element, nodeset, sideset, and global &ndash; each of which is stored
through time. Nodal results are output (at each time step) for all the
nodes in the model. An example of a nodal variable is displacement in
the X direction. Element, nodeset, and sideset results are output (at
each time step) for all entities (elements, nodes, sides) in one or
more entity block. For example, stress may be an element
variable. Another use of element variables is to record element status
(a binary flag indicating whether each element is "alive" or "dead")
through time. Global results are output (at each time step) for a
single element or node, or for a single property. Linear momentum of a
structure and the acceleration at a particular point are both examples
of global variables. Although these examples correspond to typical FE
applications, the data format is flexible enough to accommodate a
spectrum of uses.</p>
</li>
</ul>
<p>Copyright(C) 1999-2022 National Technology &amp; Engineering Solutions
of Sandia, LLC (NTESS).
Under the terms of Contract DE-NA0003525 with
NTESS, the U.S. Government retains certain rights in this software.</p>
<p>See packages/seacas/LICENSE for details</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
exodus.py v 1.20.12 (seacas-py3) is a python wrapper of some of the exodus library
(Python 3 Version)

Exodus is a common database for multiple application codes (mesh
generators, analysis codes, visualization software, etc.) affording
flexibility and robustness for both
the application code developer and application code user. By using the
Exodus data model, a user inherits the flexibility of using a large
array of application codes (including vendor-supplied codes) which
access this common data file directly or via translators.

The uses of the Exodus data model include the following:

* problem definition -- mesh generation, specification
  of locations of boundary conditions and load application, specification
  of material types.

* simulation -- model input and results output.

* visualization -- model verification, results postprocessing,
  data interrogation, and analysis tracking.

The data in Exodus files can be divided into three primary categories:
initialization data, model data, and results data.

* Initialization data includes sizing parameters (number of
nodes, number of elements, etc.), optional quality assurance
information (names of codes that have operated on the data),
and optional informational text.

* The model is described by data which are static (do not change
through time). This data includes nodal coordinates, element
connectivity (node lists for each element), element attributes,
and node sets and side sets (used to aid in applying loading
conditions and boundary constraints).

* The results are optional and include five types of variables -- nodal,
element, nodeset, sideset, and global -- each of which is stored
through time. Nodal results are output (at each time step) for all the
nodes in the model. An example of a nodal variable is displacement in
the X direction. Element, nodeset, and sideset results are output (at
each time step) for all entities (elements, nodes, sides) in one or
more entity block. For example, stress may be an element
variable. Another use of element variables is to record element status
(a binary flag indicating whether each element is &#34;alive&#34; or &#34;dead&#34;)
through time. Global results are output (at each time step) for a
single element or node, or for a single property. Linear momentum of a
structure and the acceleration at a particular point are both examples
of global variables. Although these examples correspond to typical FE
applications, the data format is flexible enough to accommodate a
spectrum of uses.

Copyright(C) 1999-2022 National Technology &amp; Engineering Solutions
of Sandia, LLC (NTESS).  Under the terms of Contract DE-NA0003525 with
NTESS, the U.S. Government retains certain rights in this software.

See packages/seacas/LICENSE for details

&#34;&#34;&#34;

import sys
if sys.version_info[0] &lt; 3:
    raise Exception(&#34;Python-3 version. If using python-2, try `import exodus2 as exodus`&#34;)

import ctypes
import os
import locale
from enum import Enum

EXODUS_PY_COPYRIGHT_AND_LICENSE = __doc__

EXODUS_PY_VERSION = &#34;1.20.12 (seacas-py3)&#34;

EXODUS_PY_COPYRIGHT = &#34;&#34;&#34;
You are using exodus.py v 1.20.12 (seacas-py3), a python wrapper of some of the exodus library.

Copyright (c) 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022 National Technology &amp;
Engineering Solutions of Sandia, LLC (NTESS).  Under the terms of
Contract DE-NA0003525 with NTESS, the U.S. Government retains certain
rights in this software.
&#34;&#34;&#34;

EXODUS_PY_CONTACTS = &#34;&#34;&#34;
Authors:
  Greg Sjaardema   (gdsjaar@sandia.gov)
  Mario LoPrinzi   (mvlopri@sandia.gov)
  Timothy Shelton  (trshelt@sandia.gov)
  Michael Veilleux (mgveill@sandia.gov)
  David Littlewood (djlittl@sandia.gov)
&#34;&#34;&#34;

# show the banner on first use
SHOW_BANNER = True

## Documentation is generated on a Mac laptop using:
## pdoc --force --html ../lib/exodus.py

sys.dont_write_bytecode = True

ONELINE = &#34;Gather from or export to Exodus files using the Exodus library&#34;

def basename(file_name):
    &#34;&#34;&#34;
    Extract base name from file_name.
    `basename(&#34;test.e&#34;) -&gt; &#34;test&#34;`
    &#34;&#34;&#34;
    return os.path.splitext(file_name)[0]


def getExodusVersion():
    &#34;&#34;&#34;
    Parse the exodusII.h header file and return the version number or 0 if not
    found.
    &#34;&#34;&#34;
    version_major = -1
    version_minor = -1
    with open(ACCESS + &#34;/include/exodusII.h&#34;) as header_file:
        for line in header_file:
            fields = line.split()
            if (len(fields) == 3 and
                    fields[0] == &#39;#define&#39; and
                    fields[1] == &#39;EXODUS_VERSION_MAJOR&#39;):
                version_major = int(fields[2])
            if (len(fields) == 3 and
                    fields[0] == &#39;#define&#39; and
                    fields[1] == &#39;EXODUS_VERSION_MINOR&#39;):
                version_minor = int(fields[2])
            if (version_major &gt; 0 and version_minor &gt;= 0):
               return 100 * version_major + version_minor
    return 0


try:
    locale.setlocale(locale.LC_ALL, &#39;en_US.utf-8&#39;)
except locale.Error:
    locale.setlocale(locale.LC_ALL, &#39;C&#39;)

class ex_options(Enum):
    &#34;&#34;&#34;
    `ex_opts()` function codes - codes are OR&#39;ed into exopts

    Parameters
    ----------
    EX_DEFAULT
         Application responsible for calling `ex_err()` to get error and warning messages to output; library is quiet
    EX_VERBOSE
         Verbose mode -- output all error and warning messages
    EX_DEBUG
         Output Debug messages
    EX_ABORT
         If an error is detected, library will abort instead of letting application decide
    EX_NULLVERBOSE
         Output error and warning messages for NULL Entity errors and warnings
    &#34;&#34;&#34;
    EX_DEFAULT     = 0
    EX_VERBOSE     = 1
    EX_DEBUG       = 2
    EX_ABORT       = 4
    EX_NULLVERBOSE = 8

ACCESS = os.getenv(&#39;ACCESS&#39;, &#39;/fgs/mvlopri/seacas&#39;)
if os.uname()[0] == &#39;Darwin&#39;:
    EXODUS_SO = ACCESS + &#34;/lib/libexodus.dylib&#34;
else:
    EXODUS_SO = ACCESS + &#34;/lib/libexodus.so&#34;
EXODUS_LIB = ctypes.cdll.LoadLibrary(EXODUS_SO)

MAX_STR_LENGTH = 32      # match exodus default
MAX_NAME_LENGTH = 256     # match exodus default
MAX_LINE_LENGTH = 80      # match exodus default

EX_API_VERSION_NODOT = getExodusVersion()
if EX_API_VERSION_NODOT &gt;= 608:
    EX_READ = 0x0002  # ex_open(): open file for reading (default)
else:
    EX_READ = 0x0000  # ex_open(): open file for reading (default)
EX_WRITE = 0x0001  # ex_open(): open existing file for appending.
EX_NOCLOBBER = 0x0004  # does not overwrite existing exodus file
EX_CLOBBER = 0x0008  # overwrites existing exodus file

EX_NORMAL_MODEL = 0x0010  # disable mods that permit storage of larger models
EX_64BIT_OFFSET = 0x0020  # enable mods that permit storage of larger models
# enable mods that permit storage of larger models
EX_LARGE_MODEL = EX_64BIT_OFFSET
EX_64BIT_DATA = 0x400000  # CDF-5 format: classic model but 64 bit dimensions and sizes
EX_NETCDF4 = 0x0040  # use the hdf5-based netcdf4 output
EX_NOSHARE = 0x0080  # Do not open netcdf file in &#34;share&#34; mode
EX_SHARE = 0x0100  # Do open netcdf file in &#34;share&#34; mode
EX_NOCLASSIC = 0x0200  # Do not force netcdf to classic mode in netcdf4 mode

EX_DISKLESS = 0x100000  # Experimental
EX_MMAP = 0x200000  # Experimental

# Need to distinguish between storage on database (DB in name) and
# passed through the API functions (API in name).
EX_MAPS_INT64_DB = 0x0400  # All maps (id, order, ...) store int64_t values
# All entity ids (sets, blocks, maps) are int64_t values
EX_IDS_INT64_DB = 0x0800
# All integer bulk data (local indices, counts, maps); not ids
EX_BULK_INT64_DB = 0x1000
# All of the above...
EX_ALL_INT64_DB = EX_MAPS_INT64_DB + EX_IDS_INT64_DB + EX_BULK_INT64_DB

EX_MAPS_INT64_API = 0x2000  # All maps (id, order, ...) store int64_t values
# All entity ids (sets, blocks, maps) are int64_t values
EX_IDS_INT64_API = 0x4000
# All integer bulk data (local indices, counts, maps); not ids
EX_BULK_INT64_API = 0x8000
EX_INQ_INT64_API = 0x10000  # Integers passed to/from ex_inquire are int64_t
# All of the above...
EX_ALL_INT64_API = EX_MAPS_INT64_API + EX_IDS_INT64_API + \
    EX_BULK_INT64_API + EX_INQ_INT64_API

# Parallel IO mode flags...
EX_MPIIO = 0x20000
EX_MPIPOSIX = 0x40000  # \deprecated As of libhdf5 1.8.13.
EX_PNETCDF = 0x80000

# set exodus error output option
exErrPrintMode = ctypes.c_int(ex_options.EX_VERBOSE.value)
EXODUS_LIB.ex_opts(exErrPrintMode)


class ex_inquiry(Enum):
        EX_INQ_FILE_TYPE = 1                    # inquire EXODUS file type
        EX_INQ_API_VERS = 2                     # inquire API version number
        EX_INQ_DB_VERS = 3                      # inquire database version number
        EX_INQ_TITLE = 4                        # inquire database title
        EX_INQ_DIM = 5                          # inquire number of dimensions
        EX_INQ_NODES = 6                        # inquire number of nodes
        EX_INQ_ELEM = 7                         # inquire number of elements
        EX_INQ_ELEM_BLK = 8                     # inquire number of element blocks
        EX_INQ_NODE_SETS = 9                    # inquire number of node sets
        EX_INQ_NS_NODE_LEN = 10                 # inquire length of node set node list
        EX_INQ_SIDE_SETS = 11                   # inquire number of side sets
        EX_INQ_SS_NODE_LEN = 12                 # inquire length of side set node list
        EX_INQ_SS_ELEM_LEN = 13                 # inquire length of side set element list
        EX_INQ_QA = 14                          # inquire number of QA records
        EX_INQ_INFO = 15                        # inquire number of info records
        EX_INQ_TIME = 16                        # inquire number of time steps in the database
        EX_INQ_EB_PROP = 17                     # inquire number of element block properties
        EX_INQ_NS_PROP = 18                     # inquire number of node set properties
        EX_INQ_SS_PROP = 19                     # inquire number of side set properties
        # inquire length of node set distribution factor list
        EX_INQ_NS_DF_LEN = 20
        # inquire length of side set distribution factor list
        EX_INQ_SS_DF_LEN = 21
        EX_INQ_LIB_VERS = 22                    # inquire API Lib vers number
        EX_INQ_EM_PROP = 23                     # inquire number of element map properties
        EX_INQ_NM_PROP = 24                     # inquire number of node map properties
        EX_INQ_ELEM_MAP = 25                    # inquire number of element maps
        EX_INQ_NODE_MAP = 26                    # inquire number of node maps
        EX_INQ_EDGE = 27                        # inquire number of edges
        EX_INQ_EDGE_BLK = 28                    # inquire number of edge blocks
        EX_INQ_EDGE_SETS = 29                   # inquire number of edge sets
        # inquire length of concat edge set edge list
        EX_INQ_ES_LEN = 30
        # inquire length of concat edge set dist factor list
        EX_INQ_ES_DF_LEN = 31
        # inquire number of properties stored per edge block
        EX_INQ_EDGE_PROP = 32
        # inquire number of properties stored per edge set
        EX_INQ_ES_PROP = 33
        EX_INQ_FACE = 34                        # inquire number of faces
        EX_INQ_FACE_BLK = 35                    # inquire number of face blocks
        EX_INQ_FACE_SETS = 36                   # inquire number of face sets
        # inquire length of concat face set face list
        EX_INQ_FS_LEN = 37
        # inquire length of concat face set dist factor list
        EX_INQ_FS_DF_LEN = 38
        # inquire number of properties stored per face block
        EX_INQ_FACE_PROP = 39
        # inquire number of properties stored per face set
        EX_INQ_FS_PROP = 40
        EX_INQ_ELEM_SETS = 41                   # inquire number of element sets
        # inquire length of concat element set element list
        EX_INQ_ELS_LEN = 42
        # inquire length of concat element set dist factor list
        EX_INQ_ELS_DF_LEN = 43
        # inquire number of properties stored per elem set
        EX_INQ_ELS_PROP = 44
        EX_INQ_EDGE_MAP = 45                    # inquire number of edge maps
        EX_INQ_FACE_MAP = 46                    # inquire number of face maps
        EX_INQ_COORD_FRAMES = 47                # inquire number of coordinate frames
        # inquire size of MAX_NAME_LENGTH dimension on database
        EX_INQ_DB_MAX_ALLOWED_NAME_LENGTH = 48
        # inquire size of MAX_NAME_LENGTH dimension on database
        EX_INQ_DB_MAX_USED_NAME_LENGTH = 49
        # inquire client-specified max size of returned names
        EX_INQ_MAX_READ_NAME_LENGTH = 50
        # inquire size of floating-point values stored on database
        EX_INQ_DB_FLOAT_SIZE = 51
        EX_INQ_ASSEMBLY = 60
        EX_INQ_BLOB = 61
        EX_INQ_INVALID = -1


class ex_type(Enum):
    EX_INTEGER = 4 # NC_INT (from netcdf.h)
    EX_DOUBLE = 6  # NC_DOUBLE (from netcdf.h)
    EX_CHAR = 2 # NC_CHAR (from netcdf.h)


def ex_inquiry_map(inquiry):
    &#34;&#34;&#34;
    Map the exodus inquiry flags to an enum value.
    &#34;&#34;&#34;
    return ex_inquiry[inquiry].value


def ex_obj_to_inq(objType):
    &#34;&#34;&#34;
    Return the ex_inquiry string corresponding to the specified objType.
    This can be passed to the ex_inquiry_map() function to get the number of
    objects of the specified objType
    &#34;&#34;&#34;
    entity_dictionary = {
        &#39;EX_ASSEMBLY&#39;: &#39;EX_INQ_ASSEMBLY&#39;,
        &#39;EX_BLOB&#39;: &#39;EX_INQ_BLOB&#39;,
        &#39;EX_EDGE_BLOCK&#39;: &#39;EX_INQ_EDGE_BLK&#39;,
        &#39;EX_FACE_BLOCK&#39;: &#39;EX_INQ_FACE_BLK&#39;,
        &#39;EX_ELEM_BLOCK&#39;: &#39;EX_INQ_ELEM_BLK&#39;,
        &#39;EX_NODE_SET&#39;: &#39;EX_INQ_NODE_SETS&#39;,
        &#39;EX_EDGE_SET&#39;: &#39;EX_INQ_EDGE_SETS&#39;,
        &#39;EX_FACE_SET&#39;: &#39;EX_INQ_FACE_SETS&#39;,
        &#39;EX_ELEM_SET&#39;: &#39;EX_INQ_ELEM_SETS&#39;,
        &#39;EX_SIDE_SET&#39;: &#39;EX_INQ_SIDE_SETS&#39;,
        &#39;EX_NODE_MAP&#39;: &#39;EX_INQ_NODES&#39;,
        &#39;EX_EDGE_MAP&#39;: &#39;EX_INQ_EDGE&#39;,
        &#39;EX_FACE_MAP&#39;: &#39;EX_INQ_FACE&#39;,
        &#39;EX_ELEM_MAP&#39;: &#39;EX_INQ_ELEM&#39;,
    }

    return entity_dictionary.get(objType, -1)


def ex_entity_type_to_objType(entity_type):
    &#34;&#34;&#34;
    &#34;&#34;&#34;
    entity_dictionary = {
        get_entity_type(&#39;EX_ASSEMBLY&#39;): &#34;assembly&#34;,
        get_entity_type(&#39;EX_BLOB&#39;): &#34;blob&#34;,
        get_entity_type(&#39;EX_EDGE_BLOCK&#39;): &#34;edge block&#34;,
        get_entity_type(&#39;EX_FACE_BLOCK&#39;): &#34;face block&#34;,
        get_entity_type(&#39;EX_ELEM_BLOCK&#39;): &#34;element block&#34;,
        get_entity_type(&#39;EX_NODE_SET&#39;): &#34;node set&#34;,
        get_entity_type(&#39;EX_EDGE_SET&#39;): &#34;edge set&#34;,
        get_entity_type(&#39;EX_FACE_SET&#39;): &#34;face set&#34;,
        get_entity_type(&#39;EX_ELEM_SET&#39;): &#34;element set&#34;,
        get_entity_type(&#39;EX_SIDE_SET&#39;): &#34;side set&#34;,
        get_entity_type(&#39;EX_NODE_MAP&#39;): &#34;node map&#34;,
        get_entity_type(&#39;EX_EDGE_MAP&#39;): &#34;edge map&#34;,
        get_entity_type(&#39;EX_FACE_MAP&#39;): &#34;face map&#34;,
        get_entity_type(&#39;EX_ELEM_MAP&#39;): &#34;element map&#34;
    }

    return entity_dictionary.get(entity_type, &#39;EX_INVALID&#39;)

class ex_entity_type(Enum):
    &#34;&#34;&#34;
    The ex_entity_type enum from the exodusII.h include file

    Parameters
    ----------
    EX_NODAL
         nodal \&#34;block\&#34; for variables
    EX_NODE_BLOCK
         alias for EX_NODAL
    EX_NODE_SET
         node set property code
    EX_EDGE_BLOCK
         edge block property code
    EX_EDGE_SET
         edge set property code
    EX_FACE_BLOCK
         face block property code
    EX_FACE_SET
         face set property code
    EX_ELEM_BLOCK
         element block property code
    EX_ELEM_SET
         face set property code
    EX_SIDE_SET
         side set property code
    EX_ELEM_MAP
         element map property code
    EX_NODE_MAP
         node map property code
    EX_EDGE_MAP
         edge map property code
    EX_FACE_MAP
         face map property code
    EX_GLOBAL
         global \&#34;block\&#34; for variables
    EX_COORDINATE
         kluge so some internal wrapper functions work
    EX_ASSEMBLY
         assemblies (collections of other entities)
    EX_BLOB
         blob (arbitrary sized binary object)
    EX_INVALID
         invalid
    &#34;&#34;&#34;
    EX_NODAL      = 14
    EX_NODE_BLOCK = 14
    EX_NODE_SET   = 2
    EX_EDGE_BLOCK = 6
    EX_EDGE_SET   = 7
    EX_FACE_BLOCK = 8
    EX_FACE_SET   = 9
    EX_ELEM_BLOCK = 1
    EX_ELEM_SET   = 10
    EX_SIDE_SET = 3
    EX_ELEM_MAP = 4
    EX_NODE_MAP = 5
    EX_EDGE_MAP = 11
    EX_FACE_MAP = 12
    EX_GLOBAL     = 13
    EX_COORDINATE = 15
    EX_ASSEMBLY   = 16
    EX_BLOB   = 17
    EX_INVALID    = -1


def get_entity_type(varType):
    &#34;&#34;&#34;
    Map the exodus ex_entity_type flags to an integer value.
    &#34;&#34;&#34;
    try:
        return ex_entity_type[varType].value
    except KeyError:
        return varType.value

# init params struct
class ex_init_params(ctypes.Structure):
    &#34;&#34;&#34;
    Parameters defining the model dimension, note that many are optional.

    Parameters
    ----------
    num_dim : int
        number of model dimensions
    num_nodes : int
        number of model nodes
    num_edge : int
        number of model edges
    num_edge_blk : int
        number of model edge blocks
    num_face : int
        number of model faces
    num_face_blk : int
        number of model face blocks
    num_elem : int
        number of model elements
    num_elem_blk : int
        number of model element blocks
    num_node_sets : int
        number of model node sets
    num_edge_sets : int
        number of model edge sets
    num_face_sets : int
        number of model face sets
    num_side_sets : int
        number of model side sets
    num_elem_sets : int
        number of model elem sets
    num_node_maps : int
        number of model node maps
    num_edge_maps : int
        number of model edge maps
    num_face_maps : int
        number of model face maps
    num_elem_maps : int
        number of model elem maps
    num_assembly : int
        number of assemblies
    num_blob : int
        number of blobs
    &#34;&#34;&#34;
    _fields_ = [(&#34;title&#34;, ctypes.c_char * (MAX_LINE_LENGTH + 1)),
                (&#34;num_dim&#34;, ctypes.c_longlong),
                (&#34;num_nodes&#34;, ctypes.c_longlong),
                (&#34;num_edge&#34;, ctypes.c_longlong),
                (&#34;num_edge_blk&#34;, ctypes.c_longlong),
                (&#34;num_face&#34;, ctypes.c_longlong),
                (&#34;num_face_blk&#34;, ctypes.c_longlong),
                (&#34;num_elem&#34;, ctypes.c_longlong),
                (&#34;num_elem_blk&#34;, ctypes.c_longlong),
                (&#34;num_node_sets&#34;, ctypes.c_longlong),
                (&#34;num_edge_sets&#34;, ctypes.c_longlong),
                (&#34;num_face_sets&#34;, ctypes.c_longlong),
                (&#34;num_side_sets&#34;, ctypes.c_longlong),
                (&#34;num_elem_sets&#34;, ctypes.c_longlong),
                (&#34;num_node_maps&#34;, ctypes.c_longlong),
                (&#34;num_edge_maps&#34;, ctypes.c_longlong),
                (&#34;num_face_maps&#34;, ctypes.c_longlong),
                (&#34;num_elem_maps&#34;, ctypes.c_longlong),
                (&#34;num_assembly&#34;, ctypes.c_longlong),
                (&#34;num_blob&#34;, ctypes.c_longlong)]

class assembly:
    def __init__(self, name, id, type):
        self.name = name
        self.id = id
        if isinstance(type, str):
            type = ex_entity_type[type].value
        if isinstance(type, ex_entity_type):
            type = type.value
        self.type = type
        self.entity_list = []

    def __repr__(self):
        return &#34;assembly(name=%r, type=%r, id=%r, members=%r)&#34; % (self.name,self.type,self.id,self.entity_list)

class ex_assembly(ctypes.Structure):
    &#34;&#34;&#34;
    Structure defining the assembly parameters.

    Parameters
    ----------
    id : int64_t
    name : char *
    type : ex_entity_type
    entity_count : int
    entity_list : void_int *
    &#34;&#34;&#34;
    _fields_ = [(&#34;id&#34;, ctypes.c_longlong),
                (&#34;name&#34;, ctypes.c_char_p),
                (&#34;type&#34;, ctypes.c_int),
                (&#34;entity_count&#34;, ctypes.c_int),
                (&#34;entity_list&#34;, ctypes.POINTER(ctypes.c_longlong))]

def setup_ex_assembly(assembly):
    ctype_assem = ex_assembly(id=assembly.id, name=assembly.name.encode(), type=assembly.type)
    ctype_assem.entity_count = len(assembly.entity_list)
    ctype_assem.entity_list = (ctypes.c_longlong * ctype_assem.entity_count)(*assembly.entity_list)
    return ctype_assem

class blob(object):
    def __init__(self, name, id, num_entry):
        self.name = name
        self.id = id
        self.num_entry = num_entry

    def __repr__(self):
        return &#34;blob(name=%r, id=%r, num_entry=%r)&#34; % (self.name,self.id,self.num_entry)

class ex_blob(ctypes.Structure):
    &#34;&#34;&#34;
    Structure defining the blob parameters.

    Parameters
    ----------
    id : int64_t
    name : char *
    num_entry : int64_t
    &#34;&#34;&#34;
    _fields_ = [(&#34;id&#34;, ctypes.c_longlong),
                (&#34;name&#34;, ctypes.c_char_p),
                (&#34;num_entry&#34;, ctypes.c_longlong)]

class attribute:
    def __init__(self, name, type, id):
        self.name = name
        self.entity_type = type
        self.entity_id = id
        self.values = []

    def __repr__(self):
        return &#34;attribute(name=%r, entity_type=%r, entity_id=%r, values=%r)&#34; % (self.name,self.entity_type,self.entity_id,self.values)

class ex_attribute(ctypes.Structure):
    &#34;&#34;&#34;
    Used for accessing underlying exodus library...
    &#34;&#34;&#34;
    _fields_ = [(&#34;entity_type&#34;, ctypes.c_int),
                (&#34;entity_id&#34;, ctypes.c_longlong),
                (&#34;name&#34;, ctypes.c_char * 256),
                (&#34;type&#34;, ctypes.c_int),
                (&#34;value_count&#34;, ctypes.c_longlong),
                (&#34;values&#34;, ctypes.c_void_p)]

#
# ----------------------------------------------------------------------
#

class exodus:
    &#34;&#34;&#34;
    The exodus model abstraction
    &#34;&#34;&#34;

    #
    # construction of a new exodus object
    #
    # --------------------------------------------------------------------

    def __init__(self, file, mode=None, array_type=&#39;ctype&#39;, title=None,
                 numDims=None, numNodes=None, numElems=None, numBlocks=None,
                 numNodeSets=None, numSideSets=None, numAssembly=None,
                 numBlob=None, init_params=None, io_size=0):
        &#34;&#34;&#34;
        Open exodus database for data insertion/extraction.

        Parameters
        ----------
        file_name : string
           name of exodus file to open
        mode : string
          &#39;r&#39; for read, &#39;a&#39; for append, &#39;w&#39; for write
        title : string
           database title
        array_type : string
           &#39;ctype&#39; for c-type arrays, &#39;numpy&#39; for numpy arrays
        num_dims : int
           number of model dimensions (&#39;w&#39; mode only)
        num_nodes : int
           number of model nodes (&#39;w&#39; mode only)
        num_elems : int
           number of model elements (&#39;w&#39; mode only)
        num_blocks : int
           number of model element blocks (&#39;w&#39; mode only)
        num_ns : int
           number of model node sets (&#39;w&#39; mode only)
        num_ss : int
           number of model side sets (&#39;w&#39; mode only)

        init_params : ex_init_params
           see `exodus.ex_init_params` for more info.

        Returns
        -------
        exo : exodus object
            the open exodus database

        Usage
        -----

        &gt;&gt;&gt; ex_pars = ex_init_params(num_dim=numDims, num_nodes=numNodes,
        ...                          num_elem=numElems, num_elem_blk=numElemBlocks, num_assembly=numAssembly)

        &gt;&gt;&gt; exo = exodus(file_name, mode=mode, title=title,
        ...             array_type=array_type, init_params=ex_pars)
        &gt;&gt;&gt; with exodus(file_name, mode=mode, title=title,\
        ...             array_type=array_type, init_params=ex_pars) as exo:
        ...     pass
        &#34;&#34;&#34;
        global SHOW_BANNER
        if SHOW_BANNER:
            print(EXODUS_PY_COPYRIGHT)
            SHOW_BANNER = False

        if mode is None:
            mode = &#39;r&#39;

        if array_type == &#39;numpy&#39;:
            # Import numpy to convert from c-type arrays to numpy arrays
            # (Numpy is imported here rather than at the module level, so that
            # the import only occurs if the user specifies a numpy array type.
            # This way, platforms without numpy installed can still import the
            # exodus.py module and just use ctype arrays.)
            import numpy as np
            self.np = np
            self.use_numpy = True
            # Warnings module is needed to suppress the invalid warning when
            # converting from c-type arrays to numpy arrays
            # http://stackoverflow.com/questions/4964101/pep-3118-warning-when-using-ctypes-array-as-numpy-array
            import warnings
            self.warnings = warnings
        else:
            self.use_numpy = False

        self.EXODUS_LIB = EXODUS_LIB
        self.fileName = str(file)
        self.basename = basename(file)
        self.modeChar = mode
        self.fileId = None
        self.__open(io_size=io_size)
        EXODUS_LIB.ex_set_max_name_length(self.fileId, MAX_NAME_LENGTH)
        if mode.lower() == &#39;w&#39;:
            if init_params is not None:
                self.init_params = init_params
                if title is not None:
                    self.init_params.title = title
                self.put_info_ext(self.init_params)
            else:
                if numNodeSets is None:
                    numNodeSets = 0
                if numSideSets is None:
                    numSideSets = 0
                if numNodes is None:
                    numNodes = 0
                if numElems is None:
                    numElems = 0
                if numBlocks is None:
                    numBlocks = 0

                info = [title, numDims, numNodes, numElems, numBlocks,
                        numNodeSets, numSideSets]
                assert None not in info
                self.__ex_put_info(info)

            self.numTimes = ctypes.c_int(0)
        else:
            self.__ex_get_info()
            self.numTimes = ctypes.c_int(
                self.__ex_inquire_int(
                    ex_inquiry_map(&#39;EX_INQ_TIME&#39;)))

        self.coordsX = None
        self.coordsY = None
        self.coordsZ = None
        self.times = None

    def __enter__(self):
        return self

    def __exit__(self, type, value, traceback):
        self.close()
        if not traceback:
            return True

    def summarize(self):
        &#34;&#34;&#34;
        Outputs a summary of the exodus file data. Output is similar to:
        ```
        Database: base_ioshell_copy.e
        Title:  This is the title

        Number of spatial dimensions = 3                                                 Number of global variables     = 10
        Number of node blocks        = 1         Number of nodes              = 1,331    Number of nodal variables      =  2
        Number of element blocks     = 1         Number of elements           = 1,000    Number of element variables    =  5
        Number of node sets          = 3         Length of node list          =   363    Number of nodeset variables    =  4
        Number of element side sets  = 3         Length of element sides      =   300    Number of sideset variables    =  3
        Number of assemblies         = 4                                                 Number of assembly variables   = 10
        Number of blobs              = 0                                                 Number of blob     variables   =  0
        Number of time steps         = 5
        ```
        &#34;&#34;&#34;

        total_sides = 0
        sidesets = self.get_ids(&#39;EX_SIDE_SET&#39;)
        for sideset in sidesets:
            total_sides += self.num_faces_in_side_set(sideset)

        total_ns_nodes = 0
        nodesets = self.get_ids(&#39;EX_NODE_SET&#39;)
        for nodeset in nodesets:
            total_ns_nodes += self.num_nodes_in_node_set(nodeset)

        num_glo_vars = self.get_variable_number(&#39;EX_GLOBAL&#39;)
        num_nod_vars = self.get_variable_number(&#39;EX_NODAL&#39;)
        num_ele_vars = self.get_variable_number(&#39;EX_ELEM_BLOCK&#39;)
        num_ns_vars = self.get_variable_number(&#39;EX_NODE_SET&#39;)
        num_ss_vars = self.get_variable_number(&#39;EX_SIDE_SET&#39;)
        num_assem_vars = self.get_reduction_variable_number(&#39;EX_ASSEMBLY&#39;)
        num_blob_vars = self.get_reduction_variable_number(&#39;EX_BLOB&#39;)

        print(&#34;\n Database: {0}\n&#34;
              &#34; Title:\t{17}\n\n&#34;
              &#34; Number of spatial dimensions = {1:3d}\t&#34;
              &#34;                                   {2:11s}\t&#34;
              &#34; Number of global variables     = {11:6d}\n&#34;
              &#34; Number of node blocks        = {5:3d}\t&#34;
              &#34; Number of nodes              = {3:10n}\t&#34;
              &#34; Number of nodal variables      = {12:6d}\n&#34;
              &#34; Number of element blocks     = {6:3n}\t&#34;
              &#34; Number of elements           = {4:10n}\t&#34;
              &#34; Number of element variables    = {13:6d}\n&#34;
              &#34; Number of node sets          = {7:3n}\t&#34;
              &#34; Length of node list          = {9:10n}\t&#34;
              &#34; Number of nodeset variables    = {14:6d}\n&#34;
              &#34; Number of element side sets  = {8:3n}\t&#34;
              &#34; Length of element sides      = {10:10n}\t&#34;
              &#34; Number of sideset variables    = {15:6d}\n&#34;
              &#34; Number of assemblies         = {18:3n}\t&#34;
              &#34;                                   {2:11s}\t&#34;
              &#34; Number of assembly red vars    = {19:6d}\n&#34;
              &#34; Number of blobs              = {20:3n}\t&#34;
              &#34;                                   {2:11s}\t&#34;
              &#34; Number of blob red vars        = {21:6d}\n&#34;
              &#34; Number of time steps         = {16:3n}\n&#34;
              .format(self.fileName,
                      self.num_dimensions(), &#34;&#34;,
                      self.num_nodes(),
                      self.num_elems(),
                      1,
                      self.num_blks(),
                      self.num_node_sets(),
                      self.num_side_sets(),
                      total_ns_nodes, total_sides,
                      num_glo_vars, num_nod_vars, num_ele_vars,
                      num_ns_vars, num_ss_vars, self.num_times(), self.title(),
                      self.num_assembly(), num_assem_vars,
                      self.num_blob(), num_blob_vars))
    #
    # build the info struct
    #
    # --------------------------------------------------------------------


    def put_info_ext(self, p):
        &#34;&#34;&#34;
        put initialization information into exodus file

        &gt;&gt;&gt; e.put_info_ext(info_struct)
        &#34;&#34;&#34;
        if len(p.title) &gt; MAX_LINE_LENGTH:
            print(&#34;WARNING: Exodus title \&#34;{}\&#34; exceeds maximum line length ({}). It will be truncated.&#34;
                  .format(p.title, MAX_LINE_LENGTH))
            p.title = p.title[-1*MAX_LINE_LENGTH:]

        self.Title = ctypes.create_string_buffer(p.title, MAX_LINE_LENGTH + 1)
        self.numDim = ctypes.c_longlong(p.num_dim)
        self.numNodes = ctypes.c_longlong(p.num_nodes)
        self.numElem = ctypes.c_longlong(p.num_elem)
        self.numElemBlk = ctypes.c_longlong(p.num_elem_blk)
        self.numNodeSets = ctypes.c_longlong(p.num_node_sets)
        self.numSideSets = ctypes.c_longlong(p.num_side_sets)
        self.numAssembly = ctypes.c_longlong(p.num_assembly)

        EXODUS_LIB.ex_put_init_ext(self.fileId, ctypes.byref(p))
        return True


    #
    # copy to a new database
    #
    # --------------------------------------------------------------------
    def copy(self, fileName, include_transient=False, mode=&#39;a&#39;):
        &#34;&#34;&#34;
        Copies exodus database to file_name and returns an opened copy as a
        new exodus object. This object will need to be closed when it is done
        being used.

        &gt;&gt;&gt; exo_copy = exo.copy(file_name)
        &gt;&gt;&gt; exo_copy.close()

        Parameters
        ----------
        file_name : str
            name of exodus file to open

        Returns
        -------
        exo_copy : exodus object opened in append mode by default
        &#34;&#34;&#34;
        i64Status = EXODUS_LIB.ex_int64_status(self.fileId)
        fileId = EXODUS_LIB.ex_create_int(fileName.encode(&#39;ascii&#39;), EX_NOCLOBBER|i64Status,
                                          ctypes.byref(self.comp_ws),
                                          ctypes.byref(self.io_ws),
                                          EX_API_VERSION_NODOT)

        self.__copy_file(fileId, include_transient)
        EXODUS_LIB.ex_close(fileId)

        return exodus(fileName, mode)


    #
    # general info
    #
    # --------------------------------------------------------------------

    def title(self):
        &#34;&#34;&#34;
        get the database title

        &gt;&gt;&gt; title = exo.title()

        Returns
        -------
        title : string
        &#34;&#34;&#34;
        return self.Title.value.decode(&#39;utf8&#39;)

    # --------------------------------------------------------------------

    def version_num(self):
        &#34;&#34;&#34;
        get exodus version number used to create the database

        &gt;&gt;&gt; version = exo.version_num()

        Returns
        -------
        version : string
            representation of version number
        &#34;&#34;&#34;
        return &#34;%1.2f&#34; % self.version.value

    # --------------------------------------------------------------------

    def put_info(self, Title, numDim, numNodes, numElem, numElemBlk,
                 numNodeSets, numSideSets):
        &#34;&#34;&#34;
        Initialize static metadata for the database.

        &gt;&gt;&gt; status = exo.put_info(title, num_dims, num_nodes, num_elems,
        ...                      num_blocks, num_ns, num_ss)

        Parameters
        ----------
        title : string
            database title
        num_dims : int
            number of model dimensions
        num_nodes : int
            number of model nodes
        num_elems : int
            number of model elements
        num_blocks : int
            number of model element blocks
        num_ns : int
            number of model node sets
        num_ss : int
            number of model side sets

        Returns
        -------
        status : bool
            True = successful execution

        &#34;&#34;&#34;
        self.__ex_put_info([Title, numDim, numNodes, numElem,
                            numElemBlk, numNodeSets, numSideSets])
        return True


    # --------------------------------------------------------------------

    def inquire(self, inquiry):
        &#34;&#34;&#34;
        Inquire about various properties of the database

        Returns
        -------
        inq_res : int
        &#34;&#34;&#34;
        return self.__ex_inquire_int(ex_inquiry_map(inquiry))

    # --------------------------------------------------------------------

    def num_qa_records(self):
        &#34;&#34;&#34;
        get the number of qa records

        &gt;&gt;&gt; num_qa_recs = exo.num_qa_records()

        Returns
        -------
        num_qa_recs : int
        &#34;&#34;&#34;
        return int(self.__ex_inquire_int(ex_inquiry_map(&#39;EX_INQ_QA&#39;)))

    # --------------------------------------------------------------------

    def get_qa_records(self):
        &#34;&#34;&#34;
        get a list of QA records where each QA record is a length-4 tuple of strings:
          1. the software name that accessed/modified the database
          2. the software descriptor, e.g. version
          3. additional software data
          4. time stamp

        &gt;&gt;&gt; qa_recs = exo.get_qa_records()


        Returns
        -------
        qa_recs : &lt;list&lt;tuple[4]&lt;string&gt;&gt;&gt;
        &#34;&#34;&#34;
        return self.__ex_get_qa()

    # --------------------------------------------------------------------

    def put_qa_records(self, records):
        &#34;&#34;&#34;
        store a list of QA records where each QA record is a length-4 tuple of strings:
          1. the software name that accessed/modified the database
          2. the software descriptor, e.g. version
          3. additional software data
          4. time stamp

        &gt;&gt;&gt; status = exo.put_qa_records()

        Parameter
        ---------
        qa_recs : &lt;list&lt;tuple[4]&lt;string&gt;&gt;&gt;

        Returns
        ------
        status : bool
            True = successful execution
        &#34;&#34;&#34;
        for rec in records:
            assert len(rec) == 4
            for recEntry in rec:
                assert len(str(recEntry).encode(&#39;ascii&#39;)) &lt; MAX_STR_LENGTH
        return self.__ex_put_qa(records)

    # --------------------------------------------------------------------

    def num_info_records(self):
        &#34;&#34;&#34;
        get the number of info records

        &gt;&gt;&gt; num_info_recs = exo.num_info_records()

        Returns
        -------
        num_info_recs : int
        &#34;&#34;&#34;
        return int(self.__ex_inquire_int(ex_inquiry_map(&#39;EX_INQ_INFO&#39;)))

    # --------------------------------------------------------------------
    def get_info_records(self):
        &#34;&#34;&#34;
        get a list info records where each entry in the list is one info
        record, e.g. a line of an input deck

        &gt;&gt;&gt; info_recs = exo.get_info_records()

        Returns
        -------
        info_recs : &lt;list&lt;string&gt;&gt;

        &#34;&#34;&#34;
        info_recs = self.__ex_get_info_recs()
        return info_recs

    # --------------------------------------------------------------------

    def put_info_records(self, info):
        &#34;&#34;&#34;
        store a list of info records where each entry in the list is
        one line of info, e.g. a line of an input deck

        &gt;&gt;&gt; status = exo.put_info_records(info)

        Parameters
        ----------
        info_recs : &lt;list&lt;tuple[4]&lt;string&gt;&gt;&gt;

        Returns
        -------
        status : bool
            True = successful execution
        &#34;&#34;&#34;
        for rec in info:
            if len(str(rec).encode(&#39;ascii&#39;)) &gt; MAX_LINE_LENGTH:
                print(&#34;WARNING: max line length reached for one or more info records;&#34;)
                print(
                    &#34;         info stored to exodus file is incomplete for these records&#34;)
                break
        return self.__ex_put_info_recs(info)

    # --------------------------------------------------------------------

    def get_sierra_input(self, inpFileName=None):
        &#34;&#34;&#34;
        parse sierra input deck from the info records if inp_file_name
        is passed the deck is written to this file; otherwise a list
        of input deck file lines is returned

        &gt;&gt;&gt; inp = exo.get_sierra_input(inpFileName=inp_file_name)

        Parameters
        ----------
        inp_file_name : string, optional
           Name of text file where info records corresponding to the Sierra input deck will be written

        Returns
        -------
        inp : list&lt;string&gt;
           lines if inp_file_name not provided; otherwise, an empty list

        &#34;&#34;&#34;
        info_recs = self.__ex_get_info_recs()
        sierra_inp = []
        begin = False
        for rec in info_recs:
            vals = rec.split()
            if not begin:  # have not reached Sierra block
                if len(vals) &gt;= 2 and vals[0].lower() == &#34;begin&#34; and vals[1].lower() == &#34;sierra&#34;:
                    begin = True
            if begin:  # inside Sierra block
                sierra_inp.append(rec)
                if len(rec) &gt; MAX_LINE_LENGTH:
                    print(
                        &#34;WARNING: max line length reached for one or more input lines;&#34;)
                    print(&#34;         input data might be incomplete for these lines&#34;)
                    break
                if len(vals) &gt;= 2 and vals[0].lower() == &#34;end&#34; and vals[1].lower() == &#34;sierra&#34;:
                    break  # end of Sierra block

        if inpFileName:
            fd = open(inpFileName.encode(&#39;ascii&#39;), &#34;w&#34;)
            for fileLine in sierra_inp:
                fd.write(fileLine+&#34;\n&#34;)
            fd.close()
            return []

        return sierra_inp

    #
    # time steps
    #
    # --------------------------------------------------------------------

    def num_times(self):
        &#34;&#34;&#34;
        get the number of time steps

        &gt;&gt;&gt; num_times = exo.num_times()

        Returns
        -------
        num_times : int
        &#34;&#34;&#34;
        return self.numTimes.value

    # --------------------------------------------------------------------

    def get_times(self):
        &#34;&#34;&#34;
        get the time values

        &gt;&gt;&gt; time_vals = exo.get_times()

        Returns
        -------
            if array_type == &#39;ctype&#39; :
              &lt;list&lt;ctypes.c_double&gt;&gt;  time_vals

            if array_type == &#39;numpy&#39; :
              &lt;np_array&lt;double&gt;&gt;  time_vals
        &#34;&#34;&#34;
        if self.numTimes.value == 0:
            self.times = []
        else:
            self.__ex_get_all_times()
        if self.use_numpy:
            self.times = ctype_to_numpy(self, self.times)
        return self.times

    # --------------------------------------------------------------------

    def put_time(self, step, value):
        &#34;&#34;&#34;
        store a new time

        &gt;&gt;&gt; exo.put_time(time_step, time_val)

        Parameters
        ----------
        time_step : int
            time step index (1-based)
        time_val : float
            time value for this step

        Returns
        -------
        status : bool
            True = successful execution
        &#34;&#34;&#34;
        self.__ex_put_time(step, value)
        self.numTimes = ctypes.c_int(self.__ex_inquire_int(ex_inquiry_map(&#39;EX_INQ_TIME&#39;)))
        return True

    #
    # coordinate system
    #
    # --------------------------------------------------------------------

    def num_dimensions(self):
        &#34;&#34;&#34;
        get the number of model spatial dimensions

        &gt;&gt;&gt; num_dims = exo.num_dimensions()

        Returns
        -------
        num_dims : &lt;int
        &#34;&#34;&#34;
        return self.numDim.value

    # --------------------------------------------------------------------

    def get_coord_names(self):
        &#34;&#34;&#34;
        get a list of length exo.num_dimensions() that has the name
        of each model coordinate direction, e.g. [&#39;x&#39;, &#39;y&#39;, &#39;z&#39;]

        &gt;&gt;&gt; coord_names = exo.get_coord_names()

        Returns
        -------
            &lt;list&lt;string&gt;&gt;  coord_names
        &#34;&#34;&#34;
        names = self.__ex_get_coord_names()
        return names

    # --------------------------------------------------------------------

    def put_coord_names(self, names):
        &#34;&#34;&#34;
        store a list of length exo.num_dimensions() that has the name
        of each model coordinate direction, e.g. [&#39;x&#39;, &#39;y&#39;, &#39;z&#39;]

        &gt;&gt;&gt; exo.put_coord_names()

        Parameters
        ----------
            &lt;list&lt;string&gt;&gt;  coord_names
        &#34;&#34;&#34;
        self.__ex_put_coord_names(names)

    #
    # nodes
    #
    # --------------------------------------------------------------------

    def num_nodes(self):
        &#34;&#34;&#34;
        get the number of nodes in the model

        &gt;&gt;&gt; num_nodes = exo.num_nodes()

        Returns
        -------
        num_nodes : int
        &#34;&#34;&#34;
        return self.numNodes.value

    # --------------------------------------------------------------------

    def get_coords(self):
        &#34;&#34;&#34;
        get model coordinates of all nodes; for each coordinate
        direction, a length exo.num_nodes() list is returned

        &gt;&gt;&gt; x_coords, y_coords, z_coords = exo.get_coords()

        Returns
        -------

            if array_type == &#39;ctype&#39;:
              &lt;list&lt;ctypes.c_double&gt;&gt;  x_coords  global x-direction coordinates
              &lt;list&lt;ctypes.c_double&gt;&gt;  y_coords  global y-direction coordinates
              &lt;list&lt;ctypes.c_double&gt;&gt;  z_coords  global z-direction coordinates

            if array_type == &#39;numpy&#39;:
              &lt;np_array&lt;double&gt;&gt;  x_coords  global x-direction coordinates
              &lt;np_array&lt;double&gt;&gt;  y_coords  global y-direction coordinates
              &lt;np_array&lt;double&gt;&gt;  z_coords  global z-direction coordinates
        &#34;&#34;&#34;
        self.__ex_get_coord()
        if self.use_numpy:
            self.coordsX = ctype_to_numpy(self, self.coordsX)
            self.coordsY = ctype_to_numpy(self, self.coordsY)
            self.coordsZ = ctype_to_numpy(self, self.coordsZ)
        return self.coordsX, self.coordsY, self.coordsZ

    # --------------------------------------------------------------------

    def get_coord(self, i):
        &#34;&#34;&#34;
        get model coordinates of a single node

        &gt;&gt;&gt; x_coord, y_coord, z_coord = exo.get_coord(node_index)

        Parameters
        ----------
        node_index : int
            the 1-based node index (indexing is from 1 to exo.num_nodes())

        Returns
        -------
        x_coord : double
            global x-direction coordinate
        y_coord : double
            global y-direction coordinate
        z_coord : double
            global z-direction coordinate

        Note:
        -----
        &gt;&gt;&gt; x_coords, y_coords, z_coords = exo.get_coords()
        &gt;&gt;&gt; x_coord = x_coords[node_index-1]
        &gt;&gt;&gt; y_coord = y_coords[node_index-1]
        &gt;&gt;&gt; z_coord = z_coords[node_index-1]
            ... is equivalent to ...
        &gt;&gt;&gt; x_coord, y_coord, z_coord = exo.get_coords(node_index)

        &#34;&#34;&#34;
        listX, listY, listZ = self.__ex_get_partial_coord(i, 1)
        return listX[0], listY[0], listZ[0]

    # --------------------------------------------------------------------

    def put_coords(self, xCoords, yCoords, zCoords):
        &#34;&#34;&#34;
        store model coordinates of all nodes; for each coordinate
        direction, a length exo.num_nodes() list is input

        &gt;&gt;&gt; status = exo.put_coords(x_coords, y_coords, z_coords)

        Parameters
        ----------
        x_coord : &lt;list&lt;float&gt;&gt;
            global x-direction coordinates
        y_coord : &lt;list&lt;float&gt;&gt;
            global y-direction coordinates
        z_coord : &lt;list&lt;float&gt;&gt;
            global z-direction coordinates

        Returns
        -------
        status : bool
            True = successful execution
        &#34;&#34;&#34;
        self.__ex_put_coord(xCoords, yCoords, zCoords)
        return True

    # --------------------------------------------------------------------

    def get_node_num_map(self):
        &#34;&#34;&#34;
        **DEPRECATED** use: `get_node_id_map()`

        get mapping of exodus node index to user- or application-
        defined node id; node_id_map is ordered the same as the nodal
        coordinate arrays returned by exo.get_coords() -- this ordering
        follows the exodus node *INDEX* order, a 1-based system going
        from 1 to exo.num_nodes(); a user or application can optionally
        use a separate node *ID* numbering system, so the node_id_map
        points to the node *ID* for each node *INDEX*

        &gt;&gt;&gt; node_id_map = exo.get_node_num_map()

        Returns
        -------
            &lt;list&lt;ctypes.c_int&gt;&gt;  node_id_map
        &#34;&#34;&#34;
        nodeNumMap = self.__ex_get_node_num_map()
        return nodeNumMap

    # --------------------------------------------------------------------

    def put_node_id_map(self, id_map):
        &#34;&#34;&#34;
        store mapping of exodus node index to user- or application-
        defined node id; node_id_map is ordered the same as the nodal
        coordinate arrays returned by exo.get_coords() -- this ordering
        follows the exodus node *INDEX* order, a 1-based system going
        from 1 to exo.num_nodes(); a user or application can optionally
        use a separate node *ID* numbering system, so the node_id_map
        points to the node *ID* for each node *INDEX*

        &gt;&gt;&gt; status = exo.put_node_id_map(node_id_map)

        Parameters
        ----------
            &lt;list&lt;int&gt;&gt;  node_id_map

        Returns
        -------
        status : bool
            True = successful execution
        &#34;&#34;&#34;
        return self.__ex_put_id_map(&#39;EX_NODE_MAP&#39;, id_map)

    # --------------------------------------------------------------------

    def get_node_variable_names(self):
        &#34;&#34;&#34;
        get the list of nodal variable names in the model

        &gt;&gt;&gt; nvar_names = exo.get_node_variable_names()

        Returns
        -------
              &lt;list&lt;string&gt;&gt;  nvar_names
        &#34;&#34;&#34;
        if self.__ex_get_variable_param(&#39;EX_NODAL&#39;).value == 0:
            return []
        return self.__ex_get_variable_names(&#39;EX_NODAL&#39;)

    # --------------------------------------------------------------------

    def get_node_variable_number(self):
        &#34;&#34;&#34;
        get the number of nodal variables in the model

        &gt;&gt;&gt; num_nvars = exo.get_node_variable_number()

        Returns
        -------
        num_nvars : int
        &#34;&#34;&#34;
        return self.__ex_get_variable_param(&#39;EX_NODAL&#39;).value

    # --------------------------------------------------------------------

    def set_node_variable_number(self, number):
        &#34;&#34;&#34;
        update the number of nodal variables in the model

        &gt;&gt;&gt; status = exo.set_node_variable_number(num_nvars)

        Parameters
        ----------
        num_nvars : int

        Returns
        -------
        status : bool
            True = successful execution
        &#34;&#34;&#34;
        self.__ex_put_variable_param(&#39;EX_NODAL&#39;, number)
        return True

    # --------------------------------------------------------------------

    def put_node_variable_name(self, name, index):
        &#34;&#34;&#34;
        add the name and index of a new nodal variable to the model;
        nodal variable indexing goes from 1 to exo.get_node_variable_number()

        &gt;&gt;&gt; status = exo.put_node_variable_name(nvar_name, nvar_index)

        Parameters
        ----------
            &lt;string&gt;  nvar_name   name of new nodal variable
            &lt;int&gt;     nvar_index  1-based index of new nodal variable

        Returns
        -------
        status : bool
            True = successful execution

        Note:
        ----
        this method is often called within the following sequence:

        &gt;&gt;&gt; num_nvars = exo.get_node_variable_number()
        &gt;&gt;&gt; new_nvar_index = num_nvars + 1
        &gt;&gt;&gt; num_nvars += 1
        &gt;&gt;&gt; exo.set_node_variable_number(num_nvars)
        &gt;&gt;&gt; exo.put_node_variable_name(&#34;new_nvar_name&#34;, new_nvar_index)
        &#34;&#34;&#34;
        NDvarNames = self.get_variable_names(&#39;EX_NODAL&#39;)
        if name in NDvarNames:
            print(&#34;WARNING: node variable \&#34;{}\&#34; already exists.&#34;.format(name))
        if index &gt; len(NDvarNames):
            raise Exception(&#34;ERROR: variable index out of range.&#34;)
        self.__ex_put_variable_name(&#39;EX_NODAL&#39;, index, name)
        return True

    # --------------------------------------------------------------------

    def get_node_variable_values(self, name, step):
        &#34;&#34;&#34;
        get list of nodal variable values for a nodal variable name
        and time step

        &gt;&gt;&gt; nvar_vals = exo.get_node_variable_values(nvar_name, time_step)

        Parameters
        ----------
            &lt;string&gt;  nvar_name  name of nodal variable
            &lt;int&gt;     time_step  1-based index of time step

        Returns
        -------

            if array_type == &#39;ctype&#39;:
              &lt;list&lt;ctypes.c_double&gt;&gt;  nvar_vals

            if array_type == &#39;numpy&#39;:
              &lt;np_array&lt;double&gt;&gt;  nvar_vals
        &#34;&#34;&#34;
        names = self.get_variable_names(&#39;EX_NODAL&#39;)
        var_id = names.index(name) + 1
        numVals = self.num_nodes()
        values = self.__ex_get_var(step, &#39;EX_NODAL&#39;, var_id, 0, numVals)
        if self.use_numpy:
            values = ctype_to_numpy(self, values)
        return values

    # --------------------------------------------------------------------

    def get_partial_node_variable_values(self, name, step, start_index, num_nodes):
        &#34;&#34;&#34;
        get partial list of nodal variable values for a nodal variable name
        and time step.  Start at node `node_index` (1-based) and return `num_nodes`
        from that point.

        &gt;&gt;&gt; nvar_vals = exo.get_partial_node_variable_values(nvar_name, time_step, 10, 100)

        Parameters
        ----------
            &lt;string&gt;  nvar_name   name of nodal variable
            &lt;int&gt;     time_step   1-based index of time step
            &lt;int&gt;     start_index 1-based index of node to start returning data
            &lt;int&gt;     num_nodes   number of nodes to return data for.

        Returns
        -------

            if array_type == &#39;ctype&#39;:
              &lt;list&lt;ctypes.c_double&gt;&gt;  nvar_vals

            if array_type == &#39;numpy&#39;:
              &lt;np_array&lt;double&gt;&gt;  nvar_vals
        &#34;&#34;&#34;
        names = self.get_variable_names(&#39;EX_NODAL&#39;)
        var_id = names.index(name) + 1
        values = self.__ex_get_partial_var(step, &#39;EX_NODAL&#39;, var_id, 0, start_index, num_nodes)
        if self.use_numpy:
            values = ctype_to_numpy(self, values)
        return values

    # --------------------------------------------------------------------

    def put_node_variable_values(self, name, step, values):
        &#34;&#34;&#34;
        store a list of nodal variable values for a nodal variable
        name and time step

        &gt;&gt;&gt; status = exo.put_node_variable_values(nvar_name, time_step, nvar_vals)

        Parameters
        ----------
            &lt;string&gt;       nvar_name  name of nodal variable
            &lt;int&gt;          time_step  1-based index of time step
            &lt;list&lt;float&gt;&gt;  nvar_vals

        Returns
        -------
        status : bool
            True = successful execution
        &#34;&#34;&#34;
        names = self.get_variable_names(&#39;EX_NODAL&#39;)
        var_id = names.index(name) + 1
        numVals = self.num_nodes()
        self.__ex_put_var(step, &#39;EX_NODAL&#39;, var_id, 0, numVals, values)
        return True

    #
    # elements
    #
    # --------------------------------------------------------------------

    def num_elems(self):
        &#34;&#34;&#34;
        get the number of elements in the model

        &gt;&gt;&gt; num_elems = exo.num_elems()

        Returns
        -------
        num_elems : int
        &#34;&#34;&#34;
        return self.numElem.value

    # --------------------------------------------------------------------

    def get_elem_id_map(self):
        &#34;&#34;&#34;
        get mapping of exodus element index to user- or application-
        defined element id; elem_id_map is ordered by the element
        *INDEX* ordering, a 1-based system going from 1 to
        exo.num_elems(), used by exodus for storage and input/output
        of array data stored on the elements; a user or application
        can optionally use a separate element *ID* numbering system,
        so the elem_id_map points to the element *ID* for each
        element *INDEX*

        &gt;&gt;&gt; elem_id_map = exo.get_elem_id_map()

        Returns
        -------

            if array_type == &#39;ctype&#39;:
              &lt;list&lt;int&gt;&gt;  elem_id_map

            if array_type == &#39;numpy&#39;:
              &lt;np_array&lt;int&gt;&gt;  elem_id_map
        &#34;&#34;&#34;
        return self.__ex_get_id_map(&#39;EX_ELEM_MAP&#39;)

    # --------------------------------------------------------------------

    def put_elem_id_map(self, id_map):
        &#34;&#34;&#34;
        store mapping of exodus element index to user- or application-
        defined element id; elem_id_map is ordered by the element
        *INDEX* ordering, a 1-based system going from 1 to
        exo.num_elems(), used by exodus for storage and input/output
        of array data stored on the elements; a user or application
        can optionally use a separate element *ID* numbering system,
        so the elem_id_map points to the element *ID* for each
        element *INDEX*

        &gt;&gt;&gt; status = exo.put_elem_id_map(elem_id_map)

        Parameters
        ----------
            &lt;list&lt;int&gt;&gt;  elem_id_map

        Returns
        -------
        status : bool
            True = successful execution
        &#34;&#34;&#34;
        return self.__ex_put_id_map(&#39;EX_ELEM_MAP&#39;, id_map)

    # --------------------------------------------------------------------

    def get_block_id_map(self, obj_type, entity_id):
        &#34;&#34;&#34;
        Gets the map of elements found in the given entity_id of an object
        of obj_type.

        *INDEX* ordering, a 1-based system going from 1 to
        number of elements in the elem_block, used by exodus for
        storage and input/output of array data stored on the elements;
        a user or application can optionally use a separate element *ID* numbering system,
        so the elem_id_map points to the element *ID* for each
        element *INDEX*

        &gt;&gt;&gt; elem_block_id_map = exo.get_block_id_map(&#34;EX_ELEM_BLOCK&#34;, 100)

        Returns
        -------

            if array_type == &#39;ctype&#39;:
              &lt;list&lt;int&gt;&gt;  elem_id_map

            if array_type == &#39;numpy&#39;:
              &lt;np_array&lt;int&gt;&gt;  elem_id_map
        &#34;&#34;&#34;
        return self.__ex_get_block_id_map(obj_type, entity_id)

    # --------------------------------------------------------------------

    def get_elem_num_map(self):
        &#34;&#34;&#34;
        **DEPRECATED** use: `get_elem_id_map()`

        get mapping of exodus element index to user- or application-
        defined element id; elem_id_map is ordered by the element
        *INDEX* ordering, a 1-based system going from 1 to
        exo.num_elems(), used by exodus for storage and input/output
        of array data stored on the elements; a user or application
        can optionally use a separate element *ID* numbering system,
        so the elem_id_map points to the element *ID* for each
        element *INDEX*

        &gt;&gt;&gt; elem_id_map = exo.get_elem_num_map()

        Returns
        -------
            &lt;list&lt;ctypes.c_int&gt;&gt;  elem_id_map
        &#34;&#34;&#34;
        elemNumMap = self.__ex_get_elem_num_map()
        return elemNumMap

    # --------------------------------------------------------------------

    def get_elem_order_map(self):
        &#34;&#34;&#34;
        get mapping of exodus element index to application-defined
        optimal ordering; elem_order_map is ordered by the element
        index ordering used by exodus for storage and input/output
        of array data stored on the elements; a user or application
        can optionally use a separate element ordering, e.g. for
        optimal solver performance, so the elem_order_map points to
        the index used by the application for each exodus element
        index

        &gt;&gt;&gt; elem_order_map = exo.get_elem_order_map()

        Returns
        -------

            if array_type == &#39;ctype&#39;:
              &lt;list&lt;int&gt;&gt;  elem_order_map

            if array_type == &#39;numpy&#39;:
              &lt;np_array&lt;int&gt;&gt;  elem_order_map
        &#34;&#34;&#34;

        elemOrderMap = self.__ex_get_elem_order_map()
        if self.use_numpy:
            elemOrderMap = ctype_to_numpy(self, elemOrderMap)
        return elemOrderMap

    # Generic (objType) get/put/query...
    # --------------------------------------------------------------------

    def put_id_map(self, objType, id_map):
        &#34;&#34;&#34;
        store mapping of exodus node index to user- or application-
        defined node id; node_id_map is ordered the same as the nodal
        coordinate arrays returned by exo.get_coords() -- this ordering
        follows the exodus node *INDEX* order, a 1-based system going
        from 1 to exo.num_nodes(); a user or application can optionally
        use a separate node *ID* numbering system, so the node_id_map
        points to the node *ID* for each node *INDEX*

        &gt;&gt;&gt; status = exo.put_node_id_map(node_id_map)

        Parameters
        ----------
            &lt;list&lt;int&gt;&gt;  node_id_map

        Returns
        -------
        status : bool
            True = successful execution
        &#34;&#34;&#34;
        return self.__ex_put_id_map(objType, id_map)

    # --------------------------------------------------------------------

    def get_id_map(self, objType):
        &#34;&#34;&#34;
        get mapping of exodus node index to user- or application-
        defined node id; node_id_map is ordered the same as the nodal
        coordinate arrays returned by exo.get_coords() -- this ordering
        follows the exodus node *INDEX* order, a 1-based system going
        from 1 to exo.num_nodes(); a user or application can optionally
        use a separate node *ID* numbering system, so the node_id_map
        points to the node *ID* for each node *INDEX*

        &gt;&gt;&gt; node_id_map = exo.get_node_id_map()

        Returns
        -------

            if array_type == &#39;ctype&#39;:
              &lt;list&lt;int&gt;&gt;  node_id_map

            if array_type == &#39;numpy&#39;:
              &lt;np_array&lt;int&gt;&gt;  node_id_map
        &#34;&#34;&#34;
        return self.__ex_get_id_map(objType)

    # --------------------------------------------------------------------

    def get_node_id_map(self):
        &#34;&#34;&#34;
        get mapping of exodus node index to user- or application-
        defined node id; node_id_map is ordered the same as the nodal
        coordinate arrays returned by exo.get_coords() -- this ordering
        follows the exodus node *INDEX* order, a 1-based system going
        from 1 to exo.num_nodes(); a user or application can optionally
        use a separate node *ID* numbering system, so the node_id_map
        points to the node *ID* for each node *INDEX*

        &gt;&gt;&gt; node_id_map = exo.get_node_id_map()

        Returns
        -------

            if array_type == &#39;ctype&#39;:
              &lt;list&lt;int&gt;&gt;  node_id_map

            if array_type == &#39;numpy&#39;:
              &lt;np_array&lt;int&gt;&gt;  node_id_map
        &#34;&#34;&#34;
        return self.__ex_get_id_map(&#39;EX_NODE_MAP&#39;)

    # --------------------------------------------------------------------

    def get_name(self, object_type, object_id):
        &#34;&#34;&#34;
        get the name of the specified entity_type and entity

        &gt;&gt;&gt; elem_blk_name = exo.get_name(&#39;EX_ELEM_BLOCK&#39;, elem_blk_id)

        Parameters
        ----------
        object_type : int
            block/set type
        object_id : int
            block/set *ID* (not *INDEX*)

        Returns
        -------
        name : string
        &#34;&#34;&#34;
        name = self.__ex_get_name(object_type, object_id)
        return name

    # --------------------------------------------------------------------

    def put_name(self, object_type, object_id, name):
        &#34;&#34;&#34;
        put the name of the specified entity_type and entity

        &gt;&gt;&gt; exo.put_name(&#39;EX_ELEM_BLOCK&#39;, elem_blk_id, block_name)

        Parameters
        ----------
        object_type : int
            block/set type
        object_id : int
            block/set *ID* (not *INDEX*)
        name : string
            block/set name

        Returns
        -------
        elem_blk_name : string
        &#34;&#34;&#34;
        self.__ex_put_name(object_type, object_id, name)

    # --------------------------------------------------------------------

    def get_names(self, object_type):
        &#34;&#34;&#34;
        get a list of all block/set names ordered by block/set *INDEX*;
        (see `exodus.get_ids` for explanation of the
        difference between *ID* and *INDEX*)

        &gt;&gt;&gt; blk_names = exo.get_names(&#39;EX_ELEM_BLOCK&#39;)

        Parameters
        ----------
        object_type : int
            block/set type

        Returns
        -------
            &lt;list&lt;string&gt;&gt;  names
        &#34;&#34;&#34;
        names = self.__ex_get_names(object_type)
        return names

    # --------------------------------------------------------------------

    def put_names(self, object_type, names):
        &#34;&#34;&#34;
        store a list of all block/set names of the specified
        `object_type` ordered by *INDEX*;
        (see `exodus.get_ids` for explanation of the
        difference between *ID* and *INDEX*)

        &gt;&gt;&gt; exo.put_names(&#39;EX_ELEM_BLOCK&#39;, elem_blk_names)

        Parameters
        ----------
        object_type : int
        names : &lt;list&lt;string&gt;&gt;
        &#34;&#34;&#34;

        self.__ex_put_names(object_type, names)

    # --------------------------------------------------------------------

    def get_reduction_variable_values(self, objType, id, step):
        &#34;&#34;&#34;
        get list of reduction variable values for a specified entity type and
        id, and time step

        &gt;&gt;&gt; evar_vals = exo.get_reduction_variable_values(&#39;EX_ELEM_BLOCK&#39;, elem_blk_id, time_step)

        Parameters
        ----------
        objType   : ex_entity_type
            type of object being queried
        id        : int
            entity *ID* (not *INDEX*)
        time_step : int
            1-based index of time step

        Returns
        -------

            if array_type == &#39;ctype&#39;:
              &lt;list&lt;ctypes.c_double&gt;&gt;  evar_vals

            if array_type == &#39;numpy&#39;:
              &lt;np_array&lt;double&gt;&gt;  evar_vals

        &#34;&#34;&#34;
        numVals = self.get_reduction_variable_number(objType)
        values = self.__ex_get_reduction_vars(step, objType, id, numVals)
        if self.use_numpy:
            values = ctype_to_numpy(self, values)
        return values

    # --------------------------------------------------------------------

    def put_reduction_variable_values(self, objType, id, step, values):
        &#34;&#34;&#34;
        store a list of &#39;objType&#39; variable values for a specified entity,
        and time step

        &gt;&gt;&gt; status = exo.put_redcution_variable_values(&#39;EX_ELEM_BLOCK&#39;, elem_blk_id,
        ...             time_step, evar_vals)

        Parameters
        ----------
        objType : ex_entity_type
            type of object begin queried
        id : int
            element block *ID* (not *INDEX*)
            &lt;int&gt;          time_step    1-based index of time step
            &lt;list&lt;float&gt;&gt;  evar_vals

        Returns
        -------
        status : bool
            True = successful execution
        &#34;&#34;&#34;
        numVals = self.get_reduction_variable_number(objType)
        self.__ex_put_reduction_vars(step, objType, id, numVals, values)
        return True

    # --------------------------------------------------------------------

    def get_ids(self, objType):
        &#34;&#34;&#34;
        get mapping of exodus block/set index to user- or application-
        defined block/set id; ids is ordered
        by the *INDEX* ordering, a 1-based system going from
        1 to number_set_or_block, used by exodus for storage
        and input/output of array data stored on the blocks/sets; a
        user or application can optionally use a separate block/set
        *ID* numbering system, so the ids array points to the
        block/set *ID* for each set *INDEX*

        &gt;&gt;&gt; node_set_ids = exo.get_ids(&#39;EX_NODE_SET&#39;)

        Returns
        -------

            if array_type == &#39;ctype&#39;:
              &lt;list&lt;int&gt;&gt;  ids

            if array_type == &#39;numpy&#39;:
              &lt;np_array&lt;int&gt;&gt;  ids
        &#34;&#34;&#34;
        ids = self.__ex_get_ids(objType)
        if self.use_numpy:
            ids = self.np.array(ids)
        return ids

    # --------------------------------------------------------------------
    def get_variable_truth_table(self, objType, entId=None):
        &#34;&#34;&#34;
        gets a truth table indicating which variables are defined for
        specified entity type; if entId is not passed, then a concatenated
        truth table for all entities is returned with variable index
        cycling faster than entity index

        &gt;&gt;&gt; ssvar_truth_tab = exo.get_variable_truth_table(&#39;EX_SIDE_SET&#39;, sideSetID=side_set_id)

        Parameters
        ----------
        entId : int, optional
            entity *ID* (not *INDEX*)

        Returns
        -------
        truth_tab : &lt;list&lt;bool&gt;&gt;
            True for variable defined in an entity, False otherwise
        &#34;&#34;&#34;
        if entId is None:
            truthTable = self.__ex_get_truth_table(objType)
        else:
            truthTable = self.__ex_get_object_truth_vector(objType, entId)
        return truthTable

    # --------------------------------------------------------------------

    def set_variable_truth_table(self, objType, table):
        &#34;&#34;&#34;
        stores a truth table indicating which variables are defined for
        all sets/blocks of the specified `objType` and all variables; variable index cycles
        faster than entity index

        &gt;&gt;&gt; status = exo.set_variable_truth_table(&#39;EX_NODE_SET&#39;, nsvar_truth_tab)

        Parameters
        ----------
        table : &lt;list&lt;bool&gt;&gt;
            True for variable defined in a node set, False otherwise

        Returns
        -------
        status : bool
            True = successful execution
        &#34;&#34;&#34;
        return self.__ex_put_truth_table(objType, table)

    # --------------------------------------------------------------------

    def get_variable_names(self, objType):
        &#34;&#34;&#34;
        get the list of variable names in the model for the specified object type.

        &gt;&gt;&gt; nar_names = exo.get_variable_names(&#39;EX_NODAL&#39;)

        Returns
        -------
              &lt;list&lt;string&gt;&gt;  nvar_names
        &#34;&#34;&#34;
        if self.__ex_get_variable_param(objType).value == 0:
            return []
        return self.__ex_get_variable_names(objType)

    # --------------------------------------------------------------------

    def get_reduction_variable_names(self, objType):
        &#34;&#34;&#34;
        get the list of reduction variable names in the model for the specified object type.

        &gt;&gt;&gt; nar_names = exo.get_reduction_variable_names(&#39;EX_ASSEMBL&#34;Y&#39;)

        Returns
        -------
              &lt;list&lt;string&gt;&gt;  nvar_names
        &#34;&#34;&#34;
        if self.__ex_get_reduction_variable_param(objType).value == 0:
            return []
        return self.__ex_get_reduction_variable_names(objType)

    # --------------------------------------------------------------------

    def get_reduction_variable_name(self, objType, varId):
        &#34;&#34;&#34;
        get a single reduction variable name in the model for the specified object type and index.

        &gt;&gt;&gt; nar_name = exo.get_reduction_variable_name(&#39;EX_ASSEMBL&#34;Y&#39;, 100)

        Returns
        -------
              string  nvar_name
        &#34;&#34;&#34;
        if self.__ex_get_reduction_variable_param(objType).value == 0:
            return &#34;&#34;
        return self.__ex_get_reduction_variable_name(objType, varId)

    # --------------------------------------------------------------------

    def get_variable_number(self, objType):
        &#34;&#34;&#34;
        get the number of variables of the specified type in the model

        &gt;&gt;&gt; num_nvars = exo.get_variable_number(&#39;EX_NODAL&#39;)

        Returns
        -------
        num_nvars :               &lt;int&gt;
        &#34;&#34;&#34;
        return self.__ex_get_variable_param(objType).value

    # --------------------------------------------------------------------

    def get_reduction_variable_number(self, objType):
        &#34;&#34;&#34;
        get the number of reduction variables of the specified type in the model

        &gt;&gt;&gt; num_nvars = exo.get_reduction_variable_number(&#39;EX_ASSEMBLY&#39;)

        Returns
        -------
        num_nvars :               &lt;int&gt;
        &#34;&#34;&#34;
        return self.__ex_get_reduction_variable_param(objType).value

    # --------------------------------------------------------------------

    def set_variable_number(self, objType, number):
        &#34;&#34;&#34;
        update the number of variables in the model

        &gt;&gt;&gt; status = exo.set_variable_number(&#39;EX_NODAL&#39;, num_nvars)

        Parameters
        ----------
        num_nvars :               &lt;int&gt;

        Returns
        -------
        status : bool
            True = successful execution
        &#34;&#34;&#34;
        self.__ex_put_variable_param(objType, number)
        return True

    # --------------------------------------------------------------------

    def set_reduction_variable_number(self, objType, number):
        &#34;&#34;&#34;
        update the number of reduction variables in the model

        &gt;&gt;&gt; status = exo.set_reduction_variable_number(&#39;EX_ASSEMBLY&#39;, num_nvars)

        Parameters
        ----------
        num_nvars :               &lt;int&gt;

        Returns
        -------
        status : bool
            True = successful execution
        &#34;&#34;&#34;
        self.__ex_put_reduction_variable_param(objType, number)
        return True

    # --------------------------------------------------------------------

    def put_variable_name(self, objType, name, index):
        &#34;&#34;&#34;
        add the name and index of a new variable to the model;
        variable indexing goes from 1 to exo.get_variable_number()

        &gt;&gt;&gt; status = exo.put_variable_name(&#39;EX_NODAL&#39;, nvar_name, nvar_index)

        Parameters
        ----------
        objType : string
            object type
        var_name : string
            name of new variable
        nvar_index : int
            1-based index of new nodal variable

        Returns
        -------
        status : bool
            True = successful execution

        Note:
        ----
        this method is often called within the following sequence:

        &gt;&gt;&gt; num_nvars = exo.get_variable_number(&#39;EX_NODAL&#39;)
        &gt;&gt;&gt; new_nvar_index = num_nvars + 1
        &gt;&gt;&gt; num_nvars += 1
        &gt;&gt;&gt; exo.set_variable_number(&#39;EX_NODAL&#39;, num_nvars)
        &gt;&gt;&gt; exo.put_variable_name(&#39;EX_NODAL&#39;, &#34;new_nvar_name&#34;, new_nvar_index)
        &#34;&#34;&#34;
        varNames = self.get_variable_names(objType)
        if name in varNames:
            print(&#34;WARNING: variable \&#34;{}\&#34; already exists.&#34;.format(name))
        if index &gt; len(varNames):
            raise Exception(&#34;ERROR: variable index out of range.&#34;)
        self.__ex_put_variable_name(objType, index, name)
        return True

    # --------------------------------------------------------------------

    def put_reduction_variable_name(self, objType, name, index):
        &#34;&#34;&#34;
        add the name and index of a new reduction variable to the model;
        variable indexing goes from 1 to exo.get_reductino_variable_number()

        &gt;&gt;&gt; status = exo.put_reduction_variable_name(&#39;EX_ASSEMBLY&#39;, assemvar_name, assemvar_index)

        Parameters
        ----------
        objType : string
            object type
        var_name : string
            name of new variable
        nvar_index : int
            1-based index of new nodal variable

        Returns
        -------
        status : bool
            True = successful execution

        Note:
        ----
        this method is often called within the following sequence:

        &gt;&gt;&gt; num_assem_vars = exo.get_reduction_variable_number(&#39;EX_ASSEMBLY&#39;)
        &gt;&gt;&gt; new_assem_var_index = num_assem_vars + 1
        &gt;&gt;&gt; num_assem_vars += 1
        &gt;&gt;&gt; exo.set_reduction_variable_number(&#39;EX_ASSEMBLY&#39;, num_assem_vars)
        &gt;&gt;&gt; exo.put_reduction_variable_name(&#39;EX_ASSEMBLY&#39;, &#34;new_assem_var_name&#34;, new_assem_var_index)
        &#34;&#34;&#34;
        varNames = self.get_reduction_variable_names(objType)
        if name in varNames:
            print(&#34;WARNING: variable \&#34;{}\&#34; already exists.&#34;.format(name))
        if index &gt; len(varNames):
            raise Exception(&#34;ERROR: variable index out of range.&#34;)
        self.__ex_put_reduction_variable_name(objType, index, name)
        return True

    # --------------------------------------------------------------------
    def get_variable_values(self, objType, entityId, name, step):
        &#34;&#34;&#34;
        get list of `objType` variable values for a specified object id
        block, variable name, and time step

        &gt;&gt;&gt; evar_vals = exo.get_variable_values(&#39;EX_ELEM_BLOCK&#39;, elem_blk_id,
        ...                                            evar_name, time_step)

        Parameters
        ----------
        objType   : ex_entity_type
            type of object being queried
        entityId : int
            id of the entity (block, set) *ID* (not *INDEX*)
        name : string
            name of variable
        time_step : int
            1-based index of time step

        Returns
        -------

            if array_type == &#39;ctype&#39;:
              &lt;list&lt;ctypes.c_double&gt;&gt;  evar_vals

            if array_type == &#39;numpy&#39;:
              &lt;np_array&lt;double&gt;&gt;  evar_vals
        &#34;&#34;&#34;
        names = self.get_variable_names(objType)
        var_id = names.index(name) + 1
        numVals = 0
        if objType == &#39;EX_NODAL&#39;:
            numVals = self.num_nodes()
        elif objType == &#39;EX_ELEM_BLOCK&#39;:
            numVals = self.num_elems_in_blk(entityId)
        elif objType == &#39;EX_NODE_SET&#39;:
            (numVals, _numDistFactInSet) = self.__ex_get_set_param(objType, entityId)
        elif objType == &#39;EX_EDGE_SET&#39;:
            (numVals, _numDistFactInSet) = self.__ex_get_set_param(objType, entityId)
        elif objType == &#39;EX_FACE_SET&#39;:
            (numVals, _numDistFactInSet) = self.__ex_get_set_param(objType, entityId)
        elif objType == &#39;EX_SIDE_SET&#39;:
            (numVals, _numDistFactInSet) = self.__ex_get_set_param(objType, entityId)

        values = self.__ex_get_var(step, objType, var_id, entityId, numVals)
        if self.use_numpy:
            values = ctype_to_numpy(self, values)
        return values


    # --------------------------------------------------------------------
    def put_variable_values(self, objType, entityId, name, step, values):
        &#34;&#34;&#34;
        store a list of element variable values for a specified element
        block, element variable name, and time step

        &gt;&gt;&gt; status = exo.put_variable_values(&#39;EX_ELEM_BLOCK&#39;, elem_blk_id,
        ...             evar_name, time_step, evar_vals)

        Parameters
        ----------
        entityId : int  entity *ID* (not *INDEX*)
            &lt;string&gt;    name    name of variable
            &lt;int&gt;          time_step    1-based index of time step
            &lt;list&lt;float&gt;&gt;  values the variable values to be output

        Returns
        -------
        status : bool
            True = successful execution
        &#34;&#34;&#34;
        names = self.get_variable_names(objType)
        var_id = names.index(name) + 1
        numVals = 0
        if objType == &#39;EX_NODAL&#39;:
            numVals = self.num_nodes()
        elif objType == &#39;EX_ELEM_BLOCK&#39;:
            numVals = self.num_elems_in_blk(entityId)
        elif objType == &#39;EX_NODE_SET&#39;:
            (numVals, _numDistFactInSet) = self.__ex_get_set_param(objType, entityId)
        elif objType == &#39;EX_EDGE_SET&#39;:
            (numVals, _numDistFactInSet) = self.__ex_get_set_param(objType, entityId)
        elif objType == &#39;EX_FACE_SET&#39;:
            (numVals, _numDistFactInSet) = self.__ex_get_set_param(objType, entityId)
        elif objType == &#39;EX_SIDE_SET&#39;:
            (numVals, _numDistFactInSet) = self.__ex_get_set_param(objType, entityId)

        self.__ex_put_var(step, objType, var_id, entityId, numVals, values)
        return True

    # Attributes (meta-data attributes; not the per-element bulk-data kind)
    # --------------------------------------------------------------------
    def get_attribute_count(self, objType, objId):
        &#34;&#34;&#34;
        IS THIS NEEDED, PYTHONIC WAY MAY BE TO JUST GET THEM...

        get the number of attributes on the specified entity

        &gt;&gt;&gt; num_attribute = exo.get_attribute_count(&#39;EX_ASSEMBLY&#39;, 100)

        Parameters
        ----------
        objType   : ex_entity_type
            type of object being queried
        id        : int
            entity *ID* (not *INDEX*)

        Returns
        -------
            &lt;int&gt;  num_attribute
        &#34;&#34;&#34;
        return self.__ex_get_attribute_count(objType, objId)

    def get_attributes(self, objType, objId):
        &#34;&#34;&#34;
        &gt;&gt;&gt; attributes = exo.get_attributes(&#39;EX_ASSEMBLY&#39;, 100)

        Returns
        -------
            &lt;ex_attribute list&gt; attributes
        &#34;&#34;&#34;

        return self.__ex_get_attributes(objType, objId)


    def put_attribute(self, attribute):
        &#34;&#34;&#34;
        &gt;&gt;&gt; attribute = exodus.attribute(&#39;Scale&#39;, &#39;EX_ASSEMBLY&#39;, 100)
        &gt;&gt;&gt; attribute.values = [1.1, 1.0, 1.2]
        &gt;&gt;&gt; attributes = exo.put_attribute(attribute)

        Returns
        -------
            &lt;ex_attribute list&gt; attributes
        &#34;&#34;&#34;

        return self.__ex_put_attribute(attribute)


    # Assemblies...
    # --------------------------------------------------------------------
    def num_assembly(self):
        &#34;&#34;&#34;
        get the number of assemblies in the model

        &gt;&gt;&gt; num_assembly = exo.num_assembly()

        Returns
        -------
            &lt;int&gt;  num_assembly
        &#34;&#34;&#34;
        return self.inquire(&#39;EX_INQ_ASSEMBLY&#39;)


    def get_assembly(self, object_id):
        &#34;&#34;&#34;
        reads the assembly parameters and assembly data for one assembly
        &#34;&#34;&#34;
        assem = ex_assembly(id=object_id)
        self.__ex_get_assembly(assem)
        assmbly = assembly(assem.name.decode(&#39;utf8&#39;), assem.id, assem.type)
        for j in range(assem.entity_count):
            assmbly.entity_list.append(assem.entity_list[j])
        return assmbly

    def get_assemblies(self, object_ids):
        &#34;&#34;&#34;
        reads the assembly parameters and assembly data for all assemblies
        with ids in object_ids
        &#34;&#34;&#34;
        assemblies = [ex_assembly(id=object_id) for object_id in object_ids]
        assems = (ex_assembly * len(assemblies))(*assemblies)
        self.__ex_get_assemblies(assems)
        assembs = [assembly(assem.name.decode(&#39;utf8&#39;), assem.id, assem.type) for assem in
                   assems]
        for i, a in enumerate(assems):
            for j in range(a.entity_count):
                assembs[i].entity_list.append(a.entity_list[j])
        return assembs

    def put_assembly(self, assembly):
        &#34;&#34;&#34;
        writes the assembly parameters and assembly data for one assembly
        &#34;&#34;&#34;
        self.__ex_put_assembly(assembly)

    def put_assemblies(self, assemblies):
        &#34;&#34;&#34;
        writes the assembly parameters and assembly data for multiple assemblies
        &#34;&#34;&#34;
        self.__ex_put_assemblies(assemblies)


    # Blobs...
    # --------------------------------------------------------------------
    def num_blob(self):
        &#34;&#34;&#34;
        get the number of blobs in the model

        &gt;&gt;&gt; num_assembly = exo.num_blob()

        Returns
        -------
            &lt;int&gt;  num_blob
        &#34;&#34;&#34;
        return self.numBlob.value


    def get_blob(self, object_id):
        &#34;&#34;&#34;
        reads the blob parameters and blob data for one blob
        &#34;&#34;&#34;
        assem = ex_blob(id=object_id)
        self.__ex_get_blob(assem)
        return assem


    # element blocks
    # --------------------------------------------------------------------

    def num_blks(self):
        &#34;&#34;&#34;
        get the number of element blocks in the model

        &gt;&gt;&gt; num_elem_blks = exo.num_blks()

        Returns
        -------
        num_elem_blks : int
        &#34;&#34;&#34;
        return self.numElemBlk.value

    # --------------------------------------------------------------------

    def get_elem_blk_ids(self):
        &#34;&#34;&#34;
        get mapping of exodus element block index to user- or
        application-defined element block id; elem_blk_ids is ordered
        by the element block *INDEX* ordering, a 1-based system going
        from 1 to exo.num_blks(), used by exodus for storage
        and input/output of array data stored on the element blocks; a
        user or application can optionally use a separate element block
        *ID* numbering system, so the elem_blk_ids array points to the
        element block *ID* for each element block *INDEX*

        &gt;&gt;&gt; elem_blk_ids = exo.get_elem_blk_ids()

        Returns
        -------

            if array_type == &#39;ctype&#39;:
              &lt;list&lt;int&gt;&gt;  elem_blk_ids

            if array_type == &#39;numpy&#39;:
              &lt;np_array&lt;int&gt;&gt;  elem_blk_ids
        &#34;&#34;&#34;
        return self.get_ids(&#39;EX_ELEM_BLOCK&#39;)

    # --------------------------------------------------------------------

    def get_elem_blk_name(self, object_id):
        &#34;&#34;&#34;
        get the element block name

        &gt;&gt;&gt; elem_blk_name = exo.get_elem_blk_name(elem_blk_id)

        Parameters
        ----------
        elem_blk_id : int
            element block *ID* (not *INDEX*)

        Returns
        -------
        elem_blk_name : string
        &#34;&#34;&#34;
        return self.__ex_get_name(&#39;EX_ELEM_BLOCK&#39;, object_id)

    # --------------------------------------------------------------------

    def put_elem_blk_name(self, object_id, name):
        &#34;&#34;&#34;
        store the element block name

        &gt;&gt;&gt; exo.put_elem_blk_name(elem_blk_id, elem_blk_name)

        Parameters
        ----------
        elem_blk_id : int
            element block *ID* (not *INDEX*)
        elem_blk_name : string
        &#34;&#34;&#34;
        self.__ex_put_name(&#39;EX_ELEM_BLOCK&#39;, object_id, name)

    # --------------------------------------------------------------------

    def get_elem_blk_names(self):
        &#34;&#34;&#34;
        get a list of all element block names ordered by block *INDEX*;
        (see `exodus.get_ids` for explanation of the
        difference between block *ID* and block *INDEX*)

        &gt;&gt;&gt; elem_blk_names = exo.get_elem_blk_names()

        Returns
        -------
        elem_blk_names : &lt;list&lt;string&gt;&gt;
        &#34;&#34;&#34;
        elemBlkNames = self.__ex_get_names(&#39;EX_ELEM_BLOCK&#39;)
        return elemBlkNames

    # --------------------------------------------------------------------

    def put_elem_blk_names(self, names):
        &#34;&#34;&#34;
        store a list of all element block names ordered by block *INDEX*;
        (see `exodus.get_ids` for explanation of the
        difference between block *ID* and block *INDEX*)

        &gt;&gt;&gt; exo.put_elem_blk_names(elem_blk_names)

        Parameters
        ----------
        elem_blk_names : &lt;list&lt;string&gt;&gt;
        &#34;&#34;&#34;
        self.__ex_put_names(&#39;EX_ELEM_BLOCK&#39;, names)

    # --------------------------------------------------------------------

    def elem_blk_info(self, object_id):
        &#34;&#34;&#34;
        get the element block info

        &gt;&gt;&gt; elem_type, num_blk_elems, num_elem_nodes, num_elem_attrs
        ...       = exo.elem_blk_info(elem_blk_id)

        Parameters
        ----------
        elem_blk_id : int
            element block *ID* (not *INDEX*)

        Returns
        -------
            &lt;string&gt;  elem_type       element type, e.g. &#39;HEX8&#39;
            &lt;int&gt;     num_blk_elems   number of elements in the block
            &lt;int&gt;     num_elem_nodes  number of nodes per element
            &lt;int&gt;     num_elem_attrs  number of attributes per element
        &#34;&#34;&#34;
        (elemType, numElem, nodesPerElem, numAttr) = self.__ex_get_block(&#39;EX_ELEM_BLOCK&#39;, object_id)
        return elemType.value, numElem.value, nodesPerElem.value, numAttr.value

    # --------------------------------------------------------------------

    def put_elem_blk_info(self, elem_blk_id, elem_type, num_blk_elems,
                          num_elem_nodes, num_elem_attrs):
        &#34;&#34;&#34;
        store the element block *ID* and element block info

        &gt;&gt;&gt; exo.put_elem_blk_info(elem_blk_id, elem_type, num_blk_elems,
        ...                      num_elem_nodes, num_elem_attrs)

        Parameters
        ----------
        elem_blk_id : int
            element block *ID* (not *INDEX*)
        elem_type : string
            element type (all caps), e.g. &#39;HEX8&#39;
        num_blk_elems : int
            number of elements in the block
        num_elem_nodes : int
            number of nodes per element
        num_elem_attrs : int
            number of attributes per element
        &#34;&#34;&#34;
        self.__ex_put_block(&#39;EX_ELEM_BLOCK&#39;, elem_blk_id, elem_type, num_blk_elems,
                            num_elem_nodes, num_elem_attrs)

    # --------------------------------------------------------------------

    def put_concat_elem_blk(self, elem_blk_ids, elem_type, num_blk_elems,
                            num_elem_nodes, num_elem_attrs, defineMaps):
        &#34;&#34;&#34;
        same as exo.put_elem_blk_info() but for all blocks at once

        &gt;&gt;&gt; status = exo.put_concat_elem_blk(elem_blk_ids, elem_types,
        ...                                 num_blk_elems, num_elem_nodes, num_elem_attrs)

        Parameters
        ----------
            &lt;list&lt;int&gt;&gt;     elem_blk_ids     element block *ID* (not *INDEX*)
              for each block
            &lt;list&lt;string&gt;&gt;  elem_types       element type for each block
            &lt;list&lt;int&gt;&gt;     num_blk_elems    number of elements for each
              block
            &lt;list&lt;int&gt;&gt;     num_elem_nodes   number of nodes per element
              for each block
            &lt;list&lt;int&gt;&gt;     num_elem_attrs   number of attributes per
              element for each block

        Returns
        -------
        status : bool
            True = successful execution
        &#34;&#34;&#34;
        self.__ex_put_concat_elem_blk(
            elem_blk_ids,
            elem_type,
            num_blk_elems,
            num_elem_nodes,
            num_elem_attrs,
            defineMaps)
        return True

    # --------------------------------------------------------------------

    def get_elem_connectivity(self, object_id):
        &#34;&#34;&#34;
        get the nodal connectivity, number of elements, and
        number of nodes per element for a single block

        &gt;&gt;&gt; elem_conn, num_blk_elems, num_elem_nodes
        ...        = exo.get_elem_connectivity(elem_blk_id)

        Parameters
        ----------
        elem_blk_id : int
            element block *ID* (not *INDEX*)

        Returns
        -------

            if array_type == &#39;ctype&#39;:
              &lt;list&lt;int&gt;&gt;  elem_conn  ordered list of node *INDICES* that
                define the connectivity of each element
                in the block; the list cycles through
                all nodes of the first element, then
                all nodes of the second element, etc.
                (see `exodus.get_id_map` for explanation
                of node *INDEX* versus node *ID*)

            if array_type == &#39;numpy&#39;:
              &lt;np_array&lt;int&gt;&gt;  elem_conn  (same description)

            &lt;int&gt;  num_blk_elems    number of elements in the block
            &lt;int&gt;  num_elem_nodes   number of nodes per element
        &#34;&#34;&#34;
        (elem_block_connectivity, num_elem_this_blk,
         num_nodes_per_elem) = self.__ex_get_elem_conn(object_id)
        if self.use_numpy:
            elem_block_connectivity = ctype_to_numpy(
                self, elem_block_connectivity)
        return elem_block_connectivity, num_elem_this_blk.value, num_nodes_per_elem.value

    # --------------------------------------------------------------------

    def put_elem_connectivity(self, object_id, connectivity):
        &#34;&#34;&#34;
        store the nodal connectivity, number of elements, and
        number of nodes per element for a single block

        &gt;&gt;&gt; exo.put_elem_connectivity(elem_blk_id, elem_conn)

        Parameters
        ----------
        elem_blk_id : int
            element block *ID* (not *INDEX*)
            &lt;list&lt;int&gt;&gt;  elem_conn    ordered list of node *INDICES* that
              define the connectivity of each
              element in the block; the list cycles
              through all nodes of the first element,
              then all nodes of the second element,
              etc.
              (see `exodus.get_id_map` for explanation
              of node *INDEX* versus node *ID*)
        &#34;&#34;&#34;
        _d1, numBlkElems, numNodesPerElem, _d2 = self.elem_blk_info(object_id)
        assert len(connectivity) == (numBlkElems * numNodesPerElem)
        self.__ex_put_elem_conn(object_id, connectivity)

    # --------------------------------------------------------------------

    def get_elem_attr(self, elem_blk_id):
        &#34;&#34;&#34;
        get all attributes for each element in a block

        &gt;&gt;&gt; elem_attrs = exo.get_elem_attr(elem_blk_id)

        Parameters
        ----------
        elem_blk_id : int
            element block *ID* (not *INDEX*)

        Returns
        -------
            if array_type == &#39;ctype&#39; : &lt;list&lt;float&gt;&gt; elem_attrs
            if array_type == &#39;numpy&#39; : &lt;np_array&lt;float&gt;&gt; elem_attrs
                list of attribute values for all
                elements in the block; the list cycles
                through all attributes of the first
                element, then all attributes of the
                second element, etc. Attributes are
                ordered by the ordering of the names
                returned by exo.get_element_attribute_names()
        &#34;&#34;&#34;
        elem_attrs = self.__ex_get_elem_attr(elem_blk_id)
        if self.use_numpy:
            elem_attrs = ctype_to_numpy(self, elem_attrs)
        return elem_attrs

    # --------------------------------------------------------------------

    def get_elem_attr_values(self, elem_blk_id, elem_attr_name):
        &#34;&#34;&#34;
        get an attribute for each element in a block

        &gt;&gt;&gt; elem_attrs = exo.get_elem_attr(elem_blk_id)

        Parameters
        ----------
            &lt;int&gt;    elem_blk_id     element block *ID* (not *INDEX*)
            &lt;string&gt; elem_attr_name  element attribute name

        Returns
        -------
            if array_type == &#39;ctype&#39;: &lt;list&lt;float&gt;&gt;  values
            if array_type == &#39;numpy&#39;: &lt;np_array&lt;float&gt;&gt;  values
                array of values for the requested
                attribute.  Array has dimensions of
                1 x num_elem, where num_elem is the
                number of elements on the element block.
        &#34;&#34;&#34;
        # Determine index of requested attribute in attribute list
        elem_attr_names = self.get_element_attribute_names(elem_blk_id)
        a_ndx = elem_attr_names.index(elem_attr_name)

        values = self.__ex_get_one_attr(&#39;EX_ELEM_BLOCK&#39;, elem_blk_id, a_ndx)
        if self.use_numpy:
            values = ctype_to_numpy(self, values)
        return values

    # --------------------------------------------------------------------

    def put_elem_attr(self, elem_blk_id, elem_attrs):
        &#34;&#34;&#34;
        store all attributes for each element in a block

        &gt;&gt;&gt; exo.put_elem_attr(elem_blk_id, elem_attrs)

        Parameters
        ----------
        elem_blk_id : int
            element block *ID* (not *INDEX*)
            &lt;list&lt;float&gt;&gt;  elem_attrs     list of all attribute values for all
              elements in the block; the list
              cycles through all attributes of
              the first element, then all attributes
              of the second element, etc. Attributes
              are ordered by the ordering of the
              names returned by
              exo.get_element_attribute_names()
        &#34;&#34;&#34;
        self.__ex_put_elem_attr(elem_blk_id, elem_attrs)

    # --------------------------------------------------------------------

    def put_elem_attr_values(self, elem_blk_id, elem_attr_name, values):
        &#34;&#34;&#34;
        store an attribute for each element in a block

        &gt;&gt;&gt; exo.put_elem_attr_values(elem_blk_id, elem_attr_name, values)

        Parameters
        ----------
        elem_blk_id : int
            element block *ID* (not *INDEX*)
            &lt;string&gt;       elem_attr_name element attribute name
            &lt;list&lt;float&gt;&gt;  values         list of values for a single attribute
                                          on a element block.  List dimensions
                                          should be 1 x N_elem, where N_elem is
                                          the number of elements on the element
                                          block.
        &#34;&#34;&#34;
        # Determine index of requested attribute in attribute list
        elem_attr_names = self.get_element_attribute_names(elem_blk_id)
        a_ndx = elem_attr_names.index(elem_attr_name)
        self.__ex_put_one_attr(&#39;EX_ELEM_BLOCK&#39;, elem_blk_id, a_ndx, values)

    # --------------------------------------------------------------------

    def elem_type(self, object_id):
        &#34;&#34;&#34;
        get the element type, e.g. &#34;HEX8&#34;, for an element block

        &gt;&gt;&gt; elem_type = exo.elem_type(elem_blk_id)

        Parameters
        ----------
        elem_blk_id : int
            element block *ID* (not *INDEX*)

        Returns
        -------
            &lt;string&gt;  elem_type
        &#34;&#34;&#34;
        (elemType, _numElem, _nodesPerElem, _numAttr) = self.__ex_get_block(&#39;EX_ELEM_BLOCK&#39;, object_id)
        return elemType.value

    # --------------------------------------------------------------------

    def num_attr(self, object_id):
        &#34;&#34;&#34;
        get the number of attributes per element for an element block

        &gt;&gt;&gt; num_elem_attrs = exo.num_attr(elem_blk_id)

        Parameters
        ----------
        elem_blk_id : int
            element block *ID* (not *INDEX*)

        Returns
        -------
            &lt;int&gt;  num_elem_attrs
        &#34;&#34;&#34;
        (_elemType, _numElem, _nodesPerElem, numAttr) = self.__ex_get_block(&#39;EX_ELEM_BLOCK&#39;, object_id)
        return numAttr.value

    # --------------------------------------------------------------------

    def num_elems_in_blk(self, object_id):
        &#34;&#34;&#34;
        get the number of elements in an element block

        &gt;&gt;&gt; num_blk_elems = exo.num_elems_in_blk(elem_blk_id)

        Parameters
        ----------
        elem_blk_id : int
            element block *ID* (not *INDEX*)

        Returns
        -------
            &lt;int&gt;  num_blk_elems
        &#34;&#34;&#34;
        (_elemType, numElem, _nodesPerElem, _numAttr) = self.__ex_get_block(&#39;EX_ELEM_BLOCK&#39;, object_id)
        return numElem.value

    # --------------------------------------------------------------------

    def num_nodes_per_elem(self, object_id):
        &#34;&#34;&#34;
        get the number of nodes per element for an element block

        &gt;&gt;&gt; num_elem_nodes = exo.num_nodes_per_elem(elem_blk_id)

        Parameters
        ----------
        elem_blk_id : int
            element block *ID* (not *INDEX*)

        Returns
        -------
            &lt;int&gt;  num_elem_nodes
        &#34;&#34;&#34;
        (_elemType, _numElem, nodesPerElem, _numAttr) = self.__ex_get_block(&#39;EX_ELEM_BLOCK&#39;, object_id)
        return nodesPerElem.value

    # --------------------------------------------------------------------

    def get_element_variable_truth_table(self, entId=None):
        &#34;&#34;&#34;
        See `exodus.get_variable_truth_table`
        &#34;&#34;&#34;
        return self.get_variable_truth_table(&#39;EX_ELEM_BLOCK&#39;, entId)

    # --------------------------------------------------------------------

    def set_element_variable_truth_table(self, table):
        &#34;&#34;&#34;
        See `exodus.set_variable_truth_table`
        &#34;&#34;&#34;
        return self.set_variable_truth_table(&#39;EX_ELEM_BLOCK&#39;, table)

    # --------------------------------------------------------------------

    def get_element_variable_values(self, blockId, name, step):
        &#34;&#34;&#34;
        get list of element variable values for a specified element
        block, element variable name, and time step

        &gt;&gt;&gt; evar_vals = exo.get_element_variable_values(elem_blk_id,
        ...                                            evar_name, time_step)

        Parameters
        ----------
        elem_blk_id : int
            element block *ID* (not *INDEX*)
        evar_name : string
            name of element variable
        time_step : int
            1-based index of time step

        Returns
        -------

            if array_type == &#39;ctype&#39;:
              &lt;list&lt;ctypes.c_double&gt;&gt;  evar_vals

            if array_type == &#39;numpy&#39;:
              &lt;np_array&lt;double&gt;&gt;  evar_vals
        &#34;&#34;&#34;
        values = self.get_variable_values(&#39;EX_ELEM_BLOCK&#39;, blockId, name, step)
        return values

    # --------------------------------------------------------------------

    def get_partial_element_variable_values(self, blockId, name, step, start_index, num_elements):
        &#34;&#34;&#34;
        get list of element variable values for a specified element
        block, element variable name, and time step

        &gt;&gt;&gt; evar_vals = exo.get_element_variable_values(elem_blk_id,
        ...                                            evar_name, time_step)

        Parameters
        ----------
        elem_blk_id : int
            element block *ID* (not *INDEX*)
        evar_name : string
            name of element variable
        time_step : int
            1-based index of time step
        start_index: int
            1-based index of element in block to start returning data
        num_elements: int
            number of elements to return data for.

        Returns
        -------

            if array_type == &#39;ctype&#39;:
              &lt;list&lt;ctypes.c_double&gt;&gt;  evar_vals

            if array_type == &#39;numpy&#39;:
              &lt;np_array&lt;double&gt;&gt;  evar_vals
        &#34;&#34;&#34;
        names = self.get_variable_names(&#39;EX_ELEM_BLOCK&#39;)
        var_id = names.index(name) + 1
        values = self.__ex_get_partial_var(step, &#39;EX_ELEM_BLOCK&#39;, var_id, blockId, start_index, num_elements)
        if self.use_numpy:
            values = ctype_to_numpy(self, values)
        return values

    # --------------------------------------------------------------------

    def put_element_variable_values(self, blockId, name, step, values):
        &#34;&#34;&#34;
        store a list of element variable values for a specified element
        block, element variable name, and time step

        &gt;&gt;&gt; status = exo.put_element_variable_values(elem_blk_id,
        ...             evar_name, time_step, evar_vals)

        Parameters
        ----------
        elem_blk_id : int
            element block *ID* (not *INDEX*)
            &lt;string&gt;       evar_name    name of element variable
            &lt;int&gt;          time_step    1-based index of time step
            &lt;list&lt;float&gt;&gt;  evar_vals

        Returns
        -------
        status : bool
            True = successful execution
        &#34;&#34;&#34;
        self.put_variable_values(&#39;EX_ELEM_BLOCK&#39;, blockId, name, step, values)
        return True

    # --------------------------------------------------------------------

    def get_element_variable_number(self):
        &#34;&#34;&#34;
        get the number of element variables in the model

        &gt;&gt;&gt; num_evars = exo.get_element_variable_number()

        Returns
        -------
              &lt;int&gt;  num_evars
        &#34;&#34;&#34;
        return self.__ex_get_variable_param(&#39;EX_ELEM_BLOCK&#39;).value

    # --------------------------------------------------------------------

    def set_element_variable_number(self, number):
        &#34;&#34;&#34;
        update the number of element variables in the model

        &gt;&gt;&gt; status = exo.set_element_variable_number(num_evars)

        Parameters
        ----------
              &lt;int&gt;  num_evars

        Returns
        -------
        status : bool
            True = successful execution
        &#34;&#34;&#34;
        self.__ex_put_variable_param(&#39;EX_ELEM_BLOCK&#39;, number)
        return True

    # --------------------------------------------------------------------

    def get_element_variable_names(self):
        &#34;&#34;&#34;
        get the list of element variable names in the model

        &gt;&gt;&gt; evar_names = exo.get_element_variable_names()

        Returns
        -------
              &lt;list&lt;string&gt;&gt;  evar_names
        &#34;&#34;&#34;
        if self.__ex_get_variable_param(&#39;EX_ELEM_BLOCK&#39;).value == 0:
            return []
        return self.__ex_get_variable_names(&#39;EX_ELEM_BLOCK&#39;)

    # --------------------------------------------------------------------

    def put_element_variable_name(self, name, index):
        &#34;&#34;&#34;
        add the name and index of a new element variable to the model;
        element variable indexing goes from 1 to
        exo.get_element_variable_number()

        &gt;&gt;&gt; status = exo.put_element_variable_name(evar_name, evar_index)

        Parameters
        ----------
            &lt;string&gt;  evar_name   name of new element variable
            &lt;int&gt;     evar_index  1-based index of new element variable

        Returns
        -------
        status : bool
            True = successful execution

        Note:
        ----
        this method is often called within the following sequence:

        &gt;&gt;&gt; num_evars = exo.get_element_variable_number()
        &gt;&gt;&gt; new_evar_index = num_evars + 1
        &gt;&gt;&gt; num_evars += 1
        &gt;&gt;&gt; exo.set_element_variable_number(num_evars)
        &gt;&gt;&gt; exo.put_element_variable_name(&#34;new_evar&#34;, new_evar_index)
        &#34;&#34;&#34;
        EBvarNames = self.get_variable_names(&#39;EX_ELEM_BLOCK&#39;)
        if name in EBvarNames:
            print(&#34;WARNING: element variable \&#34;{}\&#34; already exists.&#34;.format(name))
        if index &gt; len(EBvarNames):
            print((&#34;index&#34;, index, &#34;len&#34;, len(EBvarNames)))
            raise Exception(&#34;ERROR: variable index out of range.&#34;)
        self.__ex_put_variable_name(&#39;EX_ELEM_BLOCK&#39;, index, name)
        return True

    # --------------------------------------------------------------------

    def get_element_attribute_names(self, blkId):
        &#34;&#34;&#34;
        get the list of element attribute names for a block

        &gt;&gt;&gt; attr_names = exo.get_element_attribute_names(elem_blk_id)

        Parameters
        ----------
        elem_blk_id : int
            element block *ID* (not *INDEX*)

        Returns
        -------
            &lt;list&lt;string&gt;&gt;  attr_names
        &#34;&#34;&#34;
        names = self.__ex_get_elem_attr_names(blkId)
        return list(names)

    # --------------------------------------------------------------------

    def put_element_attribute_names(self, blkId, names):
        &#34;&#34;&#34;
        store the list of element attribute names for a block

        &gt;&gt;&gt; status = exo.put_element_attribute_names(elem_blk_id, attr_names)

        Parameters
        ----------
        elem_blk_id : int
            element block *ID* (not *INDEX*)
            &lt;list&lt;string&gt;&gt;  attr_names

        Returns
        -------
        status : bool
            True = successful execution
        &#34;&#34;&#34;
        return self.__ex_put_elem_attr_names(blkId, names)

    # --------------------------------------------------------------------

    def get_element_property_names(self):
        &#34;&#34;&#34;
        get the list of element property names for all element blocks
        in the model

        &gt;&gt;&gt; eprop_names = exo.get_element_property_names()

        Returns
        -------
            &lt;list&lt;string&gt;&gt;  eprop_names
        &#34;&#34;&#34;
        names = self.__ex_get_prop_names(&#39;EX_ELEM_BLOCK&#39;, &#39;EX_INQ_EB_PROP&#39;)
        return list(names)

    # --------------------------------------------------------------------

    def get_element_property_value(self, object_id, name):
        &#34;&#34;&#34;
        get element property value (an integer) for a specified element
        block and element property name

        &gt;&gt;&gt; eprop_val = exo.get_element_property_value(elem_blk_id, eprop_name)

        Parameters
        ----------
        elem_blk_id : int
            element block *ID* (not *INDEX*)
            &lt;string&gt;  eprop_name

        Returns
        -------
            &lt;int&gt;  eprop_val
        &#34;&#34;&#34;
        propVal = self.__ex_get_prop(&#39;EX_ELEM_BLOCK&#39;, object_id, name)
        return int(propVal)

    # --------------------------------------------------------------------

    def put_element_property_value(self, object_id, name, value):
        &#34;&#34;&#34;
        store an element property name and its integer value for an
        element block

        &gt;&gt;&gt; status = exo.put_element_property_value(elem_blk_id,
        ...                                         eprop_name, eprop_val)


        Parameters
        ----------
        elem_blk_id : int
            element block *ID* (not *INDEX*)
            &lt;string&gt;  eprop_name
            &lt;int&gt;     eprop_val

        Returns
        -------
        status : bool
            True = successful execution
        &#34;&#34;&#34;
        return self.__ex_put_prop(&#39;EX_ELEM_BLOCK&#39;, object_id, name, value)

    # --------------------------------------------------------------------

    #
    # nodesets
    #
    # --------------------------------------------------------------------

    def num_node_sets(self):
        &#34;&#34;&#34;
        get the number of node sets in the model

        &gt;&gt;&gt; num_node_sets = exo.num_node_sets()

        Returns
        -------
            &lt;int&gt;  num_node_sets
        &#34;&#34;&#34;
        return self.numNodeSets.value

    # --------------------------------------------------------------------

    def get_node_set_ids(self):
        &#34;&#34;&#34;
        get mapping of exodus node set index to user- or application-
        defined node set id; node_set_ids is ordered
        by the *INDEX* ordering, a 1-based system going from
        1 to exo.num_node_sets(), used by exodus for storage
        and input/output of array data stored on the node sets; a
        user or application can optionally use a separate node set
        *ID* numbering system, so the node_set_ids array points to the
        node set *ID* for each node set *INDEX*

        &gt;&gt;&gt; node_set_ids = exo.get_ids(&#39;EX_NODE_SET&#39;)

        Returns
        -------

            if array_type == &#39;ctype&#39;:
              &lt;list&lt;int&gt;&gt;  node_set_ids

            if array_type == &#39;numpy&#39;:
              &lt;np_array&lt;int&gt;&gt;  node_set_ids
        &#34;&#34;&#34;
        return self.get_ids(&#39;EX_NODE_SET&#39;)

    # --------------------------------------------------------------------

    def get_node_set_name(self, object_id):
        &#34;&#34;&#34;
        get the name of a node set

        &gt;&gt;&gt; node_set_name = exo.get_node_set_name(node_set_id)

        Parameters
        ----------
            &lt;int&gt;  node_set_id  node set *ID* (not *INDEX*)

        Returns
        -------
            &lt;string&gt;  node_set_name
        &#34;&#34;&#34;
        return self.__ex_get_name(&#39;EX_NODE_SET&#39;, object_id)

    # --------------------------------------------------------------------

    def put_node_set_name(self, object_id, name):
        &#34;&#34;&#34;
        store the name of a node set

        &gt;&gt;&gt; exo.put_node_set_name(node_set_id, node_set_name)

        Parameters
        ----------
            &lt;int&gt;     node_set_id    node set *ID* (not *INDEX*)
            &lt;string&gt;  node_set_name
        &#34;&#34;&#34;
        self.__ex_put_name(&#39;EX_NODE_SET&#39;, object_id, name)

    # --------------------------------------------------------------------

    def get_node_set_names(self):
        &#34;&#34;&#34;
        get a list of all node set names ordered by node set *INDEX*;
        (see `exodus.get_ids` for explanation of the
        difference between node set *ID* and node set *INDEX*)

        &gt;&gt;&gt; node_set_names = exo.get_node_set_names()

        Returns
        -------
            &lt;list&lt;string&gt;&gt;  node_set_names
        &#34;&#34;&#34;
        nodeSetNames = self.__ex_get_names(&#39;EX_NODE_SET&#39;)
        return nodeSetNames

    # --------------------------------------------------------------------

    def put_node_set_names(self, names):
        &#34;&#34;&#34;
        store a list of all node set names ordered by node set *INDEX*;
        (see `exodus.get_ids` for explanation of the
        difference between node set *ID* and node set *INDEX*)

        &gt;&gt;&gt; exo.put_node_set_names(node_set_names)

        Parameters
        ----------
            &lt;list&lt;string&gt;&gt;  node_set_names
        &#34;&#34;&#34;
        self.__ex_put_names(&#39;EX_NODE_SET&#39;, names)

    # --------------------------------------------------------------------

    def num_nodes_in_node_set(self, object_id):
        &#34;&#34;&#34;
        get the number of nodes in a node set

        &gt;&gt;&gt; num_ns_nodes = exo.num_nodes_in_node_set(node_set_id)

        Parameters
        ----------
            &lt;int&gt;  node_set_id  node set *ID* (not *INDEX*)

        Returns
        -------
            &lt;int&gt;  num_ns_nodes
        &#34;&#34;&#34;
        node_set_nodes = self.get_node_set_nodes(object_id)
        return len(node_set_nodes)

    # --------------------------------------------------------------------

    def get_node_set_nodes(self, object_id):
        &#34;&#34;&#34;
        get the list of node *INDICES* in a node set
        (see `exodus.get_id_map` for explanation of node *INDEX*
        versus node *ID*)

        &gt;&gt;&gt; ns_nodes = exo.get_node_set_nodes(node_set_id)

        Parameters
        ----------
            &lt;int&gt;  node_set_id  node set *ID* (not *INDEX*)

        Returns
        -------

            if array_type == &#39;ctype&#39;:
              &lt;list&lt;int&gt;&gt;  ns_nodes

            if array_type == &#39;numpy&#39;:
              &lt;np_array&lt;int&gt;&gt;  ns_nodes
        &#34;&#34;&#34;
        node_set_ids = self.get_ids(&#39;EX_NODE_SET&#39;)
        assert object_id in node_set_ids
        node_set_nodes = self.__ex_get_node_set(object_id)
        node_set_nodes = list(node_set_nodes)
        if self.use_numpy:
            node_set_nodes = self.np.array(node_set_nodes)
        return node_set_nodes

    # --------------------------------------------------------------------

    def put_node_set(self, object_id, nodeSetNodes):
        &#34;&#34;&#34;
        store a node set by its id and the list of node *INDICES* in
        the node set (see `exodus.get_id_map` for explanation of node
        *INDEX* versus node *ID*)

        &gt;&gt;&gt; exo.put_node_set(node_set_id, ns_nodes)

        Parameters
        ----------
            &lt;int&gt;        node_set_id  node set *ID* (not *INDEX*)
            &lt;list&lt;int&gt;&gt;  ns_nodes
        &#34;&#34;&#34;
        self.__ex_put_node_set(object_id, nodeSetNodes)

    # --------------------------------------------------------------------

    def get_node_set_dist_facts(self, object_id):
        &#34;&#34;&#34;
        get the list of distribution factors for nodes in a node set

        &gt;&gt;&gt; ns_dist_facts = exo.get_node_set_dist_facts(node_set_id)

        Parameters
        ----------
            &lt;int&gt;        node_set_id  node set *ID* (not *INDEX*)

        Returns
        -------

            if array_type == &#39;ctype&#39;:
              &lt;list&lt;float&gt;&gt;  ns_dist_facts  a list of distribution factors,
                e.g. nodal &#39;weights&#39;

            if array_type == &#39;numpy&#39;:
              &lt;np_array&lt;double&gt;&gt;  ns_dist_facts  a list of distribution
                factors, e.g. nodal
                &#39;weights&#39;
        &#34;&#34;&#34;
        node_set_dfs = self.__ex_get_node_set_dist_fact(object_id)
        node_set_dfs = list(node_set_dfs)
        if self.use_numpy:
            node_set_dfs = self.np.array(node_set_dfs)
        return node_set_dfs

    # --------------------------------------------------------------------

    def put_node_set_dist_fact(self, object_id, nodeSetDistFact):
        &#34;&#34;&#34;
        store the list of distribution factors for nodes in a node set

        &gt;&gt;&gt; exo.put_node_set_dist_fact(node_set_id, ns_dist_facts)

        Parameters
        ----------
            &lt;int&gt;          node_set_id    node set *ID* (not *INDEX*)
            &lt;list&lt;float&gt;&gt;  ns_dist_facts  a list of distribution factors,
              e.g. nodal &#39;weights&#39;
        &#34;&#34;&#34;
        self.__ex_put_node_set_dist_fact(object_id, nodeSetDistFact)

    # --------------------------------------------------------------------

    def get_node_set_variable_number(self):
        &#34;&#34;&#34;
        get the number of node set variables in the model

        &gt;&gt;&gt; num_nsvars = exo.get_node_set_variable_number()

        Returns
        -------
              &lt;int&gt;  num_nsvars
        &#34;&#34;&#34;
        return self.__ex_get_variable_param(&#39;EX_NODE_SET&#39;).value

    # --------------------------------------------------------------------

    def set_node_set_variable_number(self, number):
        &#34;&#34;&#34;
        update the number of node set variables in the model

        &gt;&gt;&gt; status = exo.set_node_set_variable_number(num_nsvars)

        Parameters
        ----------
              &lt;int&gt;  num_nsvars

        Returns
        -------
        status : bool
            True = successful execution
        &#34;&#34;&#34;
        self.__ex_put_variable_param(&#39;EX_NODE_SET&#39;, number)
        return True

    # --------------------------------------------------------------------

    def get_node_set_variable_truth_table(self, entId=None):
        &#34;&#34;&#34;
        See `exodus.get_variable_truth_table`
        &#34;&#34;&#34;
        return self.get_variable_truth_table(&#39;EX_NODE_SET&#39;, entId)

    # --------------------------------------------------------------------

    def set_node_set_variable_truth_table(self, table):
        &#34;&#34;&#34;
        See `exodus.set_variable_truth_table`
        &#34;&#34;&#34;
        return self.set_variable_truth_table(&#39;EX_NODE_SET&#39;, table)

    # --------------------------------------------------------------------

    def get_node_set_variable_names(self):
        &#34;&#34;&#34;
        get the list of node set variable names in the model

        &gt;&gt;&gt; nsvar_names = exo.get_node_set_variable_names()

        Returns
        -------
              &lt;list&lt;string&gt;&gt;  nsvar_names
        &#34;&#34;&#34;
        if self.__ex_get_variable_param(&#39;EX_NODE_SET&#39;).value == 0:
            return []
        return self.__ex_get_variable_names(&#39;EX_NODE_SET&#39;)

    # --------------------------------------------------------------------

    def put_node_set_variable_name(self, name, index):
        &#34;&#34;&#34;
        add the name and index of a new node set variable to the model;
        node set variable indexing goes from 1 to
        exo.get_node_set_variable_number()

        &gt;&gt;&gt; status = exo.put_node_set_variable_name(nsvar_name, nsvar_index)

        Parameters
        ----------
            &lt;string&gt;  nsvar_name   name of new node set variable
            &lt;int&gt;     nsvar_index  1-based index of new node set variable

        Returns
        -------
        status : bool
            True = successful execution

        Note:
        -----
        this method is often called within the following sequence:

        &gt;&gt;&gt; num_nsvars = exo.get_node_set_variable_number()
        &gt;&gt;&gt; new_nsvar_index = num_nsvars + 1
        &gt;&gt;&gt; num_nsvars += 1
        &gt;&gt;&gt; exo.set_node_set_variable_number(num_nsvars)
        &gt;&gt;&gt; exo.put_node_set_variable_name(&#34;new_nsvar&#34;, new_nsvar_index)
        &#34;&#34;&#34;
        NSvarNames = self.get_variable_names(&#39;EX_NODE_SET&#39;)
        if name in NSvarNames:
            print(&#34;WARNING: Node set variable \&#34;{}\&#34; already exists.&#34;.format(name))
        if index &gt; len(NSvarNames):
            raise Exception(&#34;ERROR: variable index out of range.&#34;)
        self.__ex_put_variable_name(&#39;EX_NODE_SET&#39;, index, name)
        return True

    # --------------------------------------------------------------------

    def get_node_set_variable_values(self, object_id, name, step):
        &#34;&#34;&#34;
        get list of node set variable values for a specified node
        set, node set variable name, and time step; the list has
        one variable value per node in the set

        &gt;&gt;&gt; nsvar_vals =
        ...   exo.get_node_set_variable_values(node_set_id,
        ...    nsvar_name, time_step)

        Parameters
        ----------
            &lt;int&gt;     node_set_id  node set *ID* (not *INDEX*)
            &lt;string&gt;  nsvar_name   name of node set variable
            &lt;int&gt;     time_step    1-based index of time step

        Returns
        -------

            if array_type == &#39;ctype&#39;:
              &lt;list&lt;ctypes.c_double&gt;&gt;  nsvar_vals

            if array_type == &#39;numpy&#39;:
              &lt;np_array&lt;double&gt;&gt;  nsvar_vals
        &#34;&#34;&#34;
        values = self.get_variable_values(&#39;EX_NODE_SET&#39;, object_id, name, step)
        return values

    # --------------------------------------------------------------------

    def get_partial_node_set_variable_values(self, object_id, name, step, start_index, num_nodes):
        &#34;&#34;&#34;
        get list of node set variable values for a specified node
        set, node set variable name, and time step; the list has
        one variable value per node in the set

        &gt;&gt;&gt; nsvar_vals =
        ...   exo.get_node_set_variable_values(node_set_id,
        ...    nsvar_name, time_step)

        Parameters
        ----------
            &lt;int&gt;     node_set_id  node set *ID* (not *INDEX*)
            &lt;string&gt;  nsvar_name   name of node set variable
            &lt;int&gt;     time_step    1-based index of time step
            &lt;int&gt;     start_index 1-based index of node to start returning data
            &lt;int&gt;     num_nodes   number of nodes to return data for.

        Returns
        -------

            if array_type == &#39;ctype&#39;:
              &lt;list&lt;ctypes.c_double&gt;&gt;  nsvar_vals

            if array_type == &#39;numpy&#39;:
              &lt;np_array&lt;double&gt;&gt;  nsvar_vals
        &#34;&#34;&#34;
        names = self.get_variable_names(&#39;EX_NODE_SET&#39;)
        var_id = names.index(name) + 1
        values = self.__ex_get_partial_var(step, &#39;EX_NODE_SET&#39;, var_id, object_id, start_index, num_nodes)
        if self.use_numpy:
            values = ctype_to_numpy(self, values)
        return values

    # --------------------------------------------------------------------

    def put_node_set_variable_values(self, object_id, name, step, values):
        &#34;&#34;&#34;
        store a list of node set variable values for a specified node
        set, node set variable name, and time step; the list has one
        variable value per node in the set

        &gt;&gt;&gt; status =
        ... exo.put_node_set_variable_values(node_set_id,
        ...     nsvar_name, time_step, nsvar_vals)

        Parameters
        ----------
            &lt;int&gt;          node_set_id  node set *ID* (not *INDEX*)
            &lt;string&gt;       nsvar_name   name of node set variable
            &lt;int&gt;          time_step    1-based index of time step
            &lt;list&lt;float&gt;&gt;  nsvar_vals

        Returns
        -------
        status : bool
            True = successful execution
        &#34;&#34;&#34;
        self.put_variable_values(&#39;EX_NODE_SET&#39;, object_id, name, step, values)
        return True

    # --------------------------------------------------------------------

    def get_all_node_set_params(self):
        &#34;&#34;&#34;
        get total number of nodes and distribution factors (e.g. nodal
        &#39;weights&#39;) combined among all node sets

        &gt;&gt;&gt; tot_num_ns_nodes,
        ... tot_num_ns_dist_facts = exo.get_all_node_set_params()

        Returns
        -------
            &lt;int&gt;  tot_num_ns_nodes
            &lt;int&gt;  tot_num_ns_dist_facts
        &#34;&#34;&#34;
        nodeSetIds = self.__ex_get_ids(&#39;EX_NODE_SET&#39;)
        totNumSetNodes, totNumSetDistFacts = 0, 0
        for nodeSetId in nodeSetIds:
            (numSetNodes, numSetDistFacts) = self.__ex_get_set_param(&#39;EX_NODE_SET&#39;, nodeSetId)
            totNumSetNodes += numSetNodes
            totNumSetDistFacts += numSetDistFacts
        return totNumSetNodes, totNumSetDistFacts

    # --------------------------------------------------------------------

    def get_set_params(self, object_type, object_id):
        &#34;&#34;&#34;
        get number of entities and distribution factors (e.g. nodal
        &#39;weights&#39;) in the specified set

        &gt;&gt;&gt; num_ns_nodes, num_ns_dist_facts =
        ...     exo.get_set_params(&#39;EX_NODE_SET&#39;, node_set_id)

        Parameters
        ----------
        set_id : int
            set *ID* (not *INDEX*)

        Returns
        -------
        num_set_entities : int
        num_set_dist_facts : int
        &#34;&#34;&#34;
        (numSetEntities, numSetDistFacts) = self.__ex_get_set_param(object_type, object_id)
        return numSetEntities, numSetDistFacts

    # --------------------------------------------------------------------

    def put_set_params(self, object_type, object_id, numSetEntity, numSetDistFacts=None):
        &#34;&#34;&#34;
        initialize a new set of the specified type

        &gt;&gt;&gt; exo.put_set_params(&#39;EX_NODE_SET&#39;, node_set_id,
        ...                 num_ns_nodes, num_ns_dist_facts)

        Parameters
        ----------
        set_id : int
            set *ID* (not *INDEX*)
        num_set_entity : int
            number of nodes/edges/faces/elements to be added to set
        num_dist_facts : int, optional
            number of distribution factors (e.g. nodal &#39;weights&#39;) --
            must be equal to zero or num_set_entity
        &#34;&#34;&#34;
        if numSetDistFacts is None:
            numSetDistFacts = numSetEntity
        assert numSetDistFacts in (0, numSetEntity)
        self.__ex_put_set_param(object_type, object_id, numSetEntity, numSetDistFacts)

    # --------------------------------------------------------------------

    def get_node_set_params(self, object_id):
        &#34;&#34;&#34; See `exodus.put_set_params` &#34;&#34;&#34;

        (numSetNodes, numSetDistFacts) = self.__ex_get_set_param(&#39;EX_NODE_SET&#39;, object_id)
        return numSetNodes, numSetDistFacts

    # --------------------------------------------------------------------

    def put_node_set_params(self, object_id, numSetNodes, numSetDistFacts=None):
        &#34;&#34;&#34; See `exodus.put_set_params` &#34;&#34;&#34;
        if numSetDistFacts is None:
            numSetDistFacts = numSetNodes
        assert numSetDistFacts in (0, numSetNodes)
        self.__ex_put_set_param(&#39;EX_NODE_SET&#39;, object_id, numSetNodes, numSetDistFacts)

    # --------------------------------------------------------------------

    def get_node_set_property_names(self):
        &#34;&#34;&#34;
        get the list of node set property names for all node sets in
        the model

        &gt;&gt;&gt; nsprop_names = exo.get_node_set_property_names()

        Returns
        -------
            &lt;list&lt;string&gt;&gt;  nsprop_names
        &#34;&#34;&#34;
        names = self.__ex_get_prop_names(&#39;EX_NODE_SET&#39;, &#39;EX_INQ_NS_PROP&#39;)
        return list(names)

    # --------------------------------------------------------------------

    def get_node_set_property_value(self, object_id, name):
        &#34;&#34;&#34;
        get node set property value (an integer) for a specified node
        set and node set property name

        &gt;&gt;&gt; nsprop_val = exo.get_node_set_property_value(node_set_id, nsprop_name)

        Parameters
        ----------
            &lt;int&gt;     node_set_id  node set *ID* (not *INDEX*)
            &lt;string&gt;  nsprop_name

        Returns
        -------
            &lt;int&gt;  nsprop_val
        &#34;&#34;&#34;
        propVal = self.__ex_get_prop(&#39;EX_NODE_SET&#39;, object_id, name)
        return int(propVal)

    # --------------------------------------------------------------------

    def put_node_set_property_value(self, object_id, name, value):
        &#34;&#34;&#34;
        store a node set property name and its integer value for a
        node set

        &gt;&gt;&gt; status = exo.put_node_set_property_value(node_set_id,
        ...                   nsprop_name, nsprop_val)

        Parameters
        ----------
            &lt;int&gt;     node_set_id  node set *ID* (not *INDEX*)
            &lt;string&gt;  nsprop_name
            &lt;int&gt;     nsprop_val

        Returns
        -------
        status : bool
            True = successful execution
        &#34;&#34;&#34;
        return self.__ex_put_prop(&#39;EX_NODE_SET&#39;, object_id, name, value)

    #
    # sidesets
    #
    # --------------------------------------------------------------------

    def num_side_sets(self):
        &#34;&#34;&#34;
        get the number of side sets in the model

        &gt;&gt;&gt; num_side_sets = exo.num_side_sets()

        Returns
        -------
            &lt;int&gt;  num_side_sets
        &#34;&#34;&#34;
        return self.numSideSets.value

    # --------------------------------------------------------------------

    def get_side_set_ids(self):
        &#34;&#34;&#34;
        get mapping of exodus side set index to user- or application-
        defined side set id; side_set_ids is ordered
        by the *INDEX* ordering, a 1-based system going from
        1 to exo.num_side_sets(), used by exodus for storage
        and input/output of array data stored on the side sets; a
        user or application can optionally use a separate side set
        *ID* numbering system, so the side_set_ids array points to the
        side set *ID* for each side set *INDEX*

        &gt;&gt;&gt; side_set_ids = exo.get_ids(&#39;EX_SIDE_SET&#39;)

        Returns
        -------

            if array_type == &#39;ctype&#39;:
              &lt;list&lt;int&gt;&gt;  side_set_ids

            if array_type == &#39;numpy&#39;:
              &lt;np_array&lt;int&gt;&gt;  side_set_ids
        &#34;&#34;&#34;
        return self.get_ids(&#39;EX_SIDE_SET&#39;)

    # --------------------------------------------------------------------

    def get_side_set_name(self, object_id):
        &#34;&#34;&#34;
        get the name of a side set

        &gt;&gt;&gt; side_set_name = exo.get_side_set_name(side_set_id)

        Parameters
        ----------
            &lt;int&gt;  side_set_id  side set *ID* (not *INDEX*)

        Returns
        -------
            &lt;string&gt;  side_set_name
        &#34;&#34;&#34;
        return self.__ex_get_name(&#39;EX_SIDE_SET&#39;, object_id)

    # --------------------------------------------------------------------

    def put_side_set_name(self, object_id, name):
        &#34;&#34;&#34;
        store the name of a side set

        &gt;&gt;&gt; exo.put_side_set_name(side_set_id, side_set_name)

        Parameters
        ----------
            &lt;int&gt;     side_set_id    side set *ID* (not *INDEX*)
            &lt;string&gt;  side_set_name
        &#34;&#34;&#34;
        self.__ex_put_name(&#39;EX_SIDE_SET&#39;, object_id, name)

    # --------------------------------------------------------------------

    def get_side_set_names(self):
        &#34;&#34;&#34;
        get a list of all side set names ordered by side set *INDEX*;
        (see `exodus.get_ids` for explanation of the
        difference between side set *ID* and side set *INDEX*)

        &gt;&gt;&gt; side_set_names = exo.get_side_set_names()

        Returns
        -------
            &lt;list&lt;string&gt;&gt;  side_set_names
        &#34;&#34;&#34;
        return self.__ex_get_names(&#39;EX_SIDE_SET&#39;)

    # --------------------------------------------------------------------

    def put_side_set_names(self, names):
        &#34;&#34;&#34;
        store a list of all side set names ordered by side set *INDEX*;
        (see `exodus.get_ids` for explanation of the
        difference between side set *ID* and side set *INDEX*)

        &gt;&gt;&gt; exo.put_side_set_names(side_set_names)

        Parameters
        ----------
            &lt;list&lt;string&gt;&gt;  side_set_names
        &#34;&#34;&#34;
        self.__ex_put_names(&#39;EX_SIDE_SET&#39;, names)

    # --------------------------------------------------------------------

    def num_faces_in_side_set(self, object_id):
        &#34;&#34;&#34;
        get the number of faces in a side set

        &gt;&gt;&gt; num_ss_faces = exo.num_faces_in_side_set(side_set_id)

        Parameters
        ----------
            &lt;int&gt;  side_set_id  side set *ID* (not *INDEX*)

        Returns
        -------
            &lt;int&gt;  num_ss_faces
        &#34;&#34;&#34;
        ssids = self.get_ids(&#39;EX_SIDE_SET&#39;)
        if object_id not in ssids:
            print(&#34;WARNING: queried side set ID does not exist in database&#34;)
            return 0
        (num_side_in_set, _num_dist_fact_in_set) = self.__ex_get_set_param(&#39;EX_SIDE_SET&#39;, object_id)
        return num_side_in_set

    # --------------------------------------------------------------------

    def get_all_side_set_params(self):
        &#34;&#34;&#34;
        get total number of sides, nodes, and distribution factors
        (e.g. nodal &#39;weights&#39;) combined among all side sets

        &gt;&gt;&gt; tot_num_ss_sides, tot_num_ss_nodes, tot_num_ss_dist_facts =
        ...          exo.get_all_side_set_params()

        Returns
        -------
            &lt;int&gt;  tot_num_ss_sides
            &lt;int&gt;  tot_num_ss_nodes
            &lt;int&gt;  tot_num_ss_dist_facts

        Note:
        -----
        The number of nodes (and distribution factors) in a side set is
        the sum of all face nodes.  A single node can be counted more
        than once, i.e. once for each face it belongs to in the side set.
        &#34;&#34;&#34;
        ids = self.__ex_get_ids(&#39;EX_SIDE_SET&#39;)
        totNumSetSides, totNumSetDistFacts = 0, 0  # totNumSetDistFacts = totNumSetNodes
        for sideSetId in ids:
            (numSetSides, numSetDistFacts) = self.__ex_get_set_param(&#39;EX_SIDE_SET&#39;, sideSetId)
            totNumSetSides += numSetSides
            totNumSetDistFacts += numSetDistFacts
        totNumSetNodes = totNumSetDistFacts
        return totNumSetSides, totNumSetNodes, totNumSetDistFacts

    # --------------------------------------------------------------------

    def get_side_set_params(self, object_id):
        &#34;&#34;&#34;
        get number of sides and nodal distribution factors (e.g. nodal
        &#39;weights&#39;) in a side set

        &gt;&gt;&gt; num_ss_sides, num_ss_dist_facts = exo.get_side_set_params(side_set_id)

        Parameters
        ----------
            &lt;int&gt;  side_set_id  side set *ID* (not *INDEX*)

        Returns
        -------
            &lt;int&gt;  num_ss_sides
            &lt;int&gt;  num_ss_dist_facts

        Note:
        -----
        The number of nodes (and distribution factors) in a side set is
        the sum of all face nodes.  A single node can be counted more
        than once, i.e. once for each face it belongs to in the side set.
        &#34;&#34;&#34;
        (numSetSides, numSetDistFacts) = self.__ex_get_set_param(&#39;EX_SIDE_SET&#39;, object_id)
        return numSetSides, numSetDistFacts

    # --------------------------------------------------------------------

    def put_side_set_params(self, object_id, numSetSides, numSetDistFacts):
        &#34;&#34;&#34;
        initialize a new side set

        &gt;&gt;&gt; exo.put_side_set_params(side_set_id, num_ss_sides, num_ss_dist_facts)

        Parameters
        ----------
            &lt;int&gt;  side_set_id        side set *ID* (not *INDEX*)
            &lt;int&gt;  num_ss_sides       number of sides to be added to set
            &lt;int&gt;  num_ss_dist_facts  number of nodal distribution factors
              (e.g. nodal &#39;weights&#39;)

        Note:
        -----
        The number of nodes (and distribution factors) in a side set is
        the sum of all face nodes.  A single node can be counted more
        than once, i.e. once for each face it belongs to in the side set.
        &#34;&#34;&#34;
        self.__ex_put_set_param(&#39;EX_SIDE_SET&#39;, object_id, numSetSides, numSetDistFacts)

    # --------------------------------------------------------------------

    def get_side_set(self, object_id):
        &#34;&#34;&#34;
        get the lists of element and side indices in a side set; the
        two lists correspond: together, ss_elems[i] and ss_sides[i]
        define the face of an element

        &gt;&gt;&gt; ss_elems, ss_sides = exo.get_side_set(side_set_id)

        Parameters
        ----------
            &lt;int&gt;  side_set_id  side set *ID* (not *INDEX*)

        Returns
        -------

            if array_type == &#39;ctype&#39;:
              &lt;list&lt;int&gt;&gt;  ss_elems
              &lt;list&lt;int&gt;&gt;  ss_sides

            if array_type == &#39;numpy&#39;:
              &lt;np_array&lt;int&gt;&gt;  ss_elems
              &lt;np_array&lt;int&gt;&gt;  ss_sides
        &#34;&#34;&#34;
        (side_set_elem_list, side_set_side_list) = self.__ex_get_side_set(object_id)
        if self.use_numpy:
            side_set_elem_list = ctype_to_numpy(self, side_set_elem_list)
            side_set_side_list = ctype_to_numpy(self, side_set_side_list)
        return side_set_elem_list, side_set_side_list

    # --------------------------------------------------------------------

    def put_side_set(self, object_id, sideSetElements, sideSetSides):
        &#34;&#34;&#34;
        store a side set by its id and the lists of element and side
        indices in the side set; the two lists correspond: together,
        ss_elems[i] and ss_sides[i] define the face of an element

        &gt;&gt;&gt; exo.put_side_set(side_set_id, ss_elems, ss_sides)

        Parameters
        ----------
            &lt;int&gt;        side_set_id  side set *ID* (not *INDEX*)
            &lt;list&lt;int&gt;&gt;  ss_elems
            &lt;list&lt;int&gt;&gt;  ss_sides
        &#34;&#34;&#34;
        self.__ex_put_side_set(object_id, sideSetElements, sideSetSides)

    # --------------------------------------------------------------------

    def get_side_set_dist_fact(self, object_id):
        &#34;&#34;&#34;
        get the list of distribution factors for nodes in a side set

        &gt;&gt;&gt; ss_dist_facts = exo.get_side_set_dist_fact(side_set_id)

        Parameters
        ----------
            &lt;int&gt;        side_set_id  side set *ID* (not *INDEX*)

        Returns
        -------

            if array_type == &#39;ctype&#39;:
              &lt;list&lt;float&gt;&gt;  ss_dist_facts  a list of distribution factors,
                e.g. nodal &#39;weights&#39;

            if array_type == &#39;numpy&#39;:
              &lt;np_array&lt;double&gt;&gt;  ss_dist_facts  a list of distribution
                factors, e.g. nodal
                &#39;weights&#39;

        Note:
        -----
        The number of nodes (and distribution factors) in a side set is
        the sum of all face nodes.  A single node can be counted more
        than once, i.e. once for each face it belongs to in the side set.
        &#34;&#34;&#34;
        side_set_dfs = list(self.__ex_get_side_set_dist_fact(object_id))
        if self.use_numpy:
            side_set_dfs = self.np.array(side_set_dfs)
        return side_set_dfs

    # --------------------------------------------------------------------

    def put_side_set_dist_fact(self, object_id, sideSetDistFact):
        &#34;&#34;&#34;
        store the list of distribution factors for nodes in a side set

        &gt;&gt;&gt; exo.put_side_set_dist_fact(side_set_id, ss_dist_facts)

        Parameters
        ----------
            &lt;int&gt;          node_set_id    node set *ID* (not *INDEX*)
            &lt;list&lt;float&gt;&gt;  ns_dist_facts  a list of distribution factors,
              e.g. nodal &#39;weights&#39;

        Note:
        -----
        The number of nodes (and distribution factors) in a side set is
        the sum of all face nodes.  A single node can be counted more
        than once, i.e. once for each face it belongs to in the side set.
        &#34;&#34;&#34;
        self.__ex_put_side_set_dist_fact(object_id, sideSetDistFact)

    # --------------------------------------------------------------------

    def get_side_set_node_list(self, object_id):
        &#34;&#34;&#34;
        get two lists:
         1. number of nodes for each side in the set
         2. concatenation of the nodes for each side in the set

        &gt;&gt;&gt; ss_num_nodes_per_side, ss_nodes = exo.get_side_set_node_list(side_set_id)

        Parameters
        ----------
            &lt;int&gt;        side_set_id  side set *ID* (not *INDEX*)

        Returns
        -------

            if array_type == &#39;ctype&#39;:
              &lt;list&lt;int&gt;&gt;  ss_num_side_nodes
              &lt;list&lt;int&gt;&gt;  ss_nodes

            if array_type == &#39;numpy&#39;:
              &lt;np_array&lt;int&gt;&gt;  ss_num_side_nodes
              &lt;np_array&lt;int&gt;&gt;  ss_nodes

        Note:
        -----
        The number of nodes (and distribution factors) in a side set is
        the sum of all face nodes.  A single node can be counted more
        than once, i.e. once for each face it belongs to in the side set.
        &#34;&#34;&#34;
        (side_set_node_cnt_list,
         side_set_node_list) = self.__ex_get_side_set_node_list(object_id)
        if self.use_numpy:
            side_set_node_cnt_list = ctype_to_numpy(
                self, side_set_node_cnt_list)
            side_set_node_list = ctype_to_numpy(self, side_set_node_list)
        return side_set_node_cnt_list, side_set_node_list

    # --------------------------------------------------------------------

    def get_side_set_variable_truth_table(self, entId=None):
        &#34;&#34;&#34;
        See `exodus.get_variable_truth_table`
        &#34;&#34;&#34;
        return self.get_variable_truth_table(&#39;EX_SIDE_SET&#39;, entId)

    # --------------------------------------------------------------------

    def set_side_set_variable_truth_table(self, table):
        &#34;&#34;&#34;
        See `exodus.set_variable_truth_table`
        &#34;&#34;&#34;
        return self.set_variable_truth_table(&#39;EX_SIDE_SET&#39;, table)

    # --------------------------------------------------------------------

    def get_side_set_variable_number(self):
        &#34;&#34;&#34;
        get the number of side set variables in the model

        &gt;&gt;&gt; num_ssvars = exo.get_side_set_variable_number()

        Returns
        -------
              &lt;int&gt;  num_ssvars
        &#34;&#34;&#34;
        return self.__ex_get_variable_param(&#39;EX_SIDE_SET&#39;).value

    # --------------------------------------------------------------------

    def set_side_set_variable_number(self, number):
        &#34;&#34;&#34;
        update the number of side set variables in the model

        &gt;&gt;&gt; status = exo.set_side_set_variable_number(num_ssvars)

        Parameters
        ----------
              &lt;int&gt;  num_ssvars

        Returns
        -------
        status : bool
            True = successful execution
        &#34;&#34;&#34;
        self.__ex_put_variable_param(&#39;EX_SIDE_SET&#39;, number)
        return True

    # --------------------------------------------------------------------

    def get_side_set_variable_names(self):
        &#34;&#34;&#34;
        get the list of side set variable names in the model

        &gt;&gt;&gt; ssvar_names = exo.get_side_set_variable_names()

        Returns
        -------
              &lt;list&lt;string&gt;&gt;  ssvar_names
        &#34;&#34;&#34;
        if self.__ex_get_variable_param(&#39;EX_SIDE_SET&#39;).value == 0:
            return []
        return self.__ex_get_variable_names(&#39;EX_SIDE_SET&#39;)

    # --------------------------------------------------------------------

    def put_side_set_variable_name(self, name, index):
        &#34;&#34;&#34;
        add the name and index of a new side set variable to the model;
        side set variable indexing goes from 1 to
        exo.get_side_set_variable_number()

        &gt;&gt;&gt; status = exo.put_side_set_variable_name(ssvar_name, ssvar_index)

        Parameters
        ----------
            &lt;string&gt;  ssvar_name   name of new side set variable
            &lt;int&gt;     ssvar_index  1-based index of new side set variable

        Returns
        -------
        status : bool
            True = successful execution

        Note:
        -----
        this method is often called within the following sequence:

        &gt;&gt;&gt; num_ssvars = exo.get_side_set_variable_number()
        &gt;&gt;&gt; new_ssvar_index = num_ssvars + 1
        &gt;&gt;&gt; num_ssvars += 1
        &gt;&gt;&gt; exo.set_side_set_variable_number(num_ssvars)
        &gt;&gt;&gt; exo.put_side_set_variable_name(&#34;new_ssvar&#34;, new_ssvar_index)

        &#34;&#34;&#34;
        SSvarNames = self.get_variable_names(&#39;EX_SIDE_SET&#39;)
        if name in SSvarNames:
            print(&#34;WARNING: Side set variable \&#34;{}\&#34; already exists.&#34;.format(name))
        if index &gt; len(SSvarNames):
            raise Exception(&#34;ERROR: variable index out of range.&#34;)
        self.__ex_put_variable_name(&#39;EX_SIDE_SET&#39;, index, name)
        return True

    # --------------------------------------------------------------------

    def get_side_set_variable_values(self, object_id, name, step):
        &#34;&#34;&#34;
        get list of side set variable values for a specified side
        set, side set variable name, and time step; the list has
        one variable value per side in the set

        &gt;&gt;&gt; ssvar_vals = exo.get_side_set_variable_values(side_set_id,
        ...    ssvar_name, time_step)

        Parameters
        ----------
            &lt;int&gt;     side_set_id  side set *ID* (not *INDEX*)
            &lt;string&gt;  ssvar_name   name of side set variable
            &lt;int&gt;     time_step    1-based index of time step

        Returns
        -------

            if array_type == &#39;ctype&#39;:
              &lt;list&lt;ctypes.c_double&gt;&gt;  ssvar_vals

            if array_type == &#39;numpy&#39;:
              &lt;np_array&lt;double&gt;&gt;  ssvar_vals
        &#34;&#34;&#34;
        values = self.get_variable_values(&#39;EX_SIDE_SET&#39;, object_id, name, step)
        return values

    # --------------------------------------------------------------------

    def get_partial_side_set_variable_values(self, object_id, name, step, start_index, num_sides):
        &#34;&#34;&#34;
        get list of side set variable values for a specified side
        set, side set variable name, and time step; the list has
        one variable value per side in the set

        &gt;&gt;&gt; ssvar_vals = exo.get_side_set_variable_values(side_set_id,
        ...    ssvar_name, time_step)

        Parameters
        ----------
            &lt;int&gt;     side_set_id  side set *ID* (not *INDEX*)
            &lt;string&gt;  ssvar_name   name of side set variable
            &lt;int&gt;     time_step    1-based index of time step
            &lt;int&gt;     start_index 1-based index of side to start returning data
            &lt;int&gt;     num_nodes   number of sides to return data for.

        Returns
        -------

            if array_type == &#39;ctype&#39;:
              &lt;list&lt;ctypes.c_double&gt;&gt;  ssvar_vals

            if array_type == &#39;numpy&#39;:
              &lt;np_array&lt;double&gt;&gt;  ssvar_vals
        &#34;&#34;&#34;
        names = self.get_variable_names(&#39;EX_SIDE_SET&#39;)
        var_id = names.index(name) + 1
        values = self.__ex_get_partial_var(step, &#39;EX_SIDE_SET&#39;, var_id, object_id, start_index, num_sides)
        if self.use_numpy:
            values = ctype_to_numpy(self, values)
        return values

    # --------------------------------------------------------------------

    def put_side_set_variable_values(self, object_id, name, step, values):
        &#34;&#34;&#34;
        store a list of side set variable values for a specified side
        set, side set variable name, and time step; the list has one
        variable value per side in the set

        &gt;&gt;&gt; status = exo.put_side_set_variable_values(side_set_id,
        ...              ssvar_name, time_step, ssvar_vals)

        Parameters
        ----------
            &lt;int&gt;          side_set_id  side set *ID* (not *INDEX*)
            &lt;string&gt;       ssvar_name   name of side set variable
            &lt;int&gt;          time_step    1-based index of time step
            &lt;list&lt;float&gt;&gt;  ssvar_vals

        Returns
        -------
        status : bool
            True = successful execution
        &#34;&#34;&#34;
        self.put_variable_values(&#39;EX_SIDE_SET&#39;, object_id, name, step, values)
        return True

    # --------------------------------------------------------------------

    def get_side_set_property_names(self):
        &#34;&#34;&#34;
        get the list of side set property names for all side sets in
        the model

        &gt;&gt;&gt; ssprop_names = exo.get_side_set_property_names()

        Returns
        -------
            &lt;list&lt;string&gt;&gt;  ssprop_names
        &#34;&#34;&#34;
        names = self.__ex_get_prop_names(&#39;EX_SIDE_SET&#39;, &#39;EX_INQ_SS_PROP&#39;)
        return list(names)

    # --------------------------------------------------------------------

    def get_side_set_property_value(self, object_id, name):
        &#34;&#34;&#34;
        get side set property value (an integer) for a specified side
        set and side set property name

        &gt;&gt;&gt; ssprop_val = exo.get_side_set_property_value(side_set_id, ssprop_name)

        Parameters
        ----------
            &lt;int&gt;     side_set_id  side set *ID* (not *INDEX*)
            &lt;string&gt;  ssprop_name

        Returns
        -------
            &lt;int&gt;  ssprop_val
        &#34;&#34;&#34;
        propVal = self.__ex_get_prop(&#39;EX_SIDE_SET&#39;, object_id, name)
        return int(propVal)

    # --------------------------------------------------------------------

    def put_side_set_property_value(self, object_id, name, value):
        &#34;&#34;&#34;
        store a side set property name and its integer value for a
        side set

        &gt;&gt;&gt; status = exo.put_side_set_property_value(side_set_id,
        ...               ssprop_name, ssprop_val)

        Parameters
        ----------
            &lt;int&gt;     side_set_id  side set *ID* (not *INDEX*)
            &lt;string&gt;  ssprop_name
            &lt;int&gt;     ssprop_val

        Returns
        -------
        status : bool
            True = successful execution
        &#34;&#34;&#34;
        return self.__ex_put_prop(&#39;EX_SIDE_SET&#39;, object_id, name, value)

    #
    # global variables
    #
    # --------------------------------------------------------------------

    def get_global_variable_number(self):
        &#34;&#34;&#34;
        get the number of global variables in the model

        &gt;&gt;&gt; num_gvars = exo.get_global_variable_number()

        Returns
        -------
              &lt;int&gt;  num_gvars
        &#34;&#34;&#34;
        return self.__ex_get_variable_param(&#39;EX_GLOBAL&#39;).value

    # --------------------------------------------------------------------

    def set_global_variable_number(self, number):
        &#34;&#34;&#34;
        update the number of global variables in the model

        &gt;&gt;&gt; status = exo.set_global_variable_number(num_gvars)

        Parameters
        ----------
              &lt;int&gt;  num_gvars

        Returns
        -------
        status : bool
            True = successful execution
        &#34;&#34;&#34;
        self.__ex_put_variable_param(&#39;EX_GLOBAL&#39;, number)
        return True

    # --------------------------------------------------------------------

    def get_global_variable_names(self):
        &#34;&#34;&#34;
        get the list of global variable names in the model

        &gt;&gt;&gt; gvar_names = exo.get_global_variable_names()

        Returns
        -------
              &lt;list&lt;string&gt;&gt;  gvar_names
        &#34;&#34;&#34;
        if self.get_variable_number(&#39;EX_GLOBAL&#39;) == 0:
            return []
        return self.__ex_get_variable_names(&#39;EX_GLOBAL&#39;)

    # --------------------------------------------------------------------

    def put_global_variable_name(self, name, index):
        &#34;&#34;&#34;
        add the name and index of a new global variable to the model;
        global variable indexing goes from 1 to
        exo.get_global_variable_number()

        &gt;&gt;&gt; status = exo.put_global_variable_name(gvar_name, gvar_index)

        Parameters
        ----------
            &lt;string&gt;  gvar_name   name of new global variable
            &lt;int&gt;     gvar_index  1-based index of new global variable

        Returns
        -------
        status : bool
            True = successful execution

        Note:
        -----
        this method is often called within the following sequence:

        &gt;&gt;&gt; num_gvars = exo.get_global_variable_number()
        &gt;&gt;&gt; new_gvar_index = num_gvars + 1
        &gt;&gt;&gt; num_gvars += 1
        &gt;&gt;&gt; exo.set_global_variable_number(num_gvars)
        &gt;&gt;&gt; exo.put_global_variable_name(&#34;new_gvar&#34;, new_gvar_index)
        &#34;&#34;&#34;
        GlobVarNames = self.get_variable_names(&#39;EX_GLOBAL&#39;)
        if name in GlobVarNames:
            print(&#34;WARNING: Global variable \&#34;{}\&#34; already exists.&#34;.format(name))
        if index &gt; len(GlobVarNames):
            print((&#34;index&#34;, index, &#34;len&#34;, len(GlobVarNames)))
            raise Exception(&#34;ERROR: variable index out of range.&#34;)
        self.__ex_put_variable_name(&#39;EX_GLOBAL&#39;, index, name)
        return True

    # --------------------------------------------------------------------

    def get_global_variable_value(self, name, step):
        &#34;&#34;&#34;
        get a global variable value for a specified global variable
        name and time step

        &gt;&gt;&gt; gvar_val = exo.get_global_variable_value(gvar_name, time_step)

        Parameters
        ----------
            &lt;string&gt;  gvar_name  name of global variable
            &lt;int&gt;     time_step  1-based index of time step

        Returns
        -------
            &lt;float&gt;  gvar_val
        &#34;&#34;&#34;
        names = self.get_variable_names(&#39;EX_GLOBAL&#39;)
        var_id = names.index(name)
        num = self.__ex_get_variable_param(&#39;EX_GLOBAL&#39;)
        gvalues = self.__ex_get_var(step, &#39;EX_GLOBAL&#39;, 0, 1, num.value)
        return gvalues[var_id]

    # --------------------------------------------------------------------

    def get_all_global_variable_values(self, step):
        &#34;&#34;&#34;
        get all global variable values (one for each global variable
        name, and in the order given by exo.get_global_variable_names())
        at a specified time step

        &gt;&gt;&gt; gvar_vals = exo.get_all_global_variable_values(time_step)

        Parameters
        ----------
            &lt;int&gt;     time_step  1-based index of time step

        Returns
        -------

            if array_type == &#39;ctype&#39;:
              &lt;list&lt;float&gt;&gt;  gvar_vals

            if array_type == &#39;numpy&#39;:
              &lt;np_array&lt;double&gt;&gt;  gvar_vals
        &#34;&#34;&#34;
        num = self.__ex_get_variable_param(&#39;EX_GLOBAL&#39;)
        gvalues = self.__ex_get_var(step, &#39;EX_GLOBAL&#39;, 0, 1, num.value)
        values = []
        for i in range(num.value):
            values.append(gvalues[i])
        if self.use_numpy:
            values = self.np.array(values)
        return values

    # --------------------------------------------------------------------

    def put_global_variable_value(self, name, step, value):
        &#34;&#34;&#34;
        store a global variable value for a specified global variable
        name and time step

        &gt;&gt;&gt; status = exo.put_global_variable_value(gvar_name, time_step, gvar_val)

        Parameters
        ----------
            &lt;string&gt;  gvar_name  name of global variable
            &lt;int&gt;     time_step  1-based index of time step
            &lt;float&gt;   gvar_val

        Returns
        -------
        status : bool
            True = successful execution
        &#34;&#34;&#34;
        # we must write all values at once, not individually
        names = self.get_variable_names(&#39;EX_GLOBAL&#39;)
        # get all values
        numVals = self.get_variable_number(&#39;EX_GLOBAL&#39;)
        values = (ctypes.c_double * numVals)()
        for i in range(numVals):
            values[i] = ctypes.c_double(
                self.get_global_variable_value(
                    names[i], step))
        # adjust one of them
        values[names.index(name)] = ctypes.c_double(value)
        # write them all
        EXODUS_LIB.ex_put_glob_vars(self.fileId,
                                    ctypes.c_int(step),
                                    ctypes.c_int(numVals),
                                    values)
        return True

    # --------------------------------------------------------------------

    def put_all_global_variable_values(self, step, values):
        &#34;&#34;&#34;
        store all global variable values (one for each global variable
        name, and in the order given by exo.get_global_variable_names())
        at a specified time step

        &gt;&gt;&gt; status = exo.put_all_global_variable_values(time_step, gvar_vals)

        Parameters
        ----------
            &lt;int&gt;          time_step  1-based index of time step
            &lt;list&lt;float&gt;&gt;  gvar_vals

        Returns
        -------
        status : bool
            True = successful execution
        &#34;&#34;&#34;
        numVals = self.get_variable_number(&#39;EX_GLOBAL&#39;)
        gvalues = (ctypes.c_double * numVals)()
        for i in range(numVals):
            gvalues[i] = ctypes.c_double(values[i])
        EXODUS_LIB.ex_put_glob_vars(self.fileId,
                                    ctypes.c_int(step),
                                    ctypes.c_int(numVals),
                                    gvalues)
        return True

    # --------------------------------------------------------------------

    def get_global_variable_values(self, name):
        &#34;&#34;&#34;
        get global variable values over all time steps for one global
        variable name

        &gt;&gt;&gt; gvar_vals = exo.get_global_variable_values(gvar_name)

        Parameters
        ----------
            &lt;string&gt;  gvar_name  name of global variable

        Returns
        -------

            if array_type == &#39;ctype&#39;:
              &lt;list&lt;float&gt;&gt;  gvar_vals

            if array_type == &#39;numpy&#39;:
              &lt;np_array&lt;double&gt;&gt;  gvar_vals
        &#34;&#34;&#34;
        names = self.get_variable_names(&#39;EX_GLOBAL&#39;)
        var_id = names.index(name)
        num = self.__ex_get_variable_param(&#39;EX_GLOBAL&#39;)
        values = []
        for i in range(self.numTimes.value):
            gvalues = self.__ex_get_var(i + 1, &#39;EX_GLOBAL&#39;, 0, 1, num.value)
            values.append(gvalues[var_id])
        if self.use_numpy:
            values = self.np.array(values)
        return values

    # --------------------------------------------------------------------

    def put_polyhedra_elem_blk(self, blkID,
                               num_elems_this_blk,
                               num_faces,
                               num_attr_per_elem):
        &#34;&#34;&#34;
        put in an element block with polyhedral elements

        &gt;&gt;&gt; status = exo.put_polyhedra_elem_blk(blkID, num_elems_this_blk,
        ...                                     num_faces, num_attr_per_elem)

        Parameters
        ----------
            &lt;int&gt;     blkID               id of the block to be added
            &lt;int&gt;     num_elems_this_blk
            &lt;int&gt;     num_faces  total number of faces in this block
            &lt;int&gt;     num_attr_per_elem

        Returns
        -------
        status : bool
            True = successful execution
        &#34;&#34;&#34;

        ebType = ctypes.c_int(get_entity_type(&#39;EX_ELEM_BLOCK&#39;))
        EXODUS_LIB.ex_put_block(self.fileId, ebType, ctypes.c_longlong(blkID),
                                ctypes.create_string_buffer(b&#34;NFACED&#34;),
                                ctypes.c_longlong(num_elems_this_blk),
                                ctypes.c_longlong(0),
                                ctypes.c_longlong(0),
                                ctypes.c_longlong(num_faces),
                                ctypes.c_longlong(num_attr_per_elem))
        return True

    # --------------------------------------------------------------------

    def put_polyhedra_face_blk(self, blkID,
                               num_faces_this_blk,
                               num_nodes,
                               num_attr_per_face):
        &#34;&#34;&#34;
        put in a block of faces

        &gt;&gt;&gt; status = exo.put_polyhedra_face_blk(blkID, num_faces_this_blk,
        ...                                     num_nodes, num_attr_per_face)

        Parameters
        ----------
            &lt;int&gt;     blkID               id of the block to be added
            &lt;int&gt;     num_faces_this_blk
            &lt;int&gt;     num_nodes           total number of nodes in this block
            &lt;int&gt;     num_attr_per_face

        Returns
        -------
        status : bool
            True = successful execution
        &#34;&#34;&#34;
        fbType = ctypes.c_int(get_entity_type(&#39;EX_FACE_BLOCK&#39;))
        EXODUS_LIB.ex_put_block(self.fileId, fbType, ctypes.c_longlong(blkID),
                                ctypes.create_string_buffer(b&#34;NSIDED&#34;),
                                ctypes.c_longlong(num_faces_this_blk),
                                ctypes.c_longlong(num_nodes),
                                ctypes.c_longlong(0),
                                ctypes.c_longlong(0),
                                ctypes.c_longlong(num_attr_per_face))
        return True

    # --------------------------------------------------------------------

    def put_face_count_per_polyhedra(self, blkID, entityCounts):
        &#34;&#34;&#34;
        put in a count of faces in for each polyhedra in an elem block

        &gt;&gt;&gt; status = exo.put_face_count_per_polyhedra(blkID, entityCounts)

        Parameters
        ----------
            &lt;int&gt;     blkID               id of the block to be added

            if array_type == &#39;ctype&#39;:
              &lt;list&lt;float&gt;&gt;  entityCounts

            if array_type == &#39;numpy&#39;:
              &lt;np_array&lt;double&gt;&gt;  entityCounts

        Returns
        -------
        status : bool
            True = successful execution
        &#34;&#34;&#34;
        ebType = ctypes.c_int(get_entity_type(&#39;EX_ELEM_BLOCK&#39;))
        entity_counts = (ctypes.c_int * len(entityCounts))()
        entity_counts[:] = entityCounts
        EXODUS_LIB.ex_put_entity_count_per_polyhedra(
            self.fileId, ebType, ctypes.c_longlong(blkID), entity_counts)
        return True

    # --------------------------------------------------------------------

    def put_node_count_per_face(self, blkID, entityCounts):
        &#34;&#34;&#34;
        put in a count of nodes in for each face in a polygonal face block

        &gt;&gt;&gt; status = exo.put_node_count_per_face(blkID, entityCounts)

        Parameters
        ----------
            &lt;int&gt;     blkID               id of the block to be added

            if array_type == &#39;ctype&#39;:
              &lt;list&lt;float&gt;&gt;  entityCounts

            if array_type == &#39;numpy&#39;:
              &lt;np_array&lt;double&gt;&gt;  entityCounts

        Returns
        -------
        status : bool
            True = successful execution
        &#34;&#34;&#34;
        ebType = ctypes.c_int(get_entity_type(&#39;EX_FACE_BLOCK&#39;))
        entity_counts = (ctypes.c_int * len(entityCounts))()
        entity_counts[:] = entityCounts
        EXODUS_LIB.ex_put_entity_count_per_polyhedra(
            self.fileId, ebType, ctypes.c_longlong(blkID), entity_counts)
        return True

    # --------------------------------------------------------------------

    def put_elem_face_conn(self, blkId, elemFaceConn):
        &#34;&#34;&#34;
        put in connectivity information from elems to faces

        &gt;&gt;&gt; status = exo.put_elem_face_conn(blkID, elemFaceConn)

        Parameters
        ----------
            &lt;int&gt;     blkID               id of the elem block to be added

            if array_type == &#39;ctype&#39;:
              &lt;list&lt;float&gt;&gt;  elemFaceConn  (raveled/flat list)

            if array_type == &#39;numpy&#39;:
              &lt;np_array&lt;double&gt;&gt;  elemFaceConn  (raveled/flat array)

        Returns
        -------
        status : bool
            True = successful execution
        &#34;&#34;&#34;
        ebType = ctypes.c_int(get_entity_type(&#39;EX_ELEM_BLOCK&#39;))
        elem_face_conn = (ctypes.c_int * len(elemFaceConn))()
        elem_face_conn[:] = elemFaceConn
        EXODUS_LIB.ex_put_conn(self.fileId, ebType, ctypes.c_longlong(blkId),
                               None, None, elem_face_conn)
        return True

    # --------------------------------------------------------------------

    def put_face_node_conn(self, blkId, faceNodeConn):
        &#34;&#34;&#34;
        put in connectivity information from faces to nodes

        &gt;&gt;&gt; status = exo.put_face_node_conn(blkID, faceNodeConn)

        Parameters
        ----------
            &lt;int&gt;     blkID               id of the face block to be added

            if array_type == &#39;ctype&#39;:
              &lt;list&lt;float&gt;&gt;  faceNodeConn  (raveled/flat list)

            if array_type == &#39;numpy&#39;:
              &lt;np_array&lt;double&gt;&gt;  faceNodeConn  (raveled/flat array)

        Returns
        -------
        status : bool
            True = successful execution
        &#34;&#34;&#34;
        ebType = ctypes.c_int(get_entity_type(&#39;EX_FACE_BLOCK&#39;))
        node_conn = (ctypes.c_int * len(faceNodeConn))()
        node_conn[:] = faceNodeConn
        EXODUS_LIB.ex_put_conn(self.fileId, ebType, ctypes.c_longlong(blkId),
                               node_conn, None, None)
        return True

    # --------------------------------------------------------------------

    def close(self):
        &#34;&#34;&#34;
        close the exodus file

        &gt;&gt;&gt; exo.close()

        Note:
        -----
        Can only be called once for an exodus object, and once called
        all methods for that object become inoperable
        &#34;&#34;&#34;
        print((&#34;Closing exodus file: &#34; + self.fileName))
        errorInt = EXODUS_LIB.ex_close(self.fileId)
        if errorInt != 0:
            raise Exception(
                &#34;ERROR: Closing file &#34; +
                self.fileName +
                &#34; had problems.&#34;)

    # --------------------------------------------------------------------
    #
    # Private Exodus API calls
    #
    # --------------------------------------------------------------------

    def __open(self, io_size=0):
        print((&#34;Opening exodus file: &#34; + self.fileName))
        self.mode = EX_READ
        if self.modeChar.lower() == &#34;a&#34;:
            self.mode = EX_WRITE
        if self.modeChar.lower() == &#34;w+&#34;:
            self.mode = EX_CLOBBER

        if self.modeChar.lower() in [
                &#34;a&#34;, &#34;r&#34;] and not os.path.isfile(self.fileName):
            raise Exception(
                &#34;ERROR: Cannot open &#34; +
                self.fileName +
                &#34; for read. Does not exist.&#34;)
        elif self.modeChar.lower() == &#34;w&#34; and os.path.isfile(self.fileName):
            raise Exception(&#34;ERROR: Cowardly not opening &#34; + self.fileName +
                            &#34; for write. File already exists.&#34;)
        elif self.modeChar.lower() not in [&#34;a&#34;, &#34;r&#34;, &#34;w&#34;, &#34;w+&#34;]:
            raise Exception(
                &#34;ERROR: File open mode &#34; +
                self.modeChar +
                &#34; unrecognized.&#34;)

        self.comp_ws = ctypes.c_int(8)
        self.io_ws = ctypes.c_int(io_size)
        self.version = ctypes.c_float(0.0)
        if self.modeChar.lower() in [&#34;a&#34;, &#34;r&#34;]:  # open existing file
            self.fileId = EXODUS_LIB.ex_open_int(self.fileName.encode(&#39;ascii&#39;), self.mode,
                                                 ctypes.byref(self.comp_ws),
                                                 ctypes.byref(self.io_ws),
                                                 ctypes.byref(self.version),
                                                 EX_API_VERSION_NODOT)
        else:  # create file
            if io_size == 0:
                io_size = 8
                self.io_ws = ctypes.c_int(io_size)
            self.__create()

    # --------------------------------------------------------------------

    def __create(self):
        self.fileId = EXODUS_LIB.ex_create_int(self.fileName.encode(&#39;ascii&#39;), self.mode,
                                               ctypes.byref(self.comp_ws),
                                               ctypes.byref(self.io_ws),
                                               EX_API_VERSION_NODOT)

    # --------------------------------------------------------------------

    def __copy_file(self, fileId, include_transient=False):
        if include_transient:
            EXODUS_LIB.ex_copy(self.fileId, fileId)
            EXODUS_LIB.ex_copy_transient(self.fileId, fileId)
        else:
            EXODUS_LIB.ex_copy(self.fileId, fileId)

    # --------------------------------------------------------------------

    def __ex_get_info(self):
        self.Title = ctypes.create_string_buffer(MAX_LINE_LENGTH + 1)
        if EXODUS_LIB.ex_int64_status(self.fileId) &amp; EX_BULK_INT64_API:
            self.numDim = ctypes.c_longlong(0)
            self.numNodes = ctypes.c_longlong(0)
            self.numElem = ctypes.c_longlong(0)
            self.numElemBlk = ctypes.c_longlong(0)
            self.numNodeSets = ctypes.c_longlong(0)
            self.numSideSets = ctypes.c_longlong(0)
            self.numAssembly = ctypes.c_longlong(0)
            self.numBlob = ctypes.c_longlong(0)
        else:
            self.numDim = ctypes.c_int(0)
            self.numNodes = ctypes.c_int(0)
            self.numElem = ctypes.c_int(0)
            self.numElemBlk = ctypes.c_int(0)
            self.numNodeSets = ctypes.c_int(0)
            self.numSideSets = ctypes.c_int(0)
            self.numAssembly = ctypes.c_int(0)
            self.numBlob = ctypes.c_int(0)
        EXODUS_LIB.ex_get_init(
            self.fileId, self.Title,
            ctypes.byref(self.numDim),
            ctypes.byref(self.numNodes),
            ctypes.byref(self.numElem),
            ctypes.byref(self.numElemBlk),
            ctypes.byref(self.numNodeSets),
            ctypes.byref(self.numSideSets))

    # --------------------------------------------------------------------

    def __ex_put_info(self, info):
        self.Title = ctypes.create_string_buffer(info[0].encode(&#39;ascii&#39;), MAX_LINE_LENGTH + 1)
        self.numDim = ctypes.c_longlong(info[1])
        self.numNodes = ctypes.c_longlong(info[2])
        self.numElem = ctypes.c_longlong(info[3])
        self.numElemBlk = ctypes.c_longlong(info[4])
        self.numNodeSets = ctypes.c_longlong(info[5])
        self.numSideSets = ctypes.c_longlong(info[6])
        EXODUS_LIB.ex_put_init(
            self.fileId,
            self.Title,
            self.numDim,
            self.numNodes,
            self.numElem,
            self.numElemBlk,
            self.numNodeSets,
            self.numSideSets)
        self.version = self.__ex_inquire_float(ex_inquiry_map(&#39;EX_INQ_DB_VERS&#39;))

    # --------------------------------------------------------------------

    def __ex_put_concat_elem_blk(self, elemBlkIDs, elemType, numElemThisBlk,
                                 numNodesPerElem, numAttr, defineMaps):
        if EXODUS_LIB.ex_int64_status(self.fileId) &amp; EX_IDS_INT64_API:
            elem_blk_ids = (ctypes.c_longlong * len(elemBlkIDs))()
            elem_blk_ids[:] = elemBlkIDs
            num_elem_this_blk = (ctypes.c_longlong
                                 * len(elemBlkIDs))()
            num_elem_this_blk[:] = numElemThisBlk
            num_nodes_per_elem = (ctypes.c_longlong * len(elemBlkIDs))()
            num_nodes_per_elem[:] = numNodesPerElem
            num_attr = (ctypes.c_longlong * len(elemBlkIDs))()
            num_attr[:] = numAttr
        else:
            elem_blk_ids = (ctypes.c_int * len(elemBlkIDs))()
            elem_blk_ids[:] = elemBlkIDs
            num_elem_this_blk = (ctypes.c_int * len(elemBlkIDs))()
            num_elem_this_blk[:] = numElemThisBlk
            num_nodes_per_elem = (ctypes.c_int * len(elemBlkIDs))()
            num_nodes_per_elem[:] = numNodesPerElem
            num_attr = (ctypes.c_int * len(elemBlkIDs))()
            num_attr[:] = numAttr
        elem_type = (ctypes.c_char_p * len(elemBlkIDs))()
        elem_type[:] = elemType
        define_maps = ctypes.c_int(defineMaps)
        EXODUS_LIB.ex_put_concat_elem_block(
            self.fileId,
            elem_blk_ids,
            elem_type,
            num_elem_this_blk,
            num_nodes_per_elem,
            num_attr,
            define_maps)

    # --------------------------------------------------------------------

    def __ex_get_qa(self):
        num_qa_recs = ctypes.c_int(self.__ex_inquire_int(ex_inquiry_map(&#39;EX_INQ_QA&#39;)))
        qa_rec_ptrs = ((ctypes.POINTER(ctypes.c_char * (MAX_STR_LENGTH + 1)) * 4) * num_qa_recs.value)()
        for i in range(num_qa_recs.value):
            for j in range(4):
                qa_rec_ptrs[i][j] = ctypes.pointer(
                    ctypes.create_string_buffer(MAX_STR_LENGTH + 1))
        if num_qa_recs.value:
            EXODUS_LIB.ex_get_qa(self.fileId, ctypes.byref(qa_rec_ptrs))
        qa_recs = []
        for qara in qa_rec_ptrs:
            qa_rec_list = []
            for ptr in qara:
                qa_rec_list.append(ptr.contents.value.decode(&#34;utf8&#34;))
            qa_rec_tuple = tuple(qa_rec_list)
            assert len(qa_rec_tuple) == 4
            qa_recs.append(qa_rec_tuple)
        return qa_recs

    # --------------------------------------------------------------------

    def __ex_put_qa(self, qaRecs):
        num_qa_recs = ctypes.c_int(len(qaRecs))
        qa_rec_ptrs = ((ctypes.POINTER(ctypes.c_char * (MAX_STR_LENGTH + 1)) * 4) * num_qa_recs.value)()
        for i in range(num_qa_recs.value):
            for j in range(4):
                qa_rec_ptrs[i][j] = ctypes.pointer(ctypes.create_string_buffer(
                    str(qaRecs[i][j]).encode(&#39;ascii&#39;), MAX_STR_LENGTH + 1))
        EXODUS_LIB.ex_put_qa(self.fileId, num_qa_recs, ctypes.byref(qa_rec_ptrs))
        return True

    # --------------------------------------------------------------------

    def _ex_get_info_recs_quietly(self):
        num_infos = ctypes.c_int(self.__ex_inquire_int(ex_inquiry_map(&#39;EX_INQ_INFO&#39;)))
        info_ptrs = (ctypes.POINTER(ctypes.c_char * (MAX_LINE_LENGTH + 1)) * num_infos.value)()
        for i in range(num_infos.value):
            info_ptrs[i] = ctypes.pointer(ctypes.create_string_buffer(MAX_LINE_LENGTH + 1))
        if num_infos.value:
            EXODUS_LIB.ex_get_info(self.fileId, ctypes.byref(info_ptrs))
        info_recs = []
        for irp in info_ptrs:
            info_recs.append(irp.contents.value.decode(&#34;utf8&#34;))
        return info_recs

    # --------------------------------------------------------------------

    def __ex_get_info_recs(self):
        num_infos = ctypes.c_int(self.__ex_inquire_int(ex_inquiry_map(&#39;EX_INQ_INFO&#39;)))
        info_ptrs = (ctypes.POINTER(ctypes.c_char * (MAX_LINE_LENGTH + 1)) * num_infos.value)()
        for i in range(num_infos.value):
            info_ptrs[i] = ctypes.pointer(ctypes.create_string_buffer(MAX_LINE_LENGTH + 1))
        EXODUS_LIB.ex_get_info(self.fileId, ctypes.byref(info_ptrs))
        info_recs = []
        for irp in info_ptrs:
            info_recs.append(irp.contents.value.decode(&#34;utf8&#34;))
        for rec in info_recs:
            if len(rec) &gt; MAX_LINE_LENGTH:
                print(&#34;WARNING: max line length reached for one or more info records;&#34;)
                print(&#34;         info might be incomplete for these records&#34;)
                break
        return info_recs

    # --------------------------------------------------------------------

    def __ex_put_info_recs(self, infoRecs):
        num_infos = ctypes.c_int(len(infoRecs))
        info_ptrs = (ctypes.POINTER(ctypes.c_char * (MAX_LINE_LENGTH + 1)) * num_infos.value)()
        for i in range(num_infos.value):
            info_ptrs[i] = ctypes.pointer(ctypes.create_string_buffer(
                str(infoRecs[i]).encode(&#39;ascii&#39;), MAX_LINE_LENGTH + 1))
        EXODUS_LIB.ex_put_info(self.fileId, num_infos, ctypes.byref(info_ptrs))
        return True

    # --------------------------------------------------------------------

    def __ex_inquire_float(self, inq_id):
        dummy_char = ctypes.create_string_buffer(MAX_LINE_LENGTH + 1)
        ret_float = ctypes.c_float(0.0)
        if EXODUS_LIB.ex_int64_status(self.fileId) &amp; EX_INQ_INT64_API:
            dummy_int = ctypes.c_longlong(0)
        else:
            dummy_int = ctypes.c_int(0)
        val = EXODUS_LIB.ex_inquire(
            self.fileId,
            inq_id,
            ctypes.byref(dummy_int),
            ctypes.byref(ret_float),
            dummy_char)
        if val &lt; 0:
            raise Exception(
                &#34;ERROR: ex_inquire(&#34; +
                str(inq_id) +
                &#34;) failed on &#34; +
                self.fileName)
        return ret_float

    # --------------------------------------------------------------------

    def __ex_inquire_int(self, inq_id):
        val = EXODUS_LIB.ex_inquire_int(self.fileId, inq_id)
        if val &lt; 0:
            raise Exception(
                &#34;ERROR: ex_inquire_int(&#34; +
                str(inq_id) +
                &#34;) failed on &#34; +
                self.fileName)
        return val

    # --------------------------------------------------------------------

    def __ex_get_coord_names(self):
        coord_name_ptrs = (
            ctypes.POINTER(ctypes.c_char * (MAX_NAME_LENGTH + 1)) * self.numDim.value)()
        for i in range(self.numDim.value):
            coord_name_ptrs[i] = ctypes.pointer(
                ctypes.create_string_buffer(
                    MAX_NAME_LENGTH + 1))
        EXODUS_LIB.ex_get_coord_names(self.fileId, ctypes.byref(coord_name_ptrs))
        coord_names = []
        for cnp in coord_name_ptrs:
            coord_names.append(cnp.contents.value.decode(&#39;utf8&#39;))
        return coord_names

    # --------------------------------------------------------------------

    def __ex_put_coord_names(self, names):
        coord_name_ptrs = (
            ctypes.POINTER(ctypes.c_char * (MAX_NAME_LENGTH + 1)) * self.numDim.value)()
        assert len(names) == self.numDim.value
        for i in range(self.numDim.value):
            coord_name_ptrs[i] = ctypes.pointer(
                ctypes.create_string_buffer(
                    names[i].encode(&#39;ascii&#39;), MAX_NAME_LENGTH + 1))
        EXODUS_LIB.ex_put_coord_names(self.fileId, ctypes.byref(coord_name_ptrs))

    # --------------------------------------------------------------------

    def __ex_get_all_times(self):
        self.times = (ctypes.c_double * self.numTimes.value)()
        EXODUS_LIB.ex_get_all_times(self.fileId, ctypes.byref(self.times))

    # --------------------------------------------------------------------

    def __ex_get_time(self, timeStep):
        time_step = ctypes.c_int(timeStep)
        time_val = ctypes.c_double(0.0)
        EXODUS_LIB.ex_get_time(self.fileId, time_step, ctypes.byref(time_val))
        return time_val.value()

    # --------------------------------------------------------------------

    def __ex_put_time(self, timeStep, timeVal):
        time_step = ctypes.c_int(timeStep)
        time_val = ctypes.c_double(timeVal)
        EXODUS_LIB.ex_put_time(self.fileId, time_step, ctypes.byref(time_val))
        return True

    # --------------------------------------------------------------------

    def __ex_get_name(self, objType, objId):
        obj_type = ctypes.c_int(get_entity_type(objType))
        obj_id = ctypes.c_longlong(objId)
        obj_name = ctypes.create_string_buffer(MAX_NAME_LENGTH + 1)
        EXODUS_LIB.ex_get_name(self.fileId, obj_type, obj_id, ctypes.byref(obj_name))
        return obj_name.value.decode(&#39;utf8&#39;)

    # --------------------------------------------------------------------

    def __ex_put_name(self, objType, objId, objName):
        obj_type = ctypes.c_int(get_entity_type(objType))
        obj_id = ctypes.c_longlong(objId)
        obj_name = ctypes.create_string_buffer(objName.encode(&#39;ascii&#39;), MAX_NAME_LENGTH + 1)
        EXODUS_LIB.ex_put_name(self.fileId, obj_type, obj_id, obj_name)

    # --------------------------------------------------------------------

    def __ex_get_names(self, objType):
        inqType = ex_inquiry_map(ex_obj_to_inq(objType))
        num_objs = ctypes.c_int(self.__ex_inquire_int(inqType)).value
        obj_name_ptrs = (ctypes.POINTER(ctypes.c_char * (MAX_NAME_LENGTH + 1)) * num_objs)()
        for i in range(num_objs):
            obj_type = ctypes.c_int(get_entity_type(objType))
            obj_name_ptrs[i] = ctypes.pointer(
                    ctypes.create_string_buffer(
                            MAX_NAME_LENGTH + 1))

        EXODUS_LIB.ex_get_names(self.fileId, obj_type, ctypes.byref(obj_name_ptrs))
        obj_names = []
        for onp in obj_name_ptrs:
            obj_names.append(onp.contents.value.decode(&#39;utf8&#39;))
        return obj_names

    # --------------------------------------------------------------------

    def __ex_put_names(self, objType, objNames):
        inqType = ex_inquiry_map(ex_obj_to_inq(objType))
        numObjs = ctypes.c_int(self.__ex_inquire_int(inqType)).value
        assert numObjs == len(objNames)
        obj_name_ptrs = (ctypes.POINTER(ctypes.c_char * (MAX_NAME_LENGTH + 1)) * numObjs)()
        obj_type = ctypes.c_int(get_entity_type(objType))
        for i in range(numObjs):
            obj_name_ptrs[i] = ctypes.pointer(
                ctypes.create_string_buffer(
                    objNames[i].encode(&#39;ascii&#39;), MAX_NAME_LENGTH + 1))
        EXODUS_LIB.ex_put_names(self.fileId, obj_type, ctypes.byref(obj_name_ptrs))

    # --------------------------------------------------------------------

    def __ex_get_ids(self, objType):
        inqType = ex_inquiry_map(ex_obj_to_inq(objType))
        numObjs = ctypes.c_int(self.__ex_inquire_int(inqType)).value
        if EXODUS_LIB.ex_int64_status(self.fileId) &amp; EX_IDS_INT64_API:
            ids = (ctypes.c_longlong * numObjs)()
        else:
            ids = (ctypes.c_int * numObjs)()
        if numObjs &gt; 0:
            obj_type = ctypes.c_int(get_entity_type(objType))
            EXODUS_LIB.ex_get_ids(self.fileId, obj_type, ctypes.byref(ids))
        return ids

    # --------------------------------------------------------------------

    def __ex_get_assembly(self, assem_struct):
        EXODUS_LIB.ex_get_assembly(self.fileId, ctypes.byref(assem_struct))
        ptr = ctypes.create_string_buffer(MAX_NAME_LENGTH+1)
        assem_struct.name = ctypes.cast(ptr, ctypes.c_char_p)
        eptr = (ctypes.c_longlong * assem_struct.entity_count)()
        assem_struct.entity_list = eptr
        EXODUS_LIB.ex_get_assembly(self.fileId, ctypes.byref(assem_struct))

    # --------------------------------------------------------------------

    def __ex_get_assemblies(self, assem_list):
        EXODUS_LIB.ex_get_assemblies(self.fileId, assem_list)
        for assem_struct in assem_list:
            ptr = ctypes.create_string_buffer(MAX_NAME_LENGTH + 1)
            assem_struct.name = ctypes.cast(ptr, ctypes.c_char_p)
            eptr = (ctypes.c_longlong * assem_struct.entity_count)()
            assem_struct.entity_list = eptr
        EXODUS_LIB.ex_get_assemblies(self.fileId, assem_list)

    # --------------------------------------------------------------------

    def __ex_get_blob(self, blob_struct):
        EXODUS_LIB.ex_get_blob(self.fileId, ctypes.byref(blob_struct))
        ptr = ctypes.create_string_buffer(MAX_NAME_LENGTH+1)
        blob_struct.name = ctypes.cast(ptr, ctypes.c_char_p)
        EXODUS_LIB.ex_get_blob(self.fileId, ctypes.byref(blob_struct))


    # --------------------------------------------------------------------

    def __ex_put_assembly(self, assembly):
        assem = setup_ex_assembly(assembly)
        EXODUS_LIB.ex_put_assembly(self.fileId, assem)

    # --------------------------------------------------------------------

    def __ex_put_assemblies(self, assemblies):
        assembly_list = []
        for assembly in assemblies:
            assem = setup_ex_assembly(assembly)
            assembly_list.append(assem)
        assems = (ex_assembly * len(assemblies))(*assembly_list)

        EXODUS_LIB.ex_put_assemblies(self.fileId, len(assembly_list), assems)


    # --------------------------------------------------------------------

    def __ex_get_attributes(self, objType, objId):
        # Get attribute count...
        obj_type = ctypes.c_int(get_entity_type(objType))
        obj_id = ctypes.c_longlong(objId)
        att_count = EXODUS_LIB.ex_get_attribute_count(self.fileId, obj_type, obj_id)

        attributes = dict()
        if att_count &gt; 0:
            att = (ex_attribute * att_count)()
            EXODUS_LIB.ex_get_attribute_param(self.fileId, obj_type, obj_id, ctypes.byref(att))
            for i in range(att_count):
                EXODUS_LIB.ex_get_attribute(self.fileId, ctypes.byref(att[i]))
                tmp_att = attribute(att[i].name.decode(&#39;utf8&#39;), ex_obj_to_name(att[i].entity_type), att[i].entity_id)

                if (att[i].type == 2):
                    vals = ctypes.cast(att[i].values, ctypes.POINTER(ctypes.c_char))
                    tmp = []
                    for j in range(att[i].value_count-1):
                        tmp.append(vals[j])
                    tmp_att.values = b&#39;&#39;.join(tmp).decode(&#39;utf8&#39;)

                if (att[i].type == 4):
                    vals = ctypes.cast(att[i].values, ctypes.POINTER(ctypes.c_int))
                    for j in range(att[i].value_count):
                        tmp_att.values.append(vals[j])

                if (att[i].type == 6):
                    vals = ctypes.cast(att[i].values, ctypes.POINTER(ctypes.c_double))
                    for j in range(att[i].value_count):
                        tmp_att.values.append(vals[j])

                attributes[att[i].name.decode(&#39;utf8&#39;)] = tmp_att

        return attributes

    # --------------------------------------------------------------------

    def __ex_put_attribute(self, attribute):
        att_id = ctypes.c_longlong(attribute.entity_id)
        att = ex_attribute(entity_id=att_id)
        att.name = attribute.name.encode(&#39;ascii&#39;)
        att.entity_type = ctypes.c_int(get_entity_type(attribute.entity_type))
        att.value_count = len(attribute.values)

        if (isinstance(attribute.values[0], int)):
            eptr = (c_int * len(attribute.values))()
            for i in range(len(attribute.values)):
               eptr[i] = ctypes.c_int(attribute.values[i])
            att.values = ctypes.cast(eptr, ctypes.c_void_p)
            att.type = 4

        elif (isinstance(attribute.values[0], float)):
            eptr = (c_double * len(attribute.values))()
            for i in range(len(attribute.values)):
              eptr[i] = ctypes.c_double(attribute.values[i])
            att.values = ctypes.cast(eptr, ctypes.c_void_p)
            att.type = 6

        elif (isinstance(attribute.values[0], str)):
            eptr = (c_char * (len(attribute.values)+1))()
            eptr = attribute.values[0].encode(&#39;ascii&#39;)
            att.values = ctypes.cast(eptr, ctypes.c_void_p)
            att.type = 2

        EXODUS_LIB.ex_put_attribute(self.fileId, att)

    # --------------------------------------------------------------------

    def __ex_get_node_set(self, nodeSetId):
        node_set_id = ctypes.c_longlong(nodeSetId)
        num_node_set_nodes = self.__ex_get_set_param(&#39;EX_NODE_SET&#39;, nodeSetId)[0]
        if num_node_set_nodes == 0:
            return []
        if EXODUS_LIB.ex_int64_status(self.fileId) &amp; EX_BULK_INT64_API:
            set_nodes = (ctypes.c_longlong * num_node_set_nodes)()
        else:
            set_nodes = (ctypes.c_int * num_node_set_nodes)()
        EXODUS_LIB.ex_get_node_set(self.fileId, node_set_id, ctypes.byref(set_nodes))
        return set_nodes

    # --------------------------------------------------------------------

    def __ex_put_node_set(self, nodeSetId, nodeSetNodes):
        node_set_id = ctypes.c_longlong(nodeSetId)
        if EXODUS_LIB.ex_int64_status(self.fileId) &amp; EX_BULK_INT64_API:
            node_set_nodes = (ctypes.c_longlong * len(nodeSetNodes))()
            for i, node_set_node in enumerate(nodeSetNodes):
                node_set_nodes[i] = ctypes.c_longlong(node_set_node)
        else:
            node_set_nodes = (ctypes.c_int * len(nodeSetNodes))()
            for i, node_set_node in enumerate(nodeSetNodes):
                node_set_nodes[i] = ctypes.c_int(node_set_node)
        EXODUS_LIB.ex_put_node_set(self.fileId, node_set_id, node_set_nodes)

    # --------------------------------------------------------------------

    def __ex_get_node_set_dist_fact(self, nodeSetId):
        node_set_id = ctypes.c_longlong(nodeSetId)
        num_node_set_nodes = self.__ex_get_set_param(&#39;EX_NODE_SET&#39;, nodeSetId)[0]
        set_dfs = (ctypes.c_double * num_node_set_nodes)()
        EXODUS_LIB.ex_get_node_set_dist_fact(
            self.fileId, node_set_id, ctypes.byref(set_dfs))
        return set_dfs

    # --------------------------------------------------------------------

    def __ex_put_node_set_dist_fact(self, nodeSetId, nodeSetDistFact):
        node_set_id = ctypes.c_longlong(nodeSetId)
        node_set_dist_fact = (ctypes.c_double * len(nodeSetDistFact))()
        for i, dist_fact in enumerate(nodeSetDistFact):
            node_set_dist_fact[i] = ctypes.c_double(dist_fact)
        EXODUS_LIB.ex_put_node_set_dist_fact(
            self.fileId, node_set_id, node_set_dist_fact)

    # --------------------------------------------------------------------

    def __ex_get_object_truth_vector(self, objType, entId):
        obj_type = ctypes.c_int(get_entity_type(objType))
        entity_id = ctypes.c_longlong(entId)
        variable_count = self.__ex_get_variable_param(objType)
        truth_table = (ctypes.c_int * (variable_count.value))()

        EXODUS_LIB.ex_get_object_truth_vector(self.fileId, obj_type,
                                              entity_id, variable_count,
                                              ctypes.byref(truth_table))
        truthTab = []
        for val in truth_table:
            if val:
                truthTab.append(True)
            else:
                truthTab.append(False)
        return truthTab

    # --------------------------------------------------------------------

    def __ex_get_truth_table(self, objType):
        inqType = ex_inquiry_map(ex_obj_to_inq(objType))
        num_objs = ctypes.c_int(self.__ex_inquire_int(inqType)).value

        obj_type = ctypes.c_int(get_entity_type(objType))
        variable_count = self.__ex_get_variable_param(objType)

        truth_table = (ctypes.c_int * (num_objs * variable_count.value))()
        EXODUS_LIB.ex_get_truth_table(self.fileId, obj_type,
                                      num_objs, variable_count,
                                      ctypes.byref(truth_table))
        truthTab = []
        for val in truth_table:
            if val:
                truthTab.append(True)
            else:
                truthTab.append(False)
        return truthTab

    # --------------------------------------------------------------------

    def __ex_put_truth_table(self, objType, truthTab):
        inqType = ex_inquiry_map(ex_obj_to_inq(objType))
        num_objs = ctypes.c_int(self.__ex_inquire_int(inqType)).value

        obj_type = ctypes.c_int(get_entity_type(objType))
        num_vars = self.__ex_get_variable_param(objType).value

        assert len(truthTab) == (num_objs * num_vars)

        truth_tab = (ctypes.c_int * (num_objs * num_vars))()
        for i, boolVal in enumerate(truthTab):
            if boolVal:
                truth_tab[i] = ctypes.c_int(1)
            else:
                truth_tab[i] = ctypes.c_int(0)

        EXODUS_LIB.ex_put_truth_table(
            self.fileId, obj_type, num_objs, num_vars, truth_tab)
        return True

    # --------------------------------------------------------------------

    def __ex_get_coord(self):
        self.coordsX = (ctypes.c_double * self.numNodes.value)()
        self.coordsY = (ctypes.c_double * self.numNodes.value)()
        self.coordsZ = (ctypes.c_double * self.numNodes.value)()
        EXODUS_LIB.ex_get_coord(
            self.fileId,
            ctypes.byref(self.coordsX),
            ctypes.byref(self.coordsY),
            ctypes.byref(self.coordsZ))

    # --------------------------------------------------------------------

    def __ex_put_coord(self, xCoords, yCoords, zCoords):
        self.coordsX = (ctypes.c_double * self.numNodes.value)()
        self.coordsY = (ctypes.c_double * self.numNodes.value)()
        self.coordsZ = (ctypes.c_double * self.numNodes.value)()
        for i in range(self.numNodes.value):
            self.coordsX[i] = float(xCoords[i])
            self.coordsY[i] = float(yCoords[i])
            self.coordsZ[i] = float(zCoords[i])
        EXODUS_LIB.ex_put_coord(
            self.fileId,
            ctypes.byref(self.coordsX),
            ctypes.byref(self.coordsY),
            ctypes.byref(self.coordsZ))

    # --------------------------------------------------------------------

    def __ex_get_partial_coord(self, startNodeId, numNodes):
        start_node_num = ctypes.c_longlong(startNodeId)
        num_nodes = ctypes.c_longlong(numNodes)
        coordsX = (ctypes.c_double * numNodes)()
        coordsY = (ctypes.c_double * numNodes)()
        coordsZ = (ctypes.c_double * numNodes)()
        EXODUS_LIB.ex_get_partial_coord(
            self.fileId,
            start_node_num,
            num_nodes,
            ctypes.byref(coordsX),
            ctypes.byref(coordsY),
            ctypes.byref(coordsZ))
        return list(coordsX), list(coordsY), list(coordsZ)

    # --------------------------------------------------------------------

    def __ex_get_id_map(self, objType):
        inqType = ex_obj_to_inq(objType)
        obj_type = ctypes.c_int(get_entity_type(objType))
        inq_type = ctypes.c_int(ex_inquiry_map(inqType))
        num_objs = ctypes.c_int(self.__ex_inquire_int(inq_type))
        numObjs = num_objs.value
        if EXODUS_LIB.ex_int64_status(self.fileId) &amp; EX_IDS_INT64_API:
            id_map = (ctypes.c_longlong * numObjs)()
        else:
            id_map = (ctypes.c_int * numObjs)()
        EXODUS_LIB.ex_get_id_map(self.fileId, obj_type, ctypes.byref(id_map))
        idMap = []
        for i in range(numObjs):
            idMap.append(id_map[i])
        if self.use_numpy:
            idMap = self.np.array(idMap)
        return idMap

    # --------------------------------------------------------------------

    def __ex_get_block_id_map(self, obj_type, id):
        obj_type = ctypes.c_int(get_entity_type(obj_type))
        entity_id = ctypes.c_longlong(id)
        _, numObjs,_,_ = self.__ex_get_block(&#39;EX_ELEM_BLOCK&#39;, id)
        if EXODUS_LIB.ex_int64_status(self.fileId) &amp; EX_IDS_INT64_API:
            id_map = (ctypes.c_longlong * numObjs.value)()
        else:
            id_map = (ctypes.c_int * numObjs.value)()
        EXODUS_LIB.ex_get_block_id_map(self.fileId, obj_type, entity_id, id_map)
        if self.use_numpy:
            id_map = ctype_to_numpy(self, id_map)
        return id_map

    # --------------------------------------------------------------------

    def __ex_put_id_map(self, objType, idMap):
        inqType = ex_obj_to_inq(objType)
        obj_type = ctypes.c_int(get_entity_type(objType))
        inq_type = ctypes.c_int(ex_inquiry_map(inqType))
        num_objs = ctypes.c_int(self.__ex_inquire_int(inq_type))
        numObjs = num_objs.value
        assert numObjs == len(idMap)
        if EXODUS_LIB.ex_int64_status(self.fileId) &amp; EX_IDS_INT64_API:
            id_map = (ctypes.c_longlong * numObjs)()
            for i in range(numObjs):
                id_map[i] = ctypes.c_longlong(idMap[i])
        else:
            id_map = (ctypes.c_int * numObjs)()
            for i in range(numObjs):
                id_map[i] = ctypes.c_int(idMap[i])
        EXODUS_LIB.ex_put_id_map(self.fileId, obj_type, ctypes.byref(id_map))
        return True

    # --------------------------------------------------------------------

    def __ex_get_elem_num_map(self):
        if EXODUS_LIB.ex_int64_status(self.fileId) &amp; EX_MAPS_INT64_API:
            elemNumMap = (ctypes.c_longlong * self.numElem.value)()
        else:
            elemNumMap = (ctypes.c_int * self.numElem.value)()
        EXODUS_LIB.ex_get_elem_num_map(self.fileId, ctypes.byref(elemNumMap))
        return elemNumMap

    # --------------------------------------------------------------------

    def __ex_get_node_num_map(self):
        if EXODUS_LIB.ex_int64_status(self.fileId) &amp; EX_MAPS_INT64_API:
            nodeNumMap = (ctypes.c_longlong * self.numNodes.value)()
        else:
            nodeNumMap = (ctypes.c_int * self.numNodes.value)()
        EXODUS_LIB.ex_get_node_num_map(self.fileId, ctypes.byref(nodeNumMap))
        return nodeNumMap

    # --------------------------------------------------------------------

    def __ex_get_elem_order_map(self):
        if EXODUS_LIB.ex_int64_status(self.fileId) &amp; EX_MAPS_INT64_API:
            elemOrderMap = (ctypes.c_longlong * self.numElem.value)()
        else:
            elemOrderMap = (ctypes.c_int * self.numElem.value)()
        EXODUS_LIB.ex_get_map(self.fileId, ctypes.byref(elemOrderMap))
        return elemOrderMap

    # --------------------------------------------------------------------

    def __ex_get_block(self, object_type, object_id):
        obj_type = ctypes.c_int(get_entity_type(object_type))
        block_id = ctypes.c_longlong(object_id)
        blk_type = ctypes.create_string_buffer(MAX_STR_LENGTH + 1)
        if EXODUS_LIB.ex_int64_status(self.fileId) &amp; EX_BULK_INT64_API:
            num_elem_this_blk = ctypes.c_longlong(0)
            num_nodes_per_elem = ctypes.c_longlong(0)
            num_edges_per_elem = ctypes.c_longlong(0)
            num_faces_per_elem = ctypes.c_longlong(0)
            num_attr = ctypes.c_longlong(0)
        else:
            num_elem_this_blk = ctypes.c_int(0)
            num_nodes_per_elem = ctypes.c_int(0)
            num_edges_per_elem = ctypes.c_int(0)
            num_faces_per_elem = ctypes.c_int(0)
            num_attr = ctypes.c_int(0)
        EXODUS_LIB.ex_get_block(
            self.fileId,
            obj_type,
            block_id,
            blk_type,
            ctypes.byref(num_elem_this_blk),
            ctypes.byref(num_nodes_per_elem),
            ctypes.byref(num_edges_per_elem),
            ctypes.byref(num_faces_per_elem),
            ctypes.byref(num_attr))
        return blk_type, num_elem_this_blk, num_nodes_per_elem, num_attr

    # --------------------------------------------------------------------

    def __ex_put_block(
            self,
            object_type,
            object_id,
            eType,
            numElems,
            numNodesPerElem,
            numAttrsPerElem):
        obj_type = ctypes.c_int(get_entity_type(object_type))
        block_id = ctypes.c_longlong(object_id)
        if type(eType) == str:
            eType = eType.encode(&#39;ascii&#39;)
        elem_type = ctypes.create_string_buffer(eType.upper(), MAX_NAME_LENGTH + 1)
        num_elem_this_blk = ctypes.c_longlong(numElems)
        num_nodes_per_elem = ctypes.c_longlong(numNodesPerElem)
        num_edges_per_elem = ctypes.c_longlong(0)
        num_faces_per_elem = ctypes.c_longlong(0)
        num_attr = ctypes.c_longlong(numAttrsPerElem)
        EXODUS_LIB.ex_put_block(self.fileId, obj_type, block_id, elem_type,
                                num_elem_this_blk, num_nodes_per_elem,
                                num_edges_per_elem, num_faces_per_elem, num_attr)

    # --------------------------------------------------------------------

    def __ex_get_elem_conn(self, object_id):
        (_elem_type, num_elem_this_blk, num_nodes_per_elem,
         _num_attr) = self.__ex_get_block(&#39;EX_ELEM_BLOCK&#39;, object_id)
        elem_block_id = ctypes.c_longlong(object_id)
        if EXODUS_LIB.ex_int64_status(self.fileId) &amp; EX_BULK_INT64_API:
            elem_block_connectivity = (
                ctypes.c_longlong * (num_elem_this_blk.value * num_nodes_per_elem.value))()
        else:
            elem_block_connectivity = (
                ctypes.c_int * (num_elem_this_blk.value * num_nodes_per_elem.value))()
        EXODUS_LIB.ex_get_elem_conn(
            self.fileId,
            elem_block_id,
            ctypes.byref(elem_block_connectivity))
        return elem_block_connectivity, num_elem_this_blk, num_nodes_per_elem

    # --------------------------------------------------------------------

    def __ex_put_elem_conn(self, object_id, connectivity):
        (_elem_type, num_elem_this_blk, num_nodes_per_elem,
         _num_attr) = self.__ex_get_block(&#39;EX_ELEM_BLOCK&#39;, object_id)
        elem_block_id = ctypes.c_longlong(object_id)
        if EXODUS_LIB.ex_int64_status(self.fileId) &amp; EX_BULK_INT64_API:
            elem_block_connectivity = (
                ctypes.c_longlong * (num_elem_this_blk.value * num_nodes_per_elem.value))()
            for i in range(num_elem_this_blk.value * num_nodes_per_elem.value):
                elem_block_connectivity[i] = ctypes.c_longlong(connectivity[i])
        else:
            elem_block_connectivity = (
                ctypes.c_int * (num_elem_this_blk.value * num_nodes_per_elem.value))()
            for i in range(num_elem_this_blk.value * num_nodes_per_elem.value):
                elem_block_connectivity[i] = ctypes.c_int(connectivity[i])
        EXODUS_LIB.ex_put_elem_conn(
            self.fileId,
            elem_block_id,
            elem_block_connectivity)

    # --------------------------------------------------------------------

    def __ex_put_one_attr(self, objType, elemBlkID, attrIndx, Attr):
        elem_blk_id = ctypes.c_longlong(elemBlkID)
        obj_type = ctypes.c_int(objType)
        attr_index = ctypes.c_longlong(attrIndx)
        attrib = (ctypes.c_double * len(Attr))()
        for i, attr in enumerate(Attr):
            attrib[i] = float(attr)
        EXODUS_LIB.ex_put_one_attr(
            self.fileId,
            obj_type,
            elem_blk_id,
            attr_index,
            attrib)

    # --------------------------------------------------------------------

    def __ex_get_one_attr(self, objType, elemBlkID, attrIndx):
        elem_blk_id = ctypes.c_longlong(elemBlkID)
        obj_type = ctypes.c_int(objType)
        attr_index = ctypes.c_longlong(attrIndx)
        inqType = ex_inquiry_map(ex_obj_to_inq(objType))
        num_objs = ctypes.c_int(self.__ex_inquire_int(inqType)).value
        attrib = (ctypes.c_double * num_objs)()
        EXODUS_LIB.ex_get_one_attr(
            self.fileId,
            obj_type,
            elem_blk_id,
            attr_index,
            ctypes.byref(attrib))
        return attrib

    # --------------------------------------------------------------------

    def __ex_put_elem_attr(self, elemBlkID, Attr):
        elem_blk_id = ctypes.c_longlong(elemBlkID)
        attrib = (ctypes.c_double * len(Attr))()
        for i, attr in enumerate(Attr):
            attrib[i] = ctypes.c_double(attr)
        EXODUS_LIB.ex_put_attr(
            self.fileId,
            ctypes.c_int(get_entity_type(&#39;EX_ELEM_BLOCK&#39;)),
            elem_blk_id,
            attrib)

    # --------------------------------------------------------------------

    def __ex_get_elem_attr(self, elemBlkID):
        elem_blk_id = ctypes.c_longlong(elemBlkID)
        numAttrThisBlk = self.num_attr(elemBlkID)
        numElemsThisBlk = self.num_elems_in_blk(elemBlkID)
        totalAttr = numAttrThisBlk * numElemsThisBlk
        attrib = (ctypes.c_double * totalAttr)()
        EXODUS_LIB.ex_get_attr(
            self.fileId,
            ctypes.c_int(get_entity_type(&#39;EX_ELEM_BLOCK&#39;)),
            elem_blk_id,
            ctypes.byref(attrib))
        return attrib

    # --------------------------------------------------------------------

    def __ex_get_variable_param(self, varType):
        var_type = ctypes.c_int(get_entity_type(varType))
        num_vars = ctypes.c_int()
        EXODUS_LIB.ex_get_variable_param(
            self.fileId, var_type, ctypes.byref(num_vars))
        return num_vars

    # --------------------------------------------------------------------

    def __ex_get_variable_names(self, varType):
        num_vars = self.__ex_get_variable_param(varType)
        var_name_ptrs = (
            ctypes.POINTER(ctypes.c_char * (MAX_NAME_LENGTH + 1)) * num_vars.value)()

        for i in range(num_vars.value):
            var_name_ptrs[i] = ctypes.pointer(
                ctypes.create_string_buffer(
                    MAX_NAME_LENGTH + 1))

        var_type = ctypes.c_int(get_entity_type(varType))
        EXODUS_LIB.ex_get_variable_names(
            self.fileId,
            var_type,
            num_vars,
            ctypes.byref(var_name_ptrs))
        var_names = []
        for vnp in var_name_ptrs:
            var_names.append(vnp.contents.value.decode(&#39;utf8&#39;))
        return var_names

    # --------------------------------------------------------------------

    def __ex_get_var(self, timeStep, varType, varId, blkId, numValues):
        step = ctypes.c_int(timeStep)
        var_type = ctypes.c_int(get_entity_type(varType))
        var_id = ctypes.c_int(varId)
        block_id = ctypes.c_longlong(blkId)
        num_values = ctypes.c_longlong(numValues)
        var_vals = (ctypes.c_double * num_values.value)()
        EXODUS_LIB.ex_get_var(
            self.fileId,
            step,
            var_type,
            var_id,
            block_id,
            num_values,
            var_vals)
        return var_vals

    # --------------------------------------------------------------------

    def __ex_get_partial_var(self, timeStep, varType, varId, blkId, startIndex, numValues):
        step = ctypes.c_int(timeStep)
        var_type = ctypes.c_int(get_entity_type(varType))
        var_id = ctypes.c_int(varId)
        block_id = ctypes.c_longlong(blkId)
        start_index = ctypes.c_longlong(startIndex)
        num_values = ctypes.c_longlong(numValues)
        var_vals = (ctypes.c_double * num_values.value)()
        EXODUS_LIB.ex_get_var(
            self.fileId,
            step,
            var_type,
            var_id,
            block_id,
            start_index,
            num_values,
            var_vals)
        return var_vals

    # --------------------------------------------------------------------

    def __ex_put_var(self, timeStep, varType, varId, blkId, numValues, values):
        step = ctypes.c_int(timeStep)
        var_type = ctypes.c_int(get_entity_type(varType))
        var_id = ctypes.c_int(varId)
        block_id = ctypes.c_longlong(blkId)
        num_values = ctypes.c_longlong(numValues)
        var_vals = (ctypes.c_double * num_values.value)()
        for i in range(num_values.value):
            var_vals[i] = float(values[i])
        EXODUS_LIB.ex_put_var(
            self.fileId,
            step,
            var_type,
            var_id,
            block_id,
            num_values,
            var_vals)
        return True

    # --------------------------------------------------------------------

    def __ex_put_reduction_variable_param(self, varType, numVars):
        num_vars = ctypes.c_int(numVars)
        current_num = self.__ex_get_reduction_variable_param(varType)
        if current_num.value == num_vars.value:
            # print &#34;value already set&#34;
            return True

        var_type = ctypes.c_int(get_entity_type(varType))
        errorInt = EXODUS_LIB.ex_put_reduction_variable_param(
            self.fileId, var_type, num_vars)
        if errorInt != 0:
            print((&#34;ERROR code =&#34;, errorInt))
            raise Exception(
                &#34;ERROR: ex_put_reduction_variable_param had problems.&#34;
                &#34; This can only be called once per varType.&#34;)
        return True

    # --------------------------------------------------------------------

    def __ex_get_reduction_variable_param(self, varType):
        var_type = ctypes.c_int(get_entity_type(varType))
        num_vars = ctypes.c_int()
        EXODUS_LIB.ex_get_reduction_variable_param(
            self.fileId, var_type, ctypes.byref(num_vars))
        return num_vars

    # --------------------------------------------------------------------

    def __ex_get_reduction_variable_name(self, varType, varId):
        var_type = ctypes.c_int(get_entity_type(varType))
        var_id = ctypes.c_int(varId)
        name = ctypes.create_string_buffer(MAX_NAME_LENGTH + 1)
        EXODUS_LIB.ex_get_reduction_variable_name(self.fileId, var_type, var_id, name)
        return name.value.decode(&#34;utf8&#34;)

    # --------------------------------------------------------------------

    def __ex_put_reduction_variable_name(self, varType, varId, varName):
        var_type = ctypes.c_int(get_entity_type(varType))
        var_id = ctypes.c_int(varId)
        name = ctypes.create_string_buffer(varName.encode(&#39;ascii&#39;), MAX_NAME_LENGTH + 1)
        EXODUS_LIB.ex_put_reduction_variable_name(self.fileId, var_type, var_id, name)
        return True

    # --------------------------------------------------------------------

    def __ex_get_reduction_variable_names(self, varType):
        num_vars = self.__ex_get_reduction_variable_param(varType)
        var_name_ptrs = (
            ctypes.POINTER(ctypes.c_char * (MAX_NAME_LENGTH + 1)) * num_vars.value)()

        for i in range(num_vars.value):
            var_name_ptrs[i] = ctypes.pointer(
                ctypes.create_string_buffer(
                    MAX_NAME_LENGTH + 1))

        var_type = ctypes.c_int(get_entity_type(varType))
        EXODUS_LIB.ex_get_reduction_variable_names(
            self.fileId,
            var_type,
            num_vars,
            ctypes.byref(var_name_ptrs))
        var_names = []
        for vnp in var_name_ptrs:
            var_names.append(vnp.contents.value.decode(&#39;utf8&#39;))
        return var_names

    # --------------------------------------------------------------------

    def __ex_get_reduction_vars(self, timeStep, varType, blkId, numValues):
        step = ctypes.c_int(timeStep)
        var_type = ctypes.c_int(get_entity_type(varType))
        block_id = ctypes.c_longlong(blkId)
        num_values = ctypes.c_longlong(numValues)
        var_vals = (ctypes.c_double * num_values.value)()
        EXODUS_LIB.ex_get_reduction_vars(
            self.fileId,
            step,
            var_type,
            block_id,
            num_values,
            var_vals)
        return var_vals

    # --------------------------------------------------------------------

    def __ex_put_reduction_vars(self, timeStep, varType, blkId, numValues, values):
        step = ctypes.c_int(timeStep)
        var_type = ctypes.c_int(get_entity_type(varType))
        block_id = ctypes.c_longlong(blkId)
        num_values = ctypes.c_longlong(numValues)
        var_vals = (ctypes.c_double * num_values.value)()
        for i in range(num_values.value):
            var_vals[i] = float(values[i])
        EXODUS_LIB.ex_put_reduction_vars(
            self.fileId,
            step,
            var_type,
            block_id,
            num_values,
            var_vals)
        return True

    # --------------------------------------------------------------------

    def __ex_get_side_set_node_list_len(self, object_id):
        side_set_id = ctypes.c_longlong(object_id)
        if EXODUS_LIB.ex_int64_status(self.fileId) &amp; EX_BULK_INT64_API:
            side_set_node_list_len = ctypes.c_longlong(0)
        else:
            side_set_node_list_len = ctypes.c_int(0)
        EXODUS_LIB.ex_get_side_set_node_list_len(
            self.fileId, side_set_id, ctypes.byref(side_set_node_list_len))
        return side_set_node_list_len

    # --------------------------------------------------------------------

    def __ex_get_set_param(self, objType, object_id):
        object_type = ctypes.c_int(get_entity_type(objType))
        side_set_id = ctypes.c_longlong(object_id)
        if EXODUS_LIB.ex_int64_status(self.fileId) &amp; EX_BULK_INT64_API:
            num_side_in_set = ctypes.c_longlong(0)
            num_dist_fact_in_set = ctypes.c_longlong(0)
        else:
            num_side_in_set = ctypes.c_int(0)
            num_dist_fact_in_set = ctypes.c_int(0)
        EXODUS_LIB.ex_get_set_param(
            self.fileId,
            object_type,
            side_set_id,
            ctypes.byref(num_side_in_set),
            ctypes.byref(num_dist_fact_in_set))
        return int(num_side_in_set.value), int(num_dist_fact_in_set.value)

    # --------------------------------------------------------------------

    def __ex_put_set_param(self, objType, object_id, numSides, numDistFacts):
        object_type = ctypes.c_int(get_entity_type(objType))
        side_set_id = ctypes.c_longlong(object_id)
        num_side_in_set = ctypes.c_longlong(numSides)
        num_dist_fact_in_set = ctypes.c_longlong(numDistFacts)
        EXODUS_LIB.ex_put_set_param(
            self.fileId,
            object_type,
            side_set_id,
            num_side_in_set,
            num_dist_fact_in_set)
        return True

    # --------------------------------------------------------------------

    def __ex_get_side_set(self, sideSetId):
        side_set_id = ctypes.c_longlong(sideSetId)
        (num_side_in_set, _num_dist_fact_in_set) = self.__ex_get_set_param(&#39;EX_SIDE_SET&#39;, sideSetId)
        if num_side_in_set == 0:
            return [], []
        if EXODUS_LIB.ex_int64_status(self.fileId) &amp; EX_BULK_INT64_API:
            side_set_elem_list = (ctypes.c_longlong * num_side_in_set)()
            side_set_side_list = (ctypes.c_longlong * num_side_in_set)()
        else:
            side_set_elem_list = (ctypes.c_int * num_side_in_set)()
            side_set_side_list = (ctypes.c_int * num_side_in_set)()
        EXODUS_LIB.ex_get_side_set(self.fileId, side_set_id,
                                   ctypes.byref(side_set_elem_list),
                                   ctypes.byref(side_set_side_list))
        return side_set_elem_list, side_set_side_list

    # --------------------------------------------------------------------

    def __ex_put_side_set(self, object_id, sideSetElements, sideSetSides):
        side_set_id = ctypes.c_longlong(object_id)
        if EXODUS_LIB.ex_int64_status(self.fileId) &amp; EX_BULK_INT64_API:
            side_set_elem_list = (ctypes.c_longlong * len(sideSetElements))()
            side_set_side_list = (ctypes.c_longlong * len(sideSetSides))()
            for i, sse in enumerate(sideSetElements):
                side_set_elem_list[i] = ctypes.c_longlong(sse)
                side_set_side_list[i] = ctypes.c_longlong(sideSetSides[i])
        else:
            side_set_elem_list = (ctypes.c_int * len(sideSetElements))()
            side_set_side_list = (ctypes.c_int * len(sideSetSides))()
            for i, sse in enumerate(sideSetElements):
                side_set_elem_list[i] = ctypes.c_int(sse)
                side_set_side_list[i] = ctypes.c_int(sideSetSides[i])
        EXODUS_LIB.ex_put_side_set(
            self.fileId,
            side_set_id,
            side_set_elem_list,
            side_set_side_list)
        return True

    # --------------------------------------------------------------------

    def __ex_get_side_set_dist_fact(self, sideSetId):
        side_set_id = ctypes.c_longlong(sideSetId)
        side_set_node_list_len = self.__ex_get_side_set_node_list_len(
            sideSetId)
        set_dfs = (ctypes.c_double * side_set_node_list_len.value)()
        EXODUS_LIB.ex_get_side_set_dist_fact(
            self.fileId, side_set_id, ctypes.byref(set_dfs))
        return set_dfs

    # --------------------------------------------------------------------

    def __ex_put_side_set_dist_fact(self, sideSetId, sideSetDistFact):
        side_set_id = ctypes.c_longlong(sideSetId)
        side_set_dist_fact = (ctypes.c_double * len(sideSetDistFact))()
        for i, df in enumerate(sideSetDistFact):
            side_set_dist_fact[i] = ctypes.c_double(df)
        EXODUS_LIB.ex_put_side_set_dist_fact(
            self.fileId, side_set_id, side_set_dist_fact)

    # --------------------------------------------------------------------

    def __ex_get_side_set_node_list(self, object_id):
        side_set_id = ctypes.c_longlong(object_id)
        side_set_node_list_len = self.__ex_get_side_set_node_list_len(object_id)
        (num_side_in_set, _num_dist_fact_in_set) = self.__ex_get_set_param(&#39;EX_SIDE_SET&#39;, object_id)
        if EXODUS_LIB.ex_int64_status(self.fileId) &amp; EX_BULK_INT64_API:
            side_set_node_cnt_list = (ctypes.c_longlong * num_side_in_set)()
            side_set_node_list = (ctypes.c_longlong * side_set_node_list_len.value)()
        else:
            side_set_node_cnt_list = (ctypes.c_int * num_side_in_set)()
            side_set_node_list = (ctypes.c_int * side_set_node_list_len.value)()
        EXODUS_LIB.ex_get_side_set_node_list(self.fileId, side_set_id,
                                             ctypes.byref(side_set_node_cnt_list),
                                             ctypes.byref(side_set_node_list))
        return side_set_node_cnt_list, side_set_node_list

    # --------------------------------------------------------------------

    def __ex_put_variable_param(self, varType, numVars):
        num_vars = ctypes.c_int(numVars)
        current_num = self.__ex_get_variable_param(varType)
        if current_num.value == num_vars.value:
            # print &#34;value already set&#34;
            return True

        var_type = ctypes.c_int(get_entity_type(varType))
        errorInt = EXODUS_LIB.ex_put_variable_param(
            self.fileId, var_type, num_vars)
        if errorInt != 0:
            print((&#34;ERROR code =&#34;, errorInt))
            raise Exception(
                &#34;ERROR: ex_put_variable_param had problems.&#34;
                &#34; This can only be called once per varType.&#34;)
        return True

    # --------------------------------------------------------------------

    def __ex_get_variable_name(self, varType, varId):
        var_type = ctypes.c_int(varType)
        var_id = ctypes.c_int(varId)
        name = ctypes.create_string_buffer(MAX_NAME_LENGTH + 1)
        EXODUS_LIB.ex_get_variable_name(self.fileId, var_type, var_id, name)
        return name.decode(&#39;utf8&#39;)

    # --------------------------------------------------------------------

    def __ex_put_variable_name(self, varType, varId, varName):
        var_type = ctypes.c_int(get_entity_type(varType))
        var_id = ctypes.c_int(varId)
        name = ctypes.create_string_buffer(varName.encode(&#39;ascii&#39;), MAX_NAME_LENGTH + 1)
        EXODUS_LIB.ex_put_variable_name(self.fileId, var_type, var_id, name)
        return True

    # --------------------------------------------------------------------

    def __ex_get_elem_attr_names(self, blkId):
        object_id = ctypes.c_longlong(blkId)
        num_attr = ctypes.c_int(self.num_attr(blkId))
        len_name = self.__ex_inquire_int(ex_inquiry_map(&#39;EX_INQ_MAX_READ_NAME_LENGTH&#39;))
        attr_name_ptrs = (ctypes.POINTER(ctypes.c_char * (len_name + 1)) * num_attr.value)()
        for i in range(num_attr.value):
            attr_name_ptrs[i] = ctypes.pointer(ctypes.create_string_buffer(len_name + 1))
        EXODUS_LIB.ex_get_elem_attr_names(
            self.fileId, object_id, ctypes.byref(attr_name_ptrs))
        attr_names = []
        for cnp in attr_name_ptrs:
            attr_names.append(cnp.contents.value.decode(&#39;utf8&#39;))
        return attr_names

    # --------------------------------------------------------------------

    def __ex_put_elem_attr_names(self, blkId, varNames):
        object_id = ctypes.c_int(blkId)
        num_attr = ctypes.c_int(self.num_attr(blkId))
        len_name = self.__ex_inquire_int(ex_inquiry_map(&#39;EX_INQ_MAX_READ_NAME_LENGTH&#39;))
        attr_name_ptrs = (ctypes.POINTER(ctypes.c_char * (len_name + 1)) * num_attr.value)()
        assert len(varNames) == num_attr.value
        for i in range(num_attr.value):
            attr_name_ptrs[i] = ctypes.pointer(
                ctypes.create_string_buffer(
                    varNames[i].encode(&#39;ascii&#39;), len_name + 1))
        EXODUS_LIB.ex_put_elem_attr_names(
            self.fileId, object_id, ctypes.byref(attr_name_ptrs))
        return True

    # --------------------------------------------------------------------

    def __ex_get_prop_names(self, varType, inqType):
        var_type = ctypes.c_int(get_entity_type(varType))
        num_props = ctypes.c_int(self.__ex_inquire_int(ex_inquiry_map(inqType)))
        prop_name_ptrs = (
            ctypes.POINTER(ctypes.c_char * (MAX_STR_LENGTH + 1)) * num_props.value)()
        for i in range(num_props.value):
            prop_name_ptrs[i] = ctypes.pointer(
                ctypes.create_string_buffer(
                    MAX_STR_LENGTH + 1))
        EXODUS_LIB.ex_get_prop_names(
            self.fileId, var_type, ctypes.byref(prop_name_ptrs))
        prop_names = []
        for cnp in prop_name_ptrs:
            prop_names.append(cnp.contents.value.decode(&#39;utf8&#39;))
        return prop_names

    # --------------------------------------------------------------------

    def __ex_get_prop(self, objType, objId, propName):
        obj_type = ctypes.c_int(get_entity_type(objType))
        obj_id = ctypes.c_longlong(objId)
        prop_name = ctypes.create_string_buffer(propName.encode(&#39;ascii&#39;), MAX_STR_LENGTH + 1)
        if EXODUS_LIB.ex_int64_status(self.fileId) &amp; EX_IDS_INT64_API:
            prop_val = ctypes.c_longlong(0)
        else:
            prop_val = ctypes.c_int(0)
        EXODUS_LIB.ex_get_prop(
            self.fileId,
            obj_type,
            obj_id,
            ctypes.byref(prop_name),
            ctypes.byref(prop_val))
        return prop_val.value

    # --------------------------------------------------------------------

    def __ex_put_prop(self, objType, objId, propName, propVal):
        obj_type = ctypes.c_int(get_entity_type(objType))
        obj_id = ctypes.c_longlong(objId)
        prop_name = ctypes.create_string_buffer(propName.encode(&#39;ascii&#39;), MAX_STR_LENGTH + 1)
        prop_val = ctypes.c_longlong(propVal)
        EXODUS_LIB.ex_put_prop(
            self.fileId,
            obj_type,
            obj_id,
            ctypes.byref(prop_name),
            prop_val)
        return True

    # --------------------------------------------------------------------

    def __ex_update(self):
        EXODUS_LIB.ex_update(self.fileId)
        return True

# --------------------------------------------------------------------
# Utility Functions
# --------------------------------------------------------------------


def collectElemConnectivity(exodusHandle, connectivity):
    &#34;&#34;&#34;
      This function generates a list of lists that represent the element connectivity.

    Usage:
    ------
    &gt;&gt;&gt; with exodus(&#34;file.g&#34;, &#34;r&#34;) as exodusHandle:
    &gt;&gt;&gt;     connectivity = []
    &gt;&gt;&gt;     collectElemConnectivity(exodusHandle, connectivity)
    &#34;&#34;&#34;

    if not isinstance(connectivity, list):
        raise Exception(
            &#34;ERROR: connectivity is not a list in call to collectElemConnectivity().&#34;)
    if connectivity:
        raise Exception(
            &#34;ERROR: connectivity is not empty in call to collectElemConnectivity().&#34;)

    blockIds = exodusHandle.get_ids(&#39;EX_ELEM_BLOCK&#39;)
    for blId in blockIds:
        (elem_block_conn, num_elem, num_nodes) = exodusHandle.get_elem_connectivity(blId)
        for k in range(num_elem):
            i = k * num_nodes
            j = i + num_nodes
            local_elem_conn = elem_block_conn[i:j]
            connectivity.append(local_elem_conn)

# --------------------------------------------------------------------


def collectLocalNodeToLocalElems(
        exodusHandle,
        connectivity,
        localNodeToLocalElems):
    &#34;&#34;&#34;
      This function generates a list of lists to go from local node id
      to local elem id.

    Usage:
    ------
    &gt;&gt;&gt; connectivity = [] ## If this is not empty it will assume it is already filled.
    &gt;&gt;&gt; localNodeToLocalElems = []
    &gt;&gt;&gt; with exodus(&#34;file.g&#34;, &#34;r&#34;) as exodusHandle:
    &gt;&gt;&gt;     collectLocalNodeToLocalElems(exodusHandle, connectivity, localNodeToLocalElems)
    &#34;&#34;&#34;

    if not isinstance(connectivity, list):
        raise Exception(
            &#34;ERROR: connectivity is not a list in call to collectLocalNodeToLocalElems().&#34;)
    if not isinstance(localNodeToLocalElems, list):
        raise Exception(
            &#34;ERROR: localNodeToLocalElems is not a list in call to collectLocalNodeToLocalElems().&#34;)
    if localNodeToLocalElems:
        raise Exception(
            &#34;ERROR: localNodeToLocalElems is not empty in call to collectLocalNodeToLocalElems().&#34;)

    if not connectivity:
        collectElemConnectivity(exodusHandle, connectivity)

    numNodes = exodusHandle.num_nodes()
    for _i in range(numNodes + 1):
        localNodeToLocalElems.append([])

    localElemId = 0
    for local_elem_conn in connectivity:
        for n in local_elem_conn:
            localNodeToLocalElems[n].append(localElemId)
        localElemId = localElemId + 1

# --------------------------------------------------------------------


def collectLocalElemToLocalElems(
        exodusHandle,
        connectivity,
        localNodeToLocalElems,
        localElemToLocalElems):
    &#34;&#34;&#34;
      This function generates a list of lists to go from local elem id
      to connected local elem ids.

    Usage:
    ------
    &gt;&gt;&gt; connectivity = [] ## If this is not empty it will assume it is already filled.
    &gt;&gt;&gt; localNodeToLocalElems = [] ## If this is not empty it will assume it is already filled.
    &gt;&gt;&gt; localElemToLocalElems = []
    &gt;&gt;&gt; with exodus(&#34;file.g&#34;, &#34;r&#34;) as exodusHandle:
    &gt;&gt;&gt;     collectLocalElemToLocalElems(exodusHandle, connectivity, localNodeToLocalElems,
    ...                              localElemToLocalElems)
    &#34;&#34;&#34;

    if not isinstance(connectivity, list):
        raise Exception(
            &#34;ERROR: connectivity is not a list in call to collectLocalElemToLocalElems().&#34;)
    if not isinstance(localNodeToLocalElems, list):
        raise Exception(
            &#34;ERROR: localNodeToLocalElems is not a list in call to collectLocalElemToLocalElems().&#34;)
    if not isinstance(localElemToLocalElems, list):
        raise Exception(
            &#34;ERROR: localElemToLocalElems is not a list in call to collectLocalElemToLocalElems().&#34;)
    if localElemToLocalElems:
        raise Exception(
            &#34;ERROR: localElemToLocalElems is not empty in call to collectLocalElemToLocalElems().&#34;)

    if not connectivity:
        collectElemConnectivity(exodusHandle, connectivity)
    if not localNodeToLocalElems:
        collectLocalNodeToLocalElems(
            exodusHandle, connectivity, localNodeToLocalElems)

    numElems = exodusHandle.num_elems()
    for _i in range(numElems):
        localElemToLocalElems.append([])
    for localElemId in range(numElems):
        nodeList = list(connectivity[localElemId])
        newConnectedElems = []
        for n in nodeList:
            for elem in localNodeToLocalElems[n]:
                newConnectedElems.append(elem)
        localElemToLocalElems[localElemId] = list(set(newConnectedElems))

# --------------------------------------------------------------------


def copy_mesh(fromFileName, toFileName, exoFromObj=None,
              additionalElementAttributes=[], array_type=&#39;ctype&#39;):
    &#34;&#34;&#34;
    Copies the mesh data from an existing exodus database to a new exodus
    database.

    Parameters
    ----------
    fromFileName : string
        File name of the exodus mesh to be copied
    toFileName : string
        File name of the new exodus mesh
    exoFromObj : exodus object, optional
        Exodus object to be copied from.  If an exodus object is supplied, the
        fromFileName string will be ignored.
    additionalElementAttributes : list
        list of element attribute names to add to all blocks or tuples
        ( name, blkIds ) where name is the element attribute to add and blkIds is
        a list of blkIds to add it to.
    array_type : &#39;ctype&#39; | &#39;numpy&#39;
        Specifies whether arrays will be imported and copied as ctype or numpy
        arrays.  (This option should make no difference to the user, but it can
        be used by developers to test whether the commands within this function
        handle both array types correctly.)

    Returns
    -------
    exo_to : exodus object
        New exodus mesh

    Note:
    -----
    This function also allows one to add new element attributes during the copy
    process.  The number of element attributes is permanently set when the
    block is created, meaning new element attributes can only be added to an
    existing mesh by copying it to a new mesh.  The values of the element
    attributes are set to their defaults so that the user can populate them
    later.
    &#34;&#34;&#34;
    debugPrint = False

    # If the user did not supply a exodus object to copy from, attempt to read an
    # exodus database with the name &#34;fromFileName&#34;
    if exoFromObj is None:
        exoFrom = exodus(fromFileName, &#34;r&#34;, array_type=array_type)
    else:
        exoFrom = exoFromObj

    if os.path.isfile(toFileName):
        raise Exception(
            &#34;ERROR: &#34;,
            toFileName,
            &#34; file already exists cowardly exiting instead of overwriting in call to copy_mesh().&#34;)

    title = exoFrom.title().encode(&#39;ascii&#39;)
    ex_pars = ex_init_params(num_dim=exoFrom.num_dimensions(),
                             num_nodes=exoFrom.num_nodes(),
                             num_elem=exoFrom.num_elems(),
                             num_elem_blk=exoFrom.num_blks(),
                             num_node_sets=exoFrom.num_node_sets(),
                             num_side_sets=exoFrom.num_side_sets(),
                             num_assembly=exoFrom.num_assembly(),
                             num_blob=exoFrom.num_blob())

    exo_to = exodus(toFileName, mode=&#34;w&#34;, array_type=array_type,
                    title=title, init_params=ex_pars)

    if debugPrint:
        print(&#34;Transfer QA records&#34;)
    qaRecords = exoFrom.get_qa_records()
    exo_to.put_qa_records(qaRecords)

    if debugPrint:
        print(&#34;Transfer Nodal Coordinates and Names&#34;)
    exo_to.put_coord_names(exoFrom.get_coord_names())
    (xCoords, yCoords, zCoords) = exoFrom.get_coords()
    exo_to.put_coords(xCoords, yCoords, zCoords)

    if debugPrint:
        print(&#34;Transfer Node Id Map&#34;)
    nodeIdMap = exoFrom.get_node_id_map()
    exo_to.put_node_id_map(nodeIdMap)

    if debugPrint:
        print(&#34;Construct mapping from block ID to element attribute data&#34;)
    # The exodus library does not provide a way to add only new element
    # attributes, so we must collect both the new and the old element
    # attributes
    e_attr_names = dict()
    e_attr_vals = dict()
    # Collect the old element attribute names and the number of elements in each
    # block
    blk_ids = exoFrom.get_ids(&#39;EX_ELEM_BLOCK&#39;)
    blk_num_elem = dict()
    for blk_id in blk_ids:
        (elemType, numElem, nodesPerElem, numAttr) = exoFrom.elem_blk_info(blk_id)
        e_attr_names[blk_id] = []
        e_attr_vals[blk_id] = []
        if numAttr &gt; 0:
            e_attr_names[blk_id].extend(
                exoFrom.get_element_attribute_names(blk_id))
            e_attr_vals[blk_id].extend(exoFrom.get_elem_attr(blk_id))
        blk_num_elem[blk_id] = numElem
    # Collect the new element attribute names
    # (The new names are mapped from &#34;attribute name&#34; to &#34;list of block IDs that
    # contain that attribute&#34;.  We need to have them be mapped as &#34;block ID&#34; to
    # &#34;list of attribute names contained in that block&#34;.)
    for item in additionalElementAttributes:
        if isinstance(item, tuple):
            e_attr_name = item[0]
            e_attr_blk_ids = item[1]
        elif isinstance(item, str):
            e_attr_name = item
            e_attr_blk_ids = blk_ids
        else:
            print((
                &#34;Warning additional element attribute item &#34; +
                item +
                &#34; is not right type to add.&#34;))
            print(&#34;should be a string or tuple, skipping&#34;)
        for blk_id in e_attr_blk_ids:
            if blk_id in blk_ids:
                e_attr_names[blk_id].append(e_attr_name)
                # Concatenate all element attribute values into a single big list,
                # because that is format required by exo.put_elem_attr().
                e_attr_vals[blk_id].extend([0.0] * blk_num_elem[blk_id])

    if debugPrint:
        print(&#34;Transfer Element Data&#34;)
    blkIds = exoFrom.get_ids(&#39;EX_ELEM_BLOCK&#39;)
    for blkId in blkIds:
        (elemType, numElem, nodesPerElem, _oldnumAttr) = exoFrom.elem_blk_info(blkId)
        numAttr = len(e_attr_names[blkId])
        exo_to.put_elem_blk_info(blkId, elemType, numElem, nodesPerElem, numAttr)
        (connectivity, numElem, nodesPerElem) = exoFrom.get_elem_connectivity(blkId)
        exo_to.put_elem_connectivity(blkId, connectivity)
        if numAttr &gt; 0:
            exo_to.put_element_attribute_names(blkId, e_attr_names[blkId])
            exo_to.put_elem_attr(blkId, e_attr_vals[blkId])
        elemProps = exoFrom.get_element_property_names()
        for elemProp in elemProps:
            propVal = exoFrom.get_element_property_value(blkId, elemProp)
            if elemProp == &#34;ID&#34; and propVal == blkId:
                continue
            else:
                exo_to.put_element_property_value(blkId, elemProp, propVal)
        blockName = exoFrom.get_name(&#39;EX_ELEM_BLOCK&#39;, blkId)
        exo_to.put_name(&#39;EX_ELEM_BLOCK&#39;, blkId, blockName)

    if debugPrint:
        print(&#34;Transfer Element Id Map&#34;)
    elemIdMap = exoFrom.get_elem_id_map()
    exo_to.put_elem_id_map(elemIdMap)

    if debugPrint:
        print(&#34;Transfer Node Sets&#34;)
    if exoFrom.num_node_sets() &gt; 0:
        nodeSetProps = exoFrom.get_node_set_property_names()
        nodeSetIds = exoFrom.get_ids(&#39;EX_NODE_SET&#39;)
        for nsId in nodeSetIds:
            (numSetNodes, numSetDistFacts) = exoFrom.get_set_params(&#39;EX_NODE_SET&#39;, nsId)
            exo_to.put_node_set_params(nsId, numSetNodes, numSetDistFacts)
            nsNodes = exoFrom.get_node_set_nodes(nsId)
            exo_to.put_node_set(nsId, nsNodes)
            if numSetDistFacts &gt; 0:
                nsDF = exoFrom.get_node_set_dist_facts(nsId)
                exo_to.put_node_set_dist_fact(nsId, nsDF)
            nodeSetName = exoFrom.get_name(&#39;EX_NODE_SET&#39;, nsId)
            exo_to.put_name(&#39;EX_NODE_SET&#39;, nsId, nodeSetName)
            for nodeSetProp in nodeSetProps:
                propVal = exoFrom.get_node_set_property_value(
                    nsId, nodeSetProp)
                if nodeSetProp == &#34;ID&#34; and propVal == nsId:
                    continue
                else:
                    exo_to.put_node_set_property_value(
                        nsId, nodeSetProp, propVal)

    if debugPrint:
        print(&#34;Transfer Side Sets&#34;)
    if exoFrom.num_side_sets() &gt; 0:
        sideSetProps = exoFrom.get_side_set_property_names()
        sideSetIds = exoFrom.get_ids(&#39;EX_SIDE_SET&#39;)
        for ssId in sideSetIds:
            (numSetSides, numSetDistFacts) = exoFrom.get_set_params(&#39;EX_SIDE_SET&#39;, ssId)
            exo_to.put_side_set_params(ssId, numSetSides, numSetDistFacts)
            (elemList, sideList) = exoFrom.get_side_set(ssId)
            exo_to.put_side_set(ssId, elemList, sideList)
            if numSetDistFacts &gt; 0:
                ssDF = exoFrom.get_side_set_dist_fact(ssId)
                exo_to.put_side_set_dist_fact(ssId, ssDF)
            sideSetName = exoFrom.get_name(&#39;EX_SIDE_SET&#39;, ssId)
            exo_to.put_name(&#39;EX_SIDE_SET&#39;, ssId, sideSetName)
            for sideSetProp in sideSetProps:
                propVal = exoFrom.get_side_set_property_value(
                    ssId, sideSetProp)
                if sideSetProp == &#34;ID&#34; and propVal == ssId:
                    continue
                else:
                    exo_to.put_side_set_property_value(
                        ssId, sideSetProp, propVal)

    # If the user did not supply an exodus object to copy from, then close the
    # database.
    if exoFromObj is None:
        exoFrom.close()

    return exo_to


def transfer_variables(
        exoFrom,
        exo_to,
        array_type=&#39;ctype&#39;,
        additionalGlobalVariables=[],
        additionalNodalVariables=[],
        additionalElementVariables=[],
        additionalNodeSetVariables=[],
        additionalSideSetVariables=[]):
    &#34;&#34;&#34;
    This function transfers variables from `exoFrom` to `exo_to` and allows
    additional variables to be added with `additionalGlobalVariables`,
    `additionalNodalVariables`, and `additionalElementVariables`.  Additional
    variables values are set to their defaults so that the user can populate
    them later.

    Parameters
    ----------
    exoFrom : exodus database object
        exodus object to transfer from

    exo_to : exodus database object
        exodus object to transfer to

    additionalGlobalVariables : list
        list of global variable names to add.

    additionalNodalVariables : list
        list of nodal variable names to add.

    additionalElementVariables : list
        should be a list of element variable names to add to all blocks or
        tuples `(name, blkIds)` where `name` is the element variable to add
        and `blkIds` is a list of block ids to add it to.
    &#34;&#34;&#34;
    # IDEA: It may make sense to make transfer_variables() strictly transfer
    # variables, and use add_variables() to add new variables.  Alternatively,
    # add_variables() could be called within transfer_variables() to add
    # new variables to the exo_to database.  Either way, we should minimize
    # duplicate code if possible.

    debugPrint = False

    if not isinstance(additionalGlobalVariables, list):
        raise Exception(&#34;ERROR: additionalGlobalVariables is not a list.&#34;)
    if not isinstance(additionalNodalVariables, list):
        raise Exception(&#34;ERROR: additionalNodalVariables is not a list.&#34;)
    if not isinstance(additionalElementVariables, list):
        raise Exception(&#34;ERROR: additionalElementVariables is not a list.&#34;)
    if not isinstance(additionalNodeSetVariables, list):
        raise Exception(&#34;ERROR: additionalNodeSetVariables is not a list.&#34;)
    if not isinstance(additionalSideSetVariables, list):
        raise Exception(&#34;ERROR: additionalSideSetVariables is not a list.&#34;)

    if debugPrint:
        print(&#34;Transfer Info records&#34;)
    numInfoRecs = exoFrom.num_info_records()
    if numInfoRecs &gt; 0:
        infoRecs = exoFrom.get_info_records()
        exo_to.put_info_records(infoRecs)
    if debugPrint:
        print(&#34;Transfer time values&#34;)

    nSteps = exoFrom.num_times()
    if nSteps == 0:
        return exo_to

    timeVals = exoFrom.get_times()
    for step in range(nSteps):
        exo_to.put_time(step + 1, timeVals[step])

    if debugPrint:
        print(&#34;Add Global Variables&#34;)
    nNewGlobalVars = len(additionalGlobalVariables)
    nGlobalVars = exoFrom.get_variable_number(&#39;EX_GLOBAL&#39;) + nNewGlobalVars
    defaultNewVarVals = []
    for _i in range(nNewGlobalVars):
        defaultNewVarVals.append(0.0)
    if nGlobalVars &gt; 0:
        exo_to.set_variable_number(&#39;EX_GLOBAL&#39;, nGlobalVars)
        gVarNames = exoFrom.get_variable_names(&#39;EX_GLOBAL&#39;)
        gVarNames.extend(additionalGlobalVariables)
        for nameIndex in range(nGlobalVars):
            globalVarName = gVarNames[nameIndex]
            exo_to.put_variable_name(&#39;EX_GLOBAL&#39;, globalVarName, nameIndex + 1)
        for step in range(nSteps):
            gValues = exoFrom.get_all_global_variable_values(step + 1)
            if array_type == &#39;numpy&#39;:
                gValues = exo_to.np.append(gValues, defaultNewVarVals)
            else:
                gValues.extend(defaultNewVarVals)
            exo_to.put_all_global_variable_values(step + 1, gValues)

    if debugPrint:
        print(&#34;Add Nodal Variables&#34;)
    nNewNodalVars = len(additionalNodalVariables)
    nOrigNodalVars = exoFrom.get_variable_number(&#39;EX_NODAL&#39;)
    nNodalVars = nOrigNodalVars + nNewNodalVars
    if nNodalVars &gt; 0:
        exo_to.set_variable_number(&#39;EX_NODAL&#39;, nNodalVars)
        nVarNames = exoFrom.get_variable_names(&#39;EX_NODAL&#39;)
        nVarNames.extend(additionalNodalVariables)
        for nameIndex in range(nNodalVars):
            nodalVarName = nVarNames[nameIndex]
            exo_to.put_variable_name(&#39;EX_NODAL&#39;, nodalVarName, nameIndex + 1)
            if nameIndex &lt; nOrigNodalVars:
                for step in range(nSteps):
                    nValues = exoFrom.get_node_variable_values(
                        nodalVarName, step + 1)
                    exo_to.put_node_variable_values(
                        nodalVarName, step + 1, nValues)

    internal_transfer_variables(exoFrom, exo_to, &#39;EX_ELEM_BLOCK&#39;, additionalElementVariables, debugPrint)
    internal_transfer_variables(exoFrom, exo_to, &#39;EX_NODE_SET&#39;, additionalNodeSetVariables, debugPrint)
    internal_transfer_variables(exoFrom, exo_to, &#39;EX_SIDE_SET&#39;, additionalSideSetVariables, debugPrint)
    return exo_to


def internal_transfer_variables(exoFrom, exo_to, obj_type, additionalVariables, debugPrint):
    &#34;&#34;&#34; Internal support function for `exodus.transfer_variables` &#34;&#34;&#34;
    if debugPrint:
        print(&#34;Construct Truth Table for additionalVariables&#34;)
    blkIds = exoFrom.get_ids(obj_type)
    numBlks = len(blkIds)
    newVariableNames = []
    newVariableBlocks = []
    for item in additionalVariables:
        if isinstance(item, tuple):
            newVariableNames.append(item[0])
            inBlks = []
            for blkId in item[1]:
                if blkId in blkIds:
                    inBlks.append(blkId)
            newVariableBlocks.append(inBlks)
        elif isinstance(item, str):
            newVariableNames.append(item)
            newVariableBlocks.append(blkIds)
        else:
            print((&#34;Warning additionalVariable item &#34;,
                   item, &#34; is not right type to add.&#34;))
            print(&#34;should be a string or tuple, skipping&#34;)

    nSteps = exoFrom.num_times()
    if debugPrint:
        print(&#34;Add Variables&#34;)
    nNewVars = len(newVariableNames)
    nOrigVars = exoFrom.get_variable_number(obj_type)
    nVars = nOrigVars + nNewVars
    if nVars &gt; 0:
        exo_to.set_variable_number(obj_type, nVars)
        origVarNames = exoFrom.get_variable_names(obj_type)
        origVarNames.extend(newVariableNames)
        truthTable = []
        if nOrigVars &gt; 0:
            truthTable = exoFrom.get_variable_truth_table(obj_type)
        if nNewVars &gt; 0:
            newTruth = []
            for j in range(numBlks):

                for k in range(nOrigVars):
                    index = j * nOrigVars + k
                    newTruth.append(truthTable[index])
                for m in range(nNewVars):
                    if blkIds[j] in newVariableBlocks[m]:
                        newTruth.append(True)
                    else:
                        newTruth.append(False)
            truthTable = newTruth
        exo_to.set_variable_truth_table(obj_type, truthTable)
        for nameIndex in range(nVars):
            varName = origVarNames[nameIndex]
            exo_to.put_variable_name(obj_type, varName, nameIndex + 1)
        truthIndex = 0
        for blkId in blkIds:
            for origVarName in origVarNames:
                if truthTable[truthIndex]:
                    for step in range(nSteps):
                        eValues = exoFrom.get_variable_values(obj_type, blkId,
                                                              origVarName, step + 1)
                        exo_to.put_variable_values(obj_type, blkId,
                                                   origVarName, step + 1, eValues)
                truthIndex = truthIndex + 1
            truthIndex = truthIndex + nNewVars


def add_variables(exo, global_vars=[], nodal_vars=[], element_vars=[], node_set_vars=[], side_set_vars=[]):
    &#34;&#34;&#34;
    This function adds variables to the exodus object.  The values of the
    variables are set to their defaults so that the user can populate them later.

    Parameters
    ----------
    exo : exodus database object
        Exodus database that variables will be added to.
    global_vars : list
        global variable names to add.
    nodal_vars : list
        nodal variable names to add.
    element_vars : list
        list of element variable names to add to all blocks or tuples
        ( name, blkIds ) where name is the element variable to add and blkIds is
        a list of blkIds to add it to.
    node_set_vars : list
        list of node set variable names to add to all sets or tuples
        ( name, setIds ) where name is the node set variable to add and `setIds` is
        a list of `setIds` to add it to.
    side_set_vars : list
        list of side set variable names to add to all sets or tuples
        ( name, setIds ) where name is the side set variable to add and `setIds` is
        a list of `setIds` to add it to.

    Returns
    -------
    exo : exodus database object
        Exodus database with variables added to it.  (The values of the variables
        are set to their defaults so that the user can populate them later.)

    Note
    ----
    This function does not allow one to add element attributes to an exodus
    database.  See `exodus.copy_mesh` function for that capability.
    &#34;&#34;&#34;
    debugPrint = False

    if not isinstance(global_vars, list):
        raise Exception(&#34;ERROR: global_vars is not a list.&#34;)
    if not isinstance(nodal_vars, list):
        raise Exception(&#34;ERROR: nodal_vars is not a list.&#34;)
    if not isinstance(element_vars, list):
        raise Exception(&#34;ERROR: element_vars is not a list.&#34;)
    if not isinstance(node_set_vars, list):
        raise Exception(&#34;ERROR: node_set_vars is not a list.&#34;)
    if not isinstance(side_set_vars, list):
        raise Exception(&#34;ERROR: side_set_vars is not a list.&#34;)

    if exo.modeChar == &#39;r&#39;:
        raise Exception(
            &#34;ERROR: variables cannot be added to an exodus object in read only mode&#34;)

    if debugPrint:
        print(&#34;Add Global Variables&#34;)
    n_new_vars = len(global_vars)
    n_old_vars = exo.get_variable_number(&#39;EX_GLOBAL&#39;)
    n_vars = n_old_vars + n_new_vars
    default_vals = [0.0] * n_new_vars
    if n_new_vars &gt; 0:
        exo.set_variable_number(&#39;EX_GLOBAL&#39;, n_vars)
        for i, var_name in enumerate(global_vars):
            exo.put_variable_name(&#39;EX_GLOBAL&#39;, var_name, n_old_vars + i + 1)
        # One might wish to put all the values for a given global variable in the
        # database at once, but exo.put_global_variable_value() ends up loading
        # all the global variables for a given step and then putting them all back
        # in, so we might as well just use
        # exo.put_all_global_variable_values().
        nSteps = exo.num_times()
        for step in range(nSteps):
            gValues = exo.get_all_global_variable_values(step + 1)
            if exo.use_numpy:
                gValues = exo.np.append(gValues, default_vals)
            else:
                gValues.extend(default_vals)
            exo.put_all_global_variable_values(step + 1, gValues)

    if debugPrint:
        print(&#34;Add Nodal Variables&#34;)
    n_new_vars = len(nodal_vars)
    n_old_vars = exo.get_variable_number(&#39;EX_NODAL&#39;)
    n_vars = n_old_vars + n_new_vars
    if n_new_vars &gt; 0:
        exo.set_variable_number(&#39;EX_NODAL&#39;, n_vars)
        for i, var_name in enumerate(nodal_vars):
            exo.put_variable_name(&#39;EX_NODAL&#39;, var_name, i + n_old_vars + 1)

    internal_add_variables(exo, &#39;EX_ELEM_BLOCK&#39;, element_vars, debugPrint)
    internal_add_variables(exo, &#39;EX_NODE_SET&#39;, node_set_vars, debugPrint)
    internal_add_variables(exo, &#39;EX_SIDE_SET&#39;, side_set_vars, debugPrint)

    return exo

# --------------------------------------------------------------------


def internal_add_variables(exo, obj_type, entvars, debugPrint):
    &#34;&#34;&#34; Internal support function for `exodus.add_variables` &#34;&#34;&#34;

    if len(entvars) == 0:
        return

    if debugPrint:
        print(&#34;Construct Truth Table for additional variables&#34;)

    new_var_names = []
    new_var_blks = []
    blk_ids = exo.get_ids(obj_type)
    for item in entvars:
        if isinstance(item, tuple):
            new_var_names.append(item[0])
            in_blks = []
            for blk_id in item[1]:
                if blk_id in blk_ids:
                    in_blks.append(blk_id)
            new_var_blks.append(in_blks)
        elif isinstance(item, str):
            new_var_names.append(item)
            new_var_blks.append(blk_ids)
        else:
            print((&#34;Warning additional variable item &#34; +
                   item + &#34; is not right type to add.&#34;))
            print(&#34;should be a string or tuple, skipping&#34;)

    if debugPrint:
        print(&#34;Add Variables&#34;)
    n_new_vars = len(new_var_names)
    n_old_vars = exo.get_variable_number(obj_type)
    n_vars = n_old_vars + n_new_vars
    if n_new_vars &gt; 0:
        exo.set_variable_number(obj_type, n_vars)
        old_truth_table = []
        if n_old_vars &gt; 0:
            old_truth_table = exo.get_variable_truth_table(obj_type)
        truth_table = []
        n_blks = len(blk_ids)
        for j in range(n_blks):
            for k in range(n_old_vars):
                ndx = j * n_old_vars + k
                truth_table.append(old_truth_table[ndx])
            for m in range(n_new_vars):
                if blk_ids[j] in new_var_blks[m]:
                    truth_table.append(True)
                else:
                    truth_table.append(False)
        exo.set_variable_truth_table(obj_type, truth_table)
        for i, var_name in enumerate(new_var_names):
            exo.put_variable_name(obj_type, var_name, n_old_vars + i + 1)


def copyTransfer(
        fromFileName,
        toFileName,
        array_type=&#39;ctype&#39;,
        additionalGlobalVariables=[],
        additionalNodalVariables=[],
        additionalElementVariables=[],
        additionalNodeSetVariables=[],
        additionalSideSetVariables=[],
        additionalElementAttributes=[]):
    &#34;&#34;&#34;
    This function creates an exodus file `toFileName` and copies
    everything from exodus file `fromFileName` returning a file handle
    to `toFileName`.

    Additional space is allocated for `additionalGlobalVariables`,
    `additionalNodalVariables` and `additionalElementVariables` if
    specified.

    Parameters
    ----------
    fromFileName : string
        File name of the exodus mesh to be copied
    toFileName : string
        File name of the new exodus mesh
    array_type : &#39;ctype&#39; | &#39;numpy&#39;
        Specifies whether arrays will be imported and copied as ctype or numpy
        arrays.  (This option should make no difference to the user, but it can
        be used by developers to test whether the commands within this function
        handle both array types correctly.)
    additionalGlobalVariables : list
        list of global variable names to add.
    additionalNodalVariables: list
        list of nodal variable names to add.
    additionalElementVariables: list
        should be a list of element variable
        names to add to all blocks or tuples (name, blkIds) where name is
        the element variable to add and blkIds is a list of blkIds to add
        it to.
    additionalElementAttributes: list
        list of element attribute names to
         add to all blocks or tuples ( name, blkIds ) where name is the
         element attribute to add and blkIds is a list of blkIds to add it
         to.

    Usage:
    ------
    &gt;&gt;&gt; fromFileName = &#34;input.e&#34;
    &gt;&gt;&gt; toFileName = &#34;output.e&#34;
    &gt;&gt;&gt; addGlobalVariables = [] ## Do not add any new global variables
    &gt;&gt;&gt; ## Add node_dummy1 and node_dummy2 as new node variables
    &gt;&gt;&gt; addNodeVariables = [&#34;node_dummy1&#34;, &#34;node_dummy2&#34;]
    &gt;&gt;&gt; ## Add elem_dummy1 on blkIds 1, 2, 3 and elem_dummy2 on all blocks
    &gt;&gt;&gt; addElementVariables = [ (&#34;elem_dummy1&#34;, [1, 2, 3]), &#34;elem_dummy2&#34; ]
    &gt;&gt;&gt; ## Add elem_attr_dummy1 on blkIds 1,2,3 and elem_attr_dummy2 on all blocks
    &gt;&gt;&gt; addElementAttributes = [ (&#34;elem_attr_dummy1&#34;,[1,2,3]), &#34;elem_attr_dummy2&#34; ]

    &gt;&gt;&gt; toFileHandle = copyTransfer(fromFileName,toFileName,addGlobalVariables,addNodeVariables,
    ...                             addElementVariables,addElementAttributes)

    &gt;&gt;&gt; ## Fill in new variables

    &gt;&gt;&gt; toFileHandle.close()
    &#34;&#34;&#34;

    exoFrom = exodus(fromFileName, &#34;r&#34;, array_type=array_type)

    exo_to = copy_mesh(fromFileName, toFileName, exoFromObj=exoFrom,
                       additionalElementAttributes=additionalElementAttributes,
                       array_type=array_type)

    exo_to = transfer_variables(
        exoFrom,
        exo_to,
        additionalGlobalVariables=additionalGlobalVariables,
        additionalNodalVariables=additionalNodalVariables,
        additionalElementVariables=additionalElementVariables,
        additionalNodeSetVariables=additionalNodeSetVariables,
        additionalSideSetVariables=additionalSideSetVariables,
        array_type=array_type)

    exoFrom.close()
    return exo_to


def ctype_to_numpy(exo, c_array):
    &#34;&#34;&#34;
    Converts a c-type array into a numpy array

    Parameters
    ----------
    exo : exodus object
        exodus database object initialized with the option `array_type = &#39;numpy&#39;`
    c_array : c-type array
        c-type array to be converted into a numpy array

    Returns
    -------
    np_array : numpy array
        Numpy array converted from c-type array
    &#34;&#34;&#34;
    # ctypes currently produce invalid PEP 3118 type codes, which causes numpy
    # to issue a warning.  This is a bug and can be ignored.
    # http://stackoverflow.com/questions/4964101/pep-3118-warning-when-using-ctypes-array-as-numpy-array
    if not c_array:
        return exo.np.array([])

    with exo.warnings.catch_warnings():
        exo.warnings.simplefilter(&#39;ignore&#39;)
        np_array = exo.np.ctypeslib.as_array(c_array)
    return np_array</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="exodus3.add_variables"><code class="name flex">
<span>def <span class="ident">add_variables</span></span>(<span>exo, global_vars=[], nodal_vars=[], element_vars=[], node_set_vars=[], side_set_vars=[])</span>
</code></dt>
<dd>
<div class="desc"><p>This function adds variables to the exodus object.
The values of the
variables are set to their defaults so that the user can populate them later.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>exo</code></strong> :&ensp;<code><a title="exodus3.exodus" href="#exodus3.exodus">exodus</a> database object</code></dt>
<dd>Exodus database that variables will be added to.</dd>
<dt><strong><code>global_vars</code></strong> :&ensp;<code>list</code></dt>
<dd>global variable names to add.</dd>
<dt><strong><code>nodal_vars</code></strong> :&ensp;<code>list</code></dt>
<dd>nodal variable names to add.</dd>
<dt><strong><code>element_vars</code></strong> :&ensp;<code>list</code></dt>
<dd>list of element variable names to add to all blocks or tuples
( name, blkIds ) where name is the element variable to add and blkIds is
a list of blkIds to add it to.</dd>
<dt><strong><code>node_set_vars</code></strong> :&ensp;<code>list</code></dt>
<dd>list of node set variable names to add to all sets or tuples
( name, setIds ) where name is the node set variable to add and <code>setIds</code> is
a list of <code>setIds</code> to add it to.</dd>
<dt><strong><code>side_set_vars</code></strong> :&ensp;<code>list</code></dt>
<dd>list of side set variable names to add to all sets or tuples
( name, setIds ) where name is the side set variable to add and <code>setIds</code> is
a list of <code>setIds</code> to add it to.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>exo</code></strong> :&ensp;<code><a title="exodus3.exodus" href="#exodus3.exodus">exodus</a> database object</code></dt>
<dd>Exodus database with variables added to it.
(The values of the variables
are set to their defaults so that the user can populate them later.)</dd>
</dl>
<h2 id="note">Note</h2>
<p>This function does not allow one to add element attributes to an exodus
database.
See <code>exodus.copy_mesh</code> function for that capability.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_variables(exo, global_vars=[], nodal_vars=[], element_vars=[], node_set_vars=[], side_set_vars=[]):
    &#34;&#34;&#34;
    This function adds variables to the exodus object.  The values of the
    variables are set to their defaults so that the user can populate them later.

    Parameters
    ----------
    exo : exodus database object
        Exodus database that variables will be added to.
    global_vars : list
        global variable names to add.
    nodal_vars : list
        nodal variable names to add.
    element_vars : list
        list of element variable names to add to all blocks or tuples
        ( name, blkIds ) where name is the element variable to add and blkIds is
        a list of blkIds to add it to.
    node_set_vars : list
        list of node set variable names to add to all sets or tuples
        ( name, setIds ) where name is the node set variable to add and `setIds` is
        a list of `setIds` to add it to.
    side_set_vars : list
        list of side set variable names to add to all sets or tuples
        ( name, setIds ) where name is the side set variable to add and `setIds` is
        a list of `setIds` to add it to.

    Returns
    -------
    exo : exodus database object
        Exodus database with variables added to it.  (The values of the variables
        are set to their defaults so that the user can populate them later.)

    Note
    ----
    This function does not allow one to add element attributes to an exodus
    database.  See `exodus.copy_mesh` function for that capability.
    &#34;&#34;&#34;
    debugPrint = False

    if not isinstance(global_vars, list):
        raise Exception(&#34;ERROR: global_vars is not a list.&#34;)
    if not isinstance(nodal_vars, list):
        raise Exception(&#34;ERROR: nodal_vars is not a list.&#34;)
    if not isinstance(element_vars, list):
        raise Exception(&#34;ERROR: element_vars is not a list.&#34;)
    if not isinstance(node_set_vars, list):
        raise Exception(&#34;ERROR: node_set_vars is not a list.&#34;)
    if not isinstance(side_set_vars, list):
        raise Exception(&#34;ERROR: side_set_vars is not a list.&#34;)

    if exo.modeChar == &#39;r&#39;:
        raise Exception(
            &#34;ERROR: variables cannot be added to an exodus object in read only mode&#34;)

    if debugPrint:
        print(&#34;Add Global Variables&#34;)
    n_new_vars = len(global_vars)
    n_old_vars = exo.get_variable_number(&#39;EX_GLOBAL&#39;)
    n_vars = n_old_vars + n_new_vars
    default_vals = [0.0] * n_new_vars
    if n_new_vars &gt; 0:
        exo.set_variable_number(&#39;EX_GLOBAL&#39;, n_vars)
        for i, var_name in enumerate(global_vars):
            exo.put_variable_name(&#39;EX_GLOBAL&#39;, var_name, n_old_vars + i + 1)
        # One might wish to put all the values for a given global variable in the
        # database at once, but exo.put_global_variable_value() ends up loading
        # all the global variables for a given step and then putting them all back
        # in, so we might as well just use
        # exo.put_all_global_variable_values().
        nSteps = exo.num_times()
        for step in range(nSteps):
            gValues = exo.get_all_global_variable_values(step + 1)
            if exo.use_numpy:
                gValues = exo.np.append(gValues, default_vals)
            else:
                gValues.extend(default_vals)
            exo.put_all_global_variable_values(step + 1, gValues)

    if debugPrint:
        print(&#34;Add Nodal Variables&#34;)
    n_new_vars = len(nodal_vars)
    n_old_vars = exo.get_variable_number(&#39;EX_NODAL&#39;)
    n_vars = n_old_vars + n_new_vars
    if n_new_vars &gt; 0:
        exo.set_variable_number(&#39;EX_NODAL&#39;, n_vars)
        for i, var_name in enumerate(nodal_vars):
            exo.put_variable_name(&#39;EX_NODAL&#39;, var_name, i + n_old_vars + 1)

    internal_add_variables(exo, &#39;EX_ELEM_BLOCK&#39;, element_vars, debugPrint)
    internal_add_variables(exo, &#39;EX_NODE_SET&#39;, node_set_vars, debugPrint)
    internal_add_variables(exo, &#39;EX_SIDE_SET&#39;, side_set_vars, debugPrint)

    return exo</code></pre>
</details>
</dd>
<dt id="exodus3.basename"><code class="name flex">
<span>def <span class="ident">basename</span></span>(<span>file_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Extract base name from file_name.
<code>basename("test.e") -&gt; "test"</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def basename(file_name):
    &#34;&#34;&#34;
    Extract base name from file_name.
    `basename(&#34;test.e&#34;) -&gt; &#34;test&#34;`
    &#34;&#34;&#34;
    return os.path.splitext(file_name)[0]</code></pre>
</details>
</dd>
<dt id="exodus3.collectElemConnectivity"><code class="name flex">
<span>def <span class="ident">collectElemConnectivity</span></span>(<span>exodusHandle, connectivity)</span>
</code></dt>
<dd>
<div class="desc"><p>This function generates a list of lists that represent the element connectivity.</p>
<h2 id="usage">Usage:</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; with exodus(&quot;file.g&quot;, &quot;r&quot;) as exodusHandle:
&gt;&gt;&gt;     connectivity = []
&gt;&gt;&gt;     collectElemConnectivity(exodusHandle, connectivity)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def collectElemConnectivity(exodusHandle, connectivity):
    &#34;&#34;&#34;
      This function generates a list of lists that represent the element connectivity.

    Usage:
    ------
    &gt;&gt;&gt; with exodus(&#34;file.g&#34;, &#34;r&#34;) as exodusHandle:
    &gt;&gt;&gt;     connectivity = []
    &gt;&gt;&gt;     collectElemConnectivity(exodusHandle, connectivity)
    &#34;&#34;&#34;

    if not isinstance(connectivity, list):
        raise Exception(
            &#34;ERROR: connectivity is not a list in call to collectElemConnectivity().&#34;)
    if connectivity:
        raise Exception(
            &#34;ERROR: connectivity is not empty in call to collectElemConnectivity().&#34;)

    blockIds = exodusHandle.get_ids(&#39;EX_ELEM_BLOCK&#39;)
    for blId in blockIds:
        (elem_block_conn, num_elem, num_nodes) = exodusHandle.get_elem_connectivity(blId)
        for k in range(num_elem):
            i = k * num_nodes
            j = i + num_nodes
            local_elem_conn = elem_block_conn[i:j]
            connectivity.append(local_elem_conn)</code></pre>
</details>
</dd>
<dt id="exodus3.collectLocalElemToLocalElems"><code class="name flex">
<span>def <span class="ident">collectLocalElemToLocalElems</span></span>(<span>exodusHandle, connectivity, localNodeToLocalElems, localElemToLocalElems)</span>
</code></dt>
<dd>
<div class="desc"><p>This function generates a list of lists to go from local elem id
to connected local elem ids.</p>
<h2 id="usage">Usage:</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; connectivity = [] ## If this is not empty it will assume it is already filled.
&gt;&gt;&gt; localNodeToLocalElems = [] ## If this is not empty it will assume it is already filled.
&gt;&gt;&gt; localElemToLocalElems = []
&gt;&gt;&gt; with exodus(&quot;file.g&quot;, &quot;r&quot;) as exodusHandle:
&gt;&gt;&gt;     collectLocalElemToLocalElems(exodusHandle, connectivity, localNodeToLocalElems,
...                              localElemToLocalElems)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def collectLocalElemToLocalElems(
        exodusHandle,
        connectivity,
        localNodeToLocalElems,
        localElemToLocalElems):
    &#34;&#34;&#34;
      This function generates a list of lists to go from local elem id
      to connected local elem ids.

    Usage:
    ------
    &gt;&gt;&gt; connectivity = [] ## If this is not empty it will assume it is already filled.
    &gt;&gt;&gt; localNodeToLocalElems = [] ## If this is not empty it will assume it is already filled.
    &gt;&gt;&gt; localElemToLocalElems = []
    &gt;&gt;&gt; with exodus(&#34;file.g&#34;, &#34;r&#34;) as exodusHandle:
    &gt;&gt;&gt;     collectLocalElemToLocalElems(exodusHandle, connectivity, localNodeToLocalElems,
    ...                              localElemToLocalElems)
    &#34;&#34;&#34;

    if not isinstance(connectivity, list):
        raise Exception(
            &#34;ERROR: connectivity is not a list in call to collectLocalElemToLocalElems().&#34;)
    if not isinstance(localNodeToLocalElems, list):
        raise Exception(
            &#34;ERROR: localNodeToLocalElems is not a list in call to collectLocalElemToLocalElems().&#34;)
    if not isinstance(localElemToLocalElems, list):
        raise Exception(
            &#34;ERROR: localElemToLocalElems is not a list in call to collectLocalElemToLocalElems().&#34;)
    if localElemToLocalElems:
        raise Exception(
            &#34;ERROR: localElemToLocalElems is not empty in call to collectLocalElemToLocalElems().&#34;)

    if not connectivity:
        collectElemConnectivity(exodusHandle, connectivity)
    if not localNodeToLocalElems:
        collectLocalNodeToLocalElems(
            exodusHandle, connectivity, localNodeToLocalElems)

    numElems = exodusHandle.num_elems()
    for _i in range(numElems):
        localElemToLocalElems.append([])
    for localElemId in range(numElems):
        nodeList = list(connectivity[localElemId])
        newConnectedElems = []
        for n in nodeList:
            for elem in localNodeToLocalElems[n]:
                newConnectedElems.append(elem)
        localElemToLocalElems[localElemId] = list(set(newConnectedElems))</code></pre>
</details>
</dd>
<dt id="exodus3.collectLocalNodeToLocalElems"><code class="name flex">
<span>def <span class="ident">collectLocalNodeToLocalElems</span></span>(<span>exodusHandle, connectivity, localNodeToLocalElems)</span>
</code></dt>
<dd>
<div class="desc"><p>This function generates a list of lists to go from local node id
to local elem id.</p>
<h2 id="usage">Usage:</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; connectivity = [] ## If this is not empty it will assume it is already filled.
&gt;&gt;&gt; localNodeToLocalElems = []
&gt;&gt;&gt; with exodus(&quot;file.g&quot;, &quot;r&quot;) as exodusHandle:
&gt;&gt;&gt;     collectLocalNodeToLocalElems(exodusHandle, connectivity, localNodeToLocalElems)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def collectLocalNodeToLocalElems(
        exodusHandle,
        connectivity,
        localNodeToLocalElems):
    &#34;&#34;&#34;
      This function generates a list of lists to go from local node id
      to local elem id.

    Usage:
    ------
    &gt;&gt;&gt; connectivity = [] ## If this is not empty it will assume it is already filled.
    &gt;&gt;&gt; localNodeToLocalElems = []
    &gt;&gt;&gt; with exodus(&#34;file.g&#34;, &#34;r&#34;) as exodusHandle:
    &gt;&gt;&gt;     collectLocalNodeToLocalElems(exodusHandle, connectivity, localNodeToLocalElems)
    &#34;&#34;&#34;

    if not isinstance(connectivity, list):
        raise Exception(
            &#34;ERROR: connectivity is not a list in call to collectLocalNodeToLocalElems().&#34;)
    if not isinstance(localNodeToLocalElems, list):
        raise Exception(
            &#34;ERROR: localNodeToLocalElems is not a list in call to collectLocalNodeToLocalElems().&#34;)
    if localNodeToLocalElems:
        raise Exception(
            &#34;ERROR: localNodeToLocalElems is not empty in call to collectLocalNodeToLocalElems().&#34;)

    if not connectivity:
        collectElemConnectivity(exodusHandle, connectivity)

    numNodes = exodusHandle.num_nodes()
    for _i in range(numNodes + 1):
        localNodeToLocalElems.append([])

    localElemId = 0
    for local_elem_conn in connectivity:
        for n in local_elem_conn:
            localNodeToLocalElems[n].append(localElemId)
        localElemId = localElemId + 1</code></pre>
</details>
</dd>
<dt id="exodus3.copyTransfer"><code class="name flex">
<span>def <span class="ident">copyTransfer</span></span>(<span>fromFileName, toFileName, array_type='ctype', additionalGlobalVariables=[], additionalNodalVariables=[], additionalElementVariables=[], additionalNodeSetVariables=[], additionalSideSetVariables=[], additionalElementAttributes=[])</span>
</code></dt>
<dd>
<div class="desc"><p>This function creates an exodus file <code>toFileName</code> and copies
everything from exodus file <code>fromFileName</code> returning a file handle
to <code>toFileName</code>.</p>
<p>Additional space is allocated for <code>additionalGlobalVariables</code>,
<code>additionalNodalVariables</code> and <code>additionalElementVariables</code> if
specified.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>fromFileName</code></strong> :&ensp;<code>string</code></dt>
<dd>File name of the exodus mesh to be copied</dd>
<dt><strong><code>toFileName</code></strong> :&ensp;<code>string</code></dt>
<dd>File name of the new exodus mesh</dd>
<dt><strong><code>array_type</code></strong> :&ensp;<code>'ctype' | 'numpy'</code></dt>
<dd>Specifies whether arrays will be imported and copied as ctype or numpy
arrays.
(This option should make no difference to the user, but it can
be used by developers to test whether the commands within this function
handle both array types correctly.)</dd>
<dt><strong><code>additionalGlobalVariables</code></strong> :&ensp;<code>list</code></dt>
<dd>list of global variable names to add.</dd>
<dt><strong><code>additionalNodalVariables</code></strong> :&ensp;<code>list</code></dt>
<dd>list of nodal variable names to add.</dd>
<dt><strong><code>additionalElementVariables</code></strong> :&ensp;<code>list</code></dt>
<dd>should be a list of element variable
names to add to all blocks or tuples (name, blkIds) where name is
the element variable to add and blkIds is a list of blkIds to add
it to.</dd>
<dt><strong><code>additionalElementAttributes</code></strong> :&ensp;<code>list</code></dt>
<dd>list of element attribute names to
add to all blocks or tuples ( name, blkIds ) where name is the
element attribute to add and blkIds is a list of blkIds to add it
to.</dd>
</dl>
<h2 id="usage">Usage:</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; fromFileName = &quot;input.e&quot;
&gt;&gt;&gt; toFileName = &quot;output.e&quot;
&gt;&gt;&gt; addGlobalVariables = [] ## Do not add any new global variables
&gt;&gt;&gt; ## Add node_dummy1 and node_dummy2 as new node variables
&gt;&gt;&gt; addNodeVariables = [&quot;node_dummy1&quot;, &quot;node_dummy2&quot;]
&gt;&gt;&gt; ## Add elem_dummy1 on blkIds 1, 2, 3 and elem_dummy2 on all blocks
&gt;&gt;&gt; addElementVariables = [ (&quot;elem_dummy1&quot;, [1, 2, 3]), &quot;elem_dummy2&quot; ]
&gt;&gt;&gt; ## Add elem_attr_dummy1 on blkIds 1,2,3 and elem_attr_dummy2 on all blocks
&gt;&gt;&gt; addElementAttributes = [ (&quot;elem_attr_dummy1&quot;,[1,2,3]), &quot;elem_attr_dummy2&quot; ]
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; toFileHandle = copyTransfer(fromFileName,toFileName,addGlobalVariables,addNodeVariables,
...                             addElementVariables,addElementAttributes)
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; ## Fill in new variables
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; toFileHandle.close()
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copyTransfer(
        fromFileName,
        toFileName,
        array_type=&#39;ctype&#39;,
        additionalGlobalVariables=[],
        additionalNodalVariables=[],
        additionalElementVariables=[],
        additionalNodeSetVariables=[],
        additionalSideSetVariables=[],
        additionalElementAttributes=[]):
    &#34;&#34;&#34;
    This function creates an exodus file `toFileName` and copies
    everything from exodus file `fromFileName` returning a file handle
    to `toFileName`.

    Additional space is allocated for `additionalGlobalVariables`,
    `additionalNodalVariables` and `additionalElementVariables` if
    specified.

    Parameters
    ----------
    fromFileName : string
        File name of the exodus mesh to be copied
    toFileName : string
        File name of the new exodus mesh
    array_type : &#39;ctype&#39; | &#39;numpy&#39;
        Specifies whether arrays will be imported and copied as ctype or numpy
        arrays.  (This option should make no difference to the user, but it can
        be used by developers to test whether the commands within this function
        handle both array types correctly.)
    additionalGlobalVariables : list
        list of global variable names to add.
    additionalNodalVariables: list
        list of nodal variable names to add.
    additionalElementVariables: list
        should be a list of element variable
        names to add to all blocks or tuples (name, blkIds) where name is
        the element variable to add and blkIds is a list of blkIds to add
        it to.
    additionalElementAttributes: list
        list of element attribute names to
         add to all blocks or tuples ( name, blkIds ) where name is the
         element attribute to add and blkIds is a list of blkIds to add it
         to.

    Usage:
    ------
    &gt;&gt;&gt; fromFileName = &#34;input.e&#34;
    &gt;&gt;&gt; toFileName = &#34;output.e&#34;
    &gt;&gt;&gt; addGlobalVariables = [] ## Do not add any new global variables
    &gt;&gt;&gt; ## Add node_dummy1 and node_dummy2 as new node variables
    &gt;&gt;&gt; addNodeVariables = [&#34;node_dummy1&#34;, &#34;node_dummy2&#34;]
    &gt;&gt;&gt; ## Add elem_dummy1 on blkIds 1, 2, 3 and elem_dummy2 on all blocks
    &gt;&gt;&gt; addElementVariables = [ (&#34;elem_dummy1&#34;, [1, 2, 3]), &#34;elem_dummy2&#34; ]
    &gt;&gt;&gt; ## Add elem_attr_dummy1 on blkIds 1,2,3 and elem_attr_dummy2 on all blocks
    &gt;&gt;&gt; addElementAttributes = [ (&#34;elem_attr_dummy1&#34;,[1,2,3]), &#34;elem_attr_dummy2&#34; ]

    &gt;&gt;&gt; toFileHandle = copyTransfer(fromFileName,toFileName,addGlobalVariables,addNodeVariables,
    ...                             addElementVariables,addElementAttributes)

    &gt;&gt;&gt; ## Fill in new variables

    &gt;&gt;&gt; toFileHandle.close()
    &#34;&#34;&#34;

    exoFrom = exodus(fromFileName, &#34;r&#34;, array_type=array_type)

    exo_to = copy_mesh(fromFileName, toFileName, exoFromObj=exoFrom,
                       additionalElementAttributes=additionalElementAttributes,
                       array_type=array_type)

    exo_to = transfer_variables(
        exoFrom,
        exo_to,
        additionalGlobalVariables=additionalGlobalVariables,
        additionalNodalVariables=additionalNodalVariables,
        additionalElementVariables=additionalElementVariables,
        additionalNodeSetVariables=additionalNodeSetVariables,
        additionalSideSetVariables=additionalSideSetVariables,
        array_type=array_type)

    exoFrom.close()
    return exo_to</code></pre>
</details>
</dd>
<dt id="exodus3.copy_mesh"><code class="name flex">
<span>def <span class="ident">copy_mesh</span></span>(<span>fromFileName, toFileName, exoFromObj=None, additionalElementAttributes=[], array_type='ctype')</span>
</code></dt>
<dd>
<div class="desc"><p>Copies the mesh data from an existing exodus database to a new exodus
database.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>fromFileName</code></strong> :&ensp;<code>string</code></dt>
<dd>File name of the exodus mesh to be copied</dd>
<dt><strong><code>toFileName</code></strong> :&ensp;<code>string</code></dt>
<dd>File name of the new exodus mesh</dd>
<dt><strong><code>exoFromObj</code></strong> :&ensp;<code><a title="exodus3.exodus" href="#exodus3.exodus">exodus</a> object</code>, optional</dt>
<dd>Exodus object to be copied from.
If an exodus object is supplied, the
fromFileName string will be ignored.</dd>
<dt><strong><code>additionalElementAttributes</code></strong> :&ensp;<code>list</code></dt>
<dd>list of element attribute names to add to all blocks or tuples
( name, blkIds ) where name is the element attribute to add and blkIds is
a list of blkIds to add it to.</dd>
<dt><strong><code>array_type</code></strong> :&ensp;<code>'ctype' | 'numpy'</code></dt>
<dd>Specifies whether arrays will be imported and copied as ctype or numpy
arrays.
(This option should make no difference to the user, but it can
be used by developers to test whether the commands within this function
handle both array types correctly.)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>exo_to</code></strong> :&ensp;<code><a title="exodus3.exodus" href="#exodus3.exodus">exodus</a> object</code></dt>
<dd>New exodus mesh</dd>
</dl>
<h2 id="note">Note:</h2>
<p>This function also allows one to add new element attributes during the copy
process.
The number of element attributes is permanently set when the
block is created, meaning new element attributes can only be added to an
existing mesh by copying it to a new mesh.
The values of the element
attributes are set to their defaults so that the user can populate them
later.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy_mesh(fromFileName, toFileName, exoFromObj=None,
              additionalElementAttributes=[], array_type=&#39;ctype&#39;):
    &#34;&#34;&#34;
    Copies the mesh data from an existing exodus database to a new exodus
    database.

    Parameters
    ----------
    fromFileName : string
        File name of the exodus mesh to be copied
    toFileName : string
        File name of the new exodus mesh
    exoFromObj : exodus object, optional
        Exodus object to be copied from.  If an exodus object is supplied, the
        fromFileName string will be ignored.
    additionalElementAttributes : list
        list of element attribute names to add to all blocks or tuples
        ( name, blkIds ) where name is the element attribute to add and blkIds is
        a list of blkIds to add it to.
    array_type : &#39;ctype&#39; | &#39;numpy&#39;
        Specifies whether arrays will be imported and copied as ctype or numpy
        arrays.  (This option should make no difference to the user, but it can
        be used by developers to test whether the commands within this function
        handle both array types correctly.)

    Returns
    -------
    exo_to : exodus object
        New exodus mesh

    Note:
    -----
    This function also allows one to add new element attributes during the copy
    process.  The number of element attributes is permanently set when the
    block is created, meaning new element attributes can only be added to an
    existing mesh by copying it to a new mesh.  The values of the element
    attributes are set to their defaults so that the user can populate them
    later.
    &#34;&#34;&#34;
    debugPrint = False

    # If the user did not supply a exodus object to copy from, attempt to read an
    # exodus database with the name &#34;fromFileName&#34;
    if exoFromObj is None:
        exoFrom = exodus(fromFileName, &#34;r&#34;, array_type=array_type)
    else:
        exoFrom = exoFromObj

    if os.path.isfile(toFileName):
        raise Exception(
            &#34;ERROR: &#34;,
            toFileName,
            &#34; file already exists cowardly exiting instead of overwriting in call to copy_mesh().&#34;)

    title = exoFrom.title().encode(&#39;ascii&#39;)
    ex_pars = ex_init_params(num_dim=exoFrom.num_dimensions(),
                             num_nodes=exoFrom.num_nodes(),
                             num_elem=exoFrom.num_elems(),
                             num_elem_blk=exoFrom.num_blks(),
                             num_node_sets=exoFrom.num_node_sets(),
                             num_side_sets=exoFrom.num_side_sets(),
                             num_assembly=exoFrom.num_assembly(),
                             num_blob=exoFrom.num_blob())

    exo_to = exodus(toFileName, mode=&#34;w&#34;, array_type=array_type,
                    title=title, init_params=ex_pars)

    if debugPrint:
        print(&#34;Transfer QA records&#34;)
    qaRecords = exoFrom.get_qa_records()
    exo_to.put_qa_records(qaRecords)

    if debugPrint:
        print(&#34;Transfer Nodal Coordinates and Names&#34;)
    exo_to.put_coord_names(exoFrom.get_coord_names())
    (xCoords, yCoords, zCoords) = exoFrom.get_coords()
    exo_to.put_coords(xCoords, yCoords, zCoords)

    if debugPrint:
        print(&#34;Transfer Node Id Map&#34;)
    nodeIdMap = exoFrom.get_node_id_map()
    exo_to.put_node_id_map(nodeIdMap)

    if debugPrint:
        print(&#34;Construct mapping from block ID to element attribute data&#34;)
    # The exodus library does not provide a way to add only new element
    # attributes, so we must collect both the new and the old element
    # attributes
    e_attr_names = dict()
    e_attr_vals = dict()
    # Collect the old element attribute names and the number of elements in each
    # block
    blk_ids = exoFrom.get_ids(&#39;EX_ELEM_BLOCK&#39;)
    blk_num_elem = dict()
    for blk_id in blk_ids:
        (elemType, numElem, nodesPerElem, numAttr) = exoFrom.elem_blk_info(blk_id)
        e_attr_names[blk_id] = []
        e_attr_vals[blk_id] = []
        if numAttr &gt; 0:
            e_attr_names[blk_id].extend(
                exoFrom.get_element_attribute_names(blk_id))
            e_attr_vals[blk_id].extend(exoFrom.get_elem_attr(blk_id))
        blk_num_elem[blk_id] = numElem
    # Collect the new element attribute names
    # (The new names are mapped from &#34;attribute name&#34; to &#34;list of block IDs that
    # contain that attribute&#34;.  We need to have them be mapped as &#34;block ID&#34; to
    # &#34;list of attribute names contained in that block&#34;.)
    for item in additionalElementAttributes:
        if isinstance(item, tuple):
            e_attr_name = item[0]
            e_attr_blk_ids = item[1]
        elif isinstance(item, str):
            e_attr_name = item
            e_attr_blk_ids = blk_ids
        else:
            print((
                &#34;Warning additional element attribute item &#34; +
                item +
                &#34; is not right type to add.&#34;))
            print(&#34;should be a string or tuple, skipping&#34;)
        for blk_id in e_attr_blk_ids:
            if blk_id in blk_ids:
                e_attr_names[blk_id].append(e_attr_name)
                # Concatenate all element attribute values into a single big list,
                # because that is format required by exo.put_elem_attr().
                e_attr_vals[blk_id].extend([0.0] * blk_num_elem[blk_id])

    if debugPrint:
        print(&#34;Transfer Element Data&#34;)
    blkIds = exoFrom.get_ids(&#39;EX_ELEM_BLOCK&#39;)
    for blkId in blkIds:
        (elemType, numElem, nodesPerElem, _oldnumAttr) = exoFrom.elem_blk_info(blkId)
        numAttr = len(e_attr_names[blkId])
        exo_to.put_elem_blk_info(blkId, elemType, numElem, nodesPerElem, numAttr)
        (connectivity, numElem, nodesPerElem) = exoFrom.get_elem_connectivity(blkId)
        exo_to.put_elem_connectivity(blkId, connectivity)
        if numAttr &gt; 0:
            exo_to.put_element_attribute_names(blkId, e_attr_names[blkId])
            exo_to.put_elem_attr(blkId, e_attr_vals[blkId])
        elemProps = exoFrom.get_element_property_names()
        for elemProp in elemProps:
            propVal = exoFrom.get_element_property_value(blkId, elemProp)
            if elemProp == &#34;ID&#34; and propVal == blkId:
                continue
            else:
                exo_to.put_element_property_value(blkId, elemProp, propVal)
        blockName = exoFrom.get_name(&#39;EX_ELEM_BLOCK&#39;, blkId)
        exo_to.put_name(&#39;EX_ELEM_BLOCK&#39;, blkId, blockName)

    if debugPrint:
        print(&#34;Transfer Element Id Map&#34;)
    elemIdMap = exoFrom.get_elem_id_map()
    exo_to.put_elem_id_map(elemIdMap)

    if debugPrint:
        print(&#34;Transfer Node Sets&#34;)
    if exoFrom.num_node_sets() &gt; 0:
        nodeSetProps = exoFrom.get_node_set_property_names()
        nodeSetIds = exoFrom.get_ids(&#39;EX_NODE_SET&#39;)
        for nsId in nodeSetIds:
            (numSetNodes, numSetDistFacts) = exoFrom.get_set_params(&#39;EX_NODE_SET&#39;, nsId)
            exo_to.put_node_set_params(nsId, numSetNodes, numSetDistFacts)
            nsNodes = exoFrom.get_node_set_nodes(nsId)
            exo_to.put_node_set(nsId, nsNodes)
            if numSetDistFacts &gt; 0:
                nsDF = exoFrom.get_node_set_dist_facts(nsId)
                exo_to.put_node_set_dist_fact(nsId, nsDF)
            nodeSetName = exoFrom.get_name(&#39;EX_NODE_SET&#39;, nsId)
            exo_to.put_name(&#39;EX_NODE_SET&#39;, nsId, nodeSetName)
            for nodeSetProp in nodeSetProps:
                propVal = exoFrom.get_node_set_property_value(
                    nsId, nodeSetProp)
                if nodeSetProp == &#34;ID&#34; and propVal == nsId:
                    continue
                else:
                    exo_to.put_node_set_property_value(
                        nsId, nodeSetProp, propVal)

    if debugPrint:
        print(&#34;Transfer Side Sets&#34;)
    if exoFrom.num_side_sets() &gt; 0:
        sideSetProps = exoFrom.get_side_set_property_names()
        sideSetIds = exoFrom.get_ids(&#39;EX_SIDE_SET&#39;)
        for ssId in sideSetIds:
            (numSetSides, numSetDistFacts) = exoFrom.get_set_params(&#39;EX_SIDE_SET&#39;, ssId)
            exo_to.put_side_set_params(ssId, numSetSides, numSetDistFacts)
            (elemList, sideList) = exoFrom.get_side_set(ssId)
            exo_to.put_side_set(ssId, elemList, sideList)
            if numSetDistFacts &gt; 0:
                ssDF = exoFrom.get_side_set_dist_fact(ssId)
                exo_to.put_side_set_dist_fact(ssId, ssDF)
            sideSetName = exoFrom.get_name(&#39;EX_SIDE_SET&#39;, ssId)
            exo_to.put_name(&#39;EX_SIDE_SET&#39;, ssId, sideSetName)
            for sideSetProp in sideSetProps:
                propVal = exoFrom.get_side_set_property_value(
                    ssId, sideSetProp)
                if sideSetProp == &#34;ID&#34; and propVal == ssId:
                    continue
                else:
                    exo_to.put_side_set_property_value(
                        ssId, sideSetProp, propVal)

    # If the user did not supply an exodus object to copy from, then close the
    # database.
    if exoFromObj is None:
        exoFrom.close()

    return exo_to</code></pre>
</details>
</dd>
<dt id="exodus3.ctype_to_numpy"><code class="name flex">
<span>def <span class="ident">ctype_to_numpy</span></span>(<span>exo, c_array)</span>
</code></dt>
<dd>
<div class="desc"><p>Converts a c-type array into a numpy array</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>exo</code></strong> :&ensp;<code><a title="exodus3.exodus" href="#exodus3.exodus">exodus</a> object</code></dt>
<dd>exodus database object initialized with the option <code>array_type = 'numpy'</code></dd>
<dt><strong><code>c_array</code></strong> :&ensp;<code>c-type array</code></dt>
<dd>c-type array to be converted into a numpy array</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>np_array</code></strong> :&ensp;<code>numpy array</code></dt>
<dd>Numpy array converted from c-type array</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ctype_to_numpy(exo, c_array):
    &#34;&#34;&#34;
    Converts a c-type array into a numpy array

    Parameters
    ----------
    exo : exodus object
        exodus database object initialized with the option `array_type = &#39;numpy&#39;`
    c_array : c-type array
        c-type array to be converted into a numpy array

    Returns
    -------
    np_array : numpy array
        Numpy array converted from c-type array
    &#34;&#34;&#34;
    # ctypes currently produce invalid PEP 3118 type codes, which causes numpy
    # to issue a warning.  This is a bug and can be ignored.
    # http://stackoverflow.com/questions/4964101/pep-3118-warning-when-using-ctypes-array-as-numpy-array
    if not c_array:
        return exo.np.array([])

    with exo.warnings.catch_warnings():
        exo.warnings.simplefilter(&#39;ignore&#39;)
        np_array = exo.np.ctypeslib.as_array(c_array)
    return np_array</code></pre>
</details>
</dd>
<dt id="exodus3.ex_entity_type_to_objType"><code class="name flex">
<span>def <span class="ident">ex_entity_type_to_objType</span></span>(<span>entity_type)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ex_entity_type_to_objType(entity_type):
    &#34;&#34;&#34;
    &#34;&#34;&#34;
    entity_dictionary = {
        get_entity_type(&#39;EX_ASSEMBLY&#39;): &#34;assembly&#34;,
        get_entity_type(&#39;EX_BLOB&#39;): &#34;blob&#34;,
        get_entity_type(&#39;EX_EDGE_BLOCK&#39;): &#34;edge block&#34;,
        get_entity_type(&#39;EX_FACE_BLOCK&#39;): &#34;face block&#34;,
        get_entity_type(&#39;EX_ELEM_BLOCK&#39;): &#34;element block&#34;,
        get_entity_type(&#39;EX_NODE_SET&#39;): &#34;node set&#34;,
        get_entity_type(&#39;EX_EDGE_SET&#39;): &#34;edge set&#34;,
        get_entity_type(&#39;EX_FACE_SET&#39;): &#34;face set&#34;,
        get_entity_type(&#39;EX_ELEM_SET&#39;): &#34;element set&#34;,
        get_entity_type(&#39;EX_SIDE_SET&#39;): &#34;side set&#34;,
        get_entity_type(&#39;EX_NODE_MAP&#39;): &#34;node map&#34;,
        get_entity_type(&#39;EX_EDGE_MAP&#39;): &#34;edge map&#34;,
        get_entity_type(&#39;EX_FACE_MAP&#39;): &#34;face map&#34;,
        get_entity_type(&#39;EX_ELEM_MAP&#39;): &#34;element map&#34;
    }

    return entity_dictionary.get(entity_type, &#39;EX_INVALID&#39;)</code></pre>
</details>
</dd>
<dt id="exodus3.ex_inquiry_map"><code class="name flex">
<span>def <span class="ident">ex_inquiry_map</span></span>(<span>inquiry)</span>
</code></dt>
<dd>
<div class="desc"><p>Map the exodus inquiry flags to an enum value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ex_inquiry_map(inquiry):
    &#34;&#34;&#34;
    Map the exodus inquiry flags to an enum value.
    &#34;&#34;&#34;
    return ex_inquiry[inquiry].value</code></pre>
</details>
</dd>
<dt id="exodus3.ex_obj_to_inq"><code class="name flex">
<span>def <span class="ident">ex_obj_to_inq</span></span>(<span>objType)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the ex_inquiry string corresponding to the specified objType.
This can be passed to the ex_inquiry_map() function to get the number of
objects of the specified objType</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ex_obj_to_inq(objType):
    &#34;&#34;&#34;
    Return the ex_inquiry string corresponding to the specified objType.
    This can be passed to the ex_inquiry_map() function to get the number of
    objects of the specified objType
    &#34;&#34;&#34;
    entity_dictionary = {
        &#39;EX_ASSEMBLY&#39;: &#39;EX_INQ_ASSEMBLY&#39;,
        &#39;EX_BLOB&#39;: &#39;EX_INQ_BLOB&#39;,
        &#39;EX_EDGE_BLOCK&#39;: &#39;EX_INQ_EDGE_BLK&#39;,
        &#39;EX_FACE_BLOCK&#39;: &#39;EX_INQ_FACE_BLK&#39;,
        &#39;EX_ELEM_BLOCK&#39;: &#39;EX_INQ_ELEM_BLK&#39;,
        &#39;EX_NODE_SET&#39;: &#39;EX_INQ_NODE_SETS&#39;,
        &#39;EX_EDGE_SET&#39;: &#39;EX_INQ_EDGE_SETS&#39;,
        &#39;EX_FACE_SET&#39;: &#39;EX_INQ_FACE_SETS&#39;,
        &#39;EX_ELEM_SET&#39;: &#39;EX_INQ_ELEM_SETS&#39;,
        &#39;EX_SIDE_SET&#39;: &#39;EX_INQ_SIDE_SETS&#39;,
        &#39;EX_NODE_MAP&#39;: &#39;EX_INQ_NODES&#39;,
        &#39;EX_EDGE_MAP&#39;: &#39;EX_INQ_EDGE&#39;,
        &#39;EX_FACE_MAP&#39;: &#39;EX_INQ_FACE&#39;,
        &#39;EX_ELEM_MAP&#39;: &#39;EX_INQ_ELEM&#39;,
    }

    return entity_dictionary.get(objType, -1)</code></pre>
</details>
</dd>
<dt id="exodus3.getExodusVersion"><code class="name flex">
<span>def <span class="ident">getExodusVersion</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Parse the exodusII.h header file and return the version number or 0 if not
found.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getExodusVersion():
    &#34;&#34;&#34;
    Parse the exodusII.h header file and return the version number or 0 if not
    found.
    &#34;&#34;&#34;
    version_major = -1
    version_minor = -1
    with open(ACCESS + &#34;/include/exodusII.h&#34;) as header_file:
        for line in header_file:
            fields = line.split()
            if (len(fields) == 3 and
                    fields[0] == &#39;#define&#39; and
                    fields[1] == &#39;EXODUS_VERSION_MAJOR&#39;):
                version_major = int(fields[2])
            if (len(fields) == 3 and
                    fields[0] == &#39;#define&#39; and
                    fields[1] == &#39;EXODUS_VERSION_MINOR&#39;):
                version_minor = int(fields[2])
            if (version_major &gt; 0 and version_minor &gt;= 0):
               return 100 * version_major + version_minor
    return 0</code></pre>
</details>
</dd>
<dt id="exodus3.get_entity_type"><code class="name flex">
<span>def <span class="ident">get_entity_type</span></span>(<span>varType)</span>
</code></dt>
<dd>
<div class="desc"><p>Map the exodus ex_entity_type flags to an integer value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_entity_type(varType):
    &#34;&#34;&#34;
    Map the exodus ex_entity_type flags to an integer value.
    &#34;&#34;&#34;
    try:
        return ex_entity_type[varType].value
    except KeyError:
        return varType.value</code></pre>
</details>
</dd>
<dt id="exodus3.internal_add_variables"><code class="name flex">
<span>def <span class="ident">internal_add_variables</span></span>(<span>exo, obj_type, entvars, debugPrint)</span>
</code></dt>
<dd>
<div class="desc"><p>Internal support function for <code>exodus.add_variables</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def internal_add_variables(exo, obj_type, entvars, debugPrint):
    &#34;&#34;&#34; Internal support function for `exodus.add_variables` &#34;&#34;&#34;

    if len(entvars) == 0:
        return

    if debugPrint:
        print(&#34;Construct Truth Table for additional variables&#34;)

    new_var_names = []
    new_var_blks = []
    blk_ids = exo.get_ids(obj_type)
    for item in entvars:
        if isinstance(item, tuple):
            new_var_names.append(item[0])
            in_blks = []
            for blk_id in item[1]:
                if blk_id in blk_ids:
                    in_blks.append(blk_id)
            new_var_blks.append(in_blks)
        elif isinstance(item, str):
            new_var_names.append(item)
            new_var_blks.append(blk_ids)
        else:
            print((&#34;Warning additional variable item &#34; +
                   item + &#34; is not right type to add.&#34;))
            print(&#34;should be a string or tuple, skipping&#34;)

    if debugPrint:
        print(&#34;Add Variables&#34;)
    n_new_vars = len(new_var_names)
    n_old_vars = exo.get_variable_number(obj_type)
    n_vars = n_old_vars + n_new_vars
    if n_new_vars &gt; 0:
        exo.set_variable_number(obj_type, n_vars)
        old_truth_table = []
        if n_old_vars &gt; 0:
            old_truth_table = exo.get_variable_truth_table(obj_type)
        truth_table = []
        n_blks = len(blk_ids)
        for j in range(n_blks):
            for k in range(n_old_vars):
                ndx = j * n_old_vars + k
                truth_table.append(old_truth_table[ndx])
            for m in range(n_new_vars):
                if blk_ids[j] in new_var_blks[m]:
                    truth_table.append(True)
                else:
                    truth_table.append(False)
        exo.set_variable_truth_table(obj_type, truth_table)
        for i, var_name in enumerate(new_var_names):
            exo.put_variable_name(obj_type, var_name, n_old_vars + i + 1)</code></pre>
</details>
</dd>
<dt id="exodus3.internal_transfer_variables"><code class="name flex">
<span>def <span class="ident">internal_transfer_variables</span></span>(<span>exoFrom, exo_to, obj_type, additionalVariables, debugPrint)</span>
</code></dt>
<dd>
<div class="desc"><p>Internal support function for <code>exodus.transfer_variables</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def internal_transfer_variables(exoFrom, exo_to, obj_type, additionalVariables, debugPrint):
    &#34;&#34;&#34; Internal support function for `exodus.transfer_variables` &#34;&#34;&#34;
    if debugPrint:
        print(&#34;Construct Truth Table for additionalVariables&#34;)
    blkIds = exoFrom.get_ids(obj_type)
    numBlks = len(blkIds)
    newVariableNames = []
    newVariableBlocks = []
    for item in additionalVariables:
        if isinstance(item, tuple):
            newVariableNames.append(item[0])
            inBlks = []
            for blkId in item[1]:
                if blkId in blkIds:
                    inBlks.append(blkId)
            newVariableBlocks.append(inBlks)
        elif isinstance(item, str):
            newVariableNames.append(item)
            newVariableBlocks.append(blkIds)
        else:
            print((&#34;Warning additionalVariable item &#34;,
                   item, &#34; is not right type to add.&#34;))
            print(&#34;should be a string or tuple, skipping&#34;)

    nSteps = exoFrom.num_times()
    if debugPrint:
        print(&#34;Add Variables&#34;)
    nNewVars = len(newVariableNames)
    nOrigVars = exoFrom.get_variable_number(obj_type)
    nVars = nOrigVars + nNewVars
    if nVars &gt; 0:
        exo_to.set_variable_number(obj_type, nVars)
        origVarNames = exoFrom.get_variable_names(obj_type)
        origVarNames.extend(newVariableNames)
        truthTable = []
        if nOrigVars &gt; 0:
            truthTable = exoFrom.get_variable_truth_table(obj_type)
        if nNewVars &gt; 0:
            newTruth = []
            for j in range(numBlks):

                for k in range(nOrigVars):
                    index = j * nOrigVars + k
                    newTruth.append(truthTable[index])
                for m in range(nNewVars):
                    if blkIds[j] in newVariableBlocks[m]:
                        newTruth.append(True)
                    else:
                        newTruth.append(False)
            truthTable = newTruth
        exo_to.set_variable_truth_table(obj_type, truthTable)
        for nameIndex in range(nVars):
            varName = origVarNames[nameIndex]
            exo_to.put_variable_name(obj_type, varName, nameIndex + 1)
        truthIndex = 0
        for blkId in blkIds:
            for origVarName in origVarNames:
                if truthTable[truthIndex]:
                    for step in range(nSteps):
                        eValues = exoFrom.get_variable_values(obj_type, blkId,
                                                              origVarName, step + 1)
                        exo_to.put_variable_values(obj_type, blkId,
                                                   origVarName, step + 1, eValues)
                truthIndex = truthIndex + 1
            truthIndex = truthIndex + nNewVars</code></pre>
</details>
</dd>
<dt id="exodus3.setup_ex_assembly"><code class="name flex">
<span>def <span class="ident">setup_ex_assembly</span></span>(<span>assembly)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setup_ex_assembly(assembly):
    ctype_assem = ex_assembly(id=assembly.id, name=assembly.name.encode(), type=assembly.type)
    ctype_assem.entity_count = len(assembly.entity_list)
    ctype_assem.entity_list = (ctypes.c_longlong * ctype_assem.entity_count)(*assembly.entity_list)
    return ctype_assem</code></pre>
</details>
</dd>
<dt id="exodus3.transfer_variables"><code class="name flex">
<span>def <span class="ident">transfer_variables</span></span>(<span>exoFrom, exo_to, array_type='ctype', additionalGlobalVariables=[], additionalNodalVariables=[], additionalElementVariables=[], additionalNodeSetVariables=[], additionalSideSetVariables=[])</span>
</code></dt>
<dd>
<div class="desc"><p>This function transfers variables from <code>exoFrom</code> to <code>exo_to</code> and allows
additional variables to be added with <code>additionalGlobalVariables</code>,
<code>additionalNodalVariables</code>, and <code>additionalElementVariables</code>.
Additional
variables values are set to their defaults so that the user can populate
them later.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>exoFrom</code></strong> :&ensp;<code><a title="exodus3.exodus" href="#exodus3.exodus">exodus</a> database object</code></dt>
<dd>exodus object to transfer from</dd>
<dt><strong><code>exo_to</code></strong> :&ensp;<code><a title="exodus3.exodus" href="#exodus3.exodus">exodus</a> database object</code></dt>
<dd>exodus object to transfer to</dd>
<dt><strong><code>additionalGlobalVariables</code></strong> :&ensp;<code>list</code></dt>
<dd>list of global variable names to add.</dd>
<dt><strong><code>additionalNodalVariables</code></strong> :&ensp;<code>list</code></dt>
<dd>list of nodal variable names to add.</dd>
<dt><strong><code>additionalElementVariables</code></strong> :&ensp;<code>list</code></dt>
<dd>should be a list of element variable names to add to all blocks or
tuples <code>(name, blkIds)</code> where <code>name</code> is the element variable to add
and <code>blkIds</code> is a list of block ids to add it to.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transfer_variables(
        exoFrom,
        exo_to,
        array_type=&#39;ctype&#39;,
        additionalGlobalVariables=[],
        additionalNodalVariables=[],
        additionalElementVariables=[],
        additionalNodeSetVariables=[],
        additionalSideSetVariables=[]):
    &#34;&#34;&#34;
    This function transfers variables from `exoFrom` to `exo_to` and allows
    additional variables to be added with `additionalGlobalVariables`,
    `additionalNodalVariables`, and `additionalElementVariables`.  Additional
    variables values are set to their defaults so that the user can populate
    them later.

    Parameters
    ----------
    exoFrom : exodus database object
        exodus object to transfer from

    exo_to : exodus database object
        exodus object to transfer to

    additionalGlobalVariables : list
        list of global variable names to add.

    additionalNodalVariables : list
        list of nodal variable names to add.

    additionalElementVariables : list
        should be a list of element variable names to add to all blocks or
        tuples `(name, blkIds)` where `name` is the element variable to add
        and `blkIds` is a list of block ids to add it to.
    &#34;&#34;&#34;
    # IDEA: It may make sense to make transfer_variables() strictly transfer
    # variables, and use add_variables() to add new variables.  Alternatively,
    # add_variables() could be called within transfer_variables() to add
    # new variables to the exo_to database.  Either way, we should minimize
    # duplicate code if possible.

    debugPrint = False

    if not isinstance(additionalGlobalVariables, list):
        raise Exception(&#34;ERROR: additionalGlobalVariables is not a list.&#34;)
    if not isinstance(additionalNodalVariables, list):
        raise Exception(&#34;ERROR: additionalNodalVariables is not a list.&#34;)
    if not isinstance(additionalElementVariables, list):
        raise Exception(&#34;ERROR: additionalElementVariables is not a list.&#34;)
    if not isinstance(additionalNodeSetVariables, list):
        raise Exception(&#34;ERROR: additionalNodeSetVariables is not a list.&#34;)
    if not isinstance(additionalSideSetVariables, list):
        raise Exception(&#34;ERROR: additionalSideSetVariables is not a list.&#34;)

    if debugPrint:
        print(&#34;Transfer Info records&#34;)
    numInfoRecs = exoFrom.num_info_records()
    if numInfoRecs &gt; 0:
        infoRecs = exoFrom.get_info_records()
        exo_to.put_info_records(infoRecs)
    if debugPrint:
        print(&#34;Transfer time values&#34;)

    nSteps = exoFrom.num_times()
    if nSteps == 0:
        return exo_to

    timeVals = exoFrom.get_times()
    for step in range(nSteps):
        exo_to.put_time(step + 1, timeVals[step])

    if debugPrint:
        print(&#34;Add Global Variables&#34;)
    nNewGlobalVars = len(additionalGlobalVariables)
    nGlobalVars = exoFrom.get_variable_number(&#39;EX_GLOBAL&#39;) + nNewGlobalVars
    defaultNewVarVals = []
    for _i in range(nNewGlobalVars):
        defaultNewVarVals.append(0.0)
    if nGlobalVars &gt; 0:
        exo_to.set_variable_number(&#39;EX_GLOBAL&#39;, nGlobalVars)
        gVarNames = exoFrom.get_variable_names(&#39;EX_GLOBAL&#39;)
        gVarNames.extend(additionalGlobalVariables)
        for nameIndex in range(nGlobalVars):
            globalVarName = gVarNames[nameIndex]
            exo_to.put_variable_name(&#39;EX_GLOBAL&#39;, globalVarName, nameIndex + 1)
        for step in range(nSteps):
            gValues = exoFrom.get_all_global_variable_values(step + 1)
            if array_type == &#39;numpy&#39;:
                gValues = exo_to.np.append(gValues, defaultNewVarVals)
            else:
                gValues.extend(defaultNewVarVals)
            exo_to.put_all_global_variable_values(step + 1, gValues)

    if debugPrint:
        print(&#34;Add Nodal Variables&#34;)
    nNewNodalVars = len(additionalNodalVariables)
    nOrigNodalVars = exoFrom.get_variable_number(&#39;EX_NODAL&#39;)
    nNodalVars = nOrigNodalVars + nNewNodalVars
    if nNodalVars &gt; 0:
        exo_to.set_variable_number(&#39;EX_NODAL&#39;, nNodalVars)
        nVarNames = exoFrom.get_variable_names(&#39;EX_NODAL&#39;)
        nVarNames.extend(additionalNodalVariables)
        for nameIndex in range(nNodalVars):
            nodalVarName = nVarNames[nameIndex]
            exo_to.put_variable_name(&#39;EX_NODAL&#39;, nodalVarName, nameIndex + 1)
            if nameIndex &lt; nOrigNodalVars:
                for step in range(nSteps):
                    nValues = exoFrom.get_node_variable_values(
                        nodalVarName, step + 1)
                    exo_to.put_node_variable_values(
                        nodalVarName, step + 1, nValues)

    internal_transfer_variables(exoFrom, exo_to, &#39;EX_ELEM_BLOCK&#39;, additionalElementVariables, debugPrint)
    internal_transfer_variables(exoFrom, exo_to, &#39;EX_NODE_SET&#39;, additionalNodeSetVariables, debugPrint)
    internal_transfer_variables(exoFrom, exo_to, &#39;EX_SIDE_SET&#39;, additionalSideSetVariables, debugPrint)
    return exo_to</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="exodus3.assembly"><code class="flex name class">
<span>class <span class="ident">assembly</span></span>
<span>(</span><span>name, id, type)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class assembly:
    def __init__(self, name, id, type):
        self.name = name
        self.id = id
        if isinstance(type, str):
            type = ex_entity_type[type].value
        if isinstance(type, ex_entity_type):
            type = type.value
        self.type = type
        self.entity_list = []

    def __repr__(self):
        return &#34;assembly(name=%r, type=%r, id=%r, members=%r)&#34; % (self.name,self.type,self.id,self.entity_list)</code></pre>
</details>
</dd>
<dt id="exodus3.attribute"><code class="flex name class">
<span>class <span class="ident">attribute</span></span>
<span>(</span><span>name, type, id)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class attribute:
    def __init__(self, name, type, id):
        self.name = name
        self.entity_type = type
        self.entity_id = id
        self.values = []

    def __repr__(self):
        return &#34;attribute(name=%r, entity_type=%r, entity_id=%r, values=%r)&#34; % (self.name,self.entity_type,self.entity_id,self.values)</code></pre>
</details>
</dd>
<dt id="exodus3.blob"><code class="flex name class">
<span>class <span class="ident">blob</span></span>
<span>(</span><span>name, id, num_entry)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class blob(object):
    def __init__(self, name, id, num_entry):
        self.name = name
        self.id = id
        self.num_entry = num_entry

    def __repr__(self):
        return &#34;blob(name=%r, id=%r, num_entry=%r)&#34; % (self.name,self.id,self.num_entry)</code></pre>
</details>
</dd>
<dt id="exodus3.ex_assembly"><code class="flex name class">
<span>class <span class="ident">ex_assembly</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Structure defining the assembly parameters.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>id</code></strong> :&ensp;<code>int64_t</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>char *</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>type</code></strong> :&ensp;<code><a title="exodus3.ex_entity_type" href="#exodus3.ex_entity_type">ex_entity_type</a></code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>entity_count</code></strong> :&ensp;<code>int</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>entity_list</code></strong> :&ensp;<code>void_int *</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ex_assembly(ctypes.Structure):
    &#34;&#34;&#34;
    Structure defining the assembly parameters.

    Parameters
    ----------
    id : int64_t
    name : char *
    type : ex_entity_type
    entity_count : int
    entity_list : void_int *
    &#34;&#34;&#34;
    _fields_ = [(&#34;id&#34;, ctypes.c_longlong),
                (&#34;name&#34;, ctypes.c_char_p),
                (&#34;type&#34;, ctypes.c_int),
                (&#34;entity_count&#34;, ctypes.c_int),
                (&#34;entity_list&#34;, ctypes.POINTER(ctypes.c_longlong))]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>_ctypes.Structure</li>
<li>_ctypes._CData</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="exodus3.ex_assembly.entity_count"><code class="name">var <span class="ident">entity_count</span></code></dt>
<dd>
<div class="desc"><p>Structure/Union member</p></div>
</dd>
<dt id="exodus3.ex_assembly.entity_list"><code class="name">var <span class="ident">entity_list</span></code></dt>
<dd>
<div class="desc"><p>Structure/Union member</p></div>
</dd>
<dt id="exodus3.ex_assembly.id"><code class="name">var <span class="ident">id</span></code></dt>
<dd>
<div class="desc"><p>Structure/Union member</p></div>
</dd>
<dt id="exodus3.ex_assembly.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>Structure/Union member</p></div>
</dd>
<dt id="exodus3.ex_assembly.type"><code class="name">var <span class="ident">type</span></code></dt>
<dd>
<div class="desc"><p>Structure/Union member</p></div>
</dd>
</dl>
</dd>
<dt id="exodus3.ex_attribute"><code class="flex name class">
<span>class <span class="ident">ex_attribute</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Used for accessing underlying exodus library&hellip;</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ex_attribute(ctypes.Structure):
    &#34;&#34;&#34;
    Used for accessing underlying exodus library...
    &#34;&#34;&#34;
    _fields_ = [(&#34;entity_type&#34;, ctypes.c_int),
                (&#34;entity_id&#34;, ctypes.c_longlong),
                (&#34;name&#34;, ctypes.c_char * 256),
                (&#34;type&#34;, ctypes.c_int),
                (&#34;value_count&#34;, ctypes.c_longlong),
                (&#34;values&#34;, ctypes.c_void_p)]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>_ctypes.Structure</li>
<li>_ctypes._CData</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="exodus3.ex_attribute.entity_id"><code class="name">var <span class="ident">entity_id</span></code></dt>
<dd>
<div class="desc"><p>Structure/Union member</p></div>
</dd>
<dt id="exodus3.ex_attribute.entity_type"><code class="name">var <span class="ident">entity_type</span></code></dt>
<dd>
<div class="desc"><p>Structure/Union member</p></div>
</dd>
<dt id="exodus3.ex_attribute.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>Structure/Union member</p></div>
</dd>
<dt id="exodus3.ex_attribute.type"><code class="name">var <span class="ident">type</span></code></dt>
<dd>
<div class="desc"><p>Structure/Union member</p></div>
</dd>
<dt id="exodus3.ex_attribute.value_count"><code class="name">var <span class="ident">value_count</span></code></dt>
<dd>
<div class="desc"><p>Structure/Union member</p></div>
</dd>
<dt id="exodus3.ex_attribute.values"><code class="name">var <span class="ident">values</span></code></dt>
<dd>
<div class="desc"><p>Structure/Union member</p></div>
</dd>
</dl>
</dd>
<dt id="exodus3.ex_blob"><code class="flex name class">
<span>class <span class="ident">ex_blob</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Structure defining the blob parameters.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>id</code></strong> :&ensp;<code>int64_t</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>char *</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>num_entry</code></strong> :&ensp;<code>int64_t</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ex_blob(ctypes.Structure):
    &#34;&#34;&#34;
    Structure defining the blob parameters.

    Parameters
    ----------
    id : int64_t
    name : char *
    num_entry : int64_t
    &#34;&#34;&#34;
    _fields_ = [(&#34;id&#34;, ctypes.c_longlong),
                (&#34;name&#34;, ctypes.c_char_p),
                (&#34;num_entry&#34;, ctypes.c_longlong)]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>_ctypes.Structure</li>
<li>_ctypes._CData</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="exodus3.ex_blob.id"><code class="name">var <span class="ident">id</span></code></dt>
<dd>
<div class="desc"><p>Structure/Union member</p></div>
</dd>
<dt id="exodus3.ex_blob.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>Structure/Union member</p></div>
</dd>
<dt id="exodus3.ex_blob.num_entry"><code class="name">var <span class="ident">num_entry</span></code></dt>
<dd>
<div class="desc"><p>Structure/Union member</p></div>
</dd>
</dl>
</dd>
<dt id="exodus3.ex_entity_type"><code class="flex name class">
<span>class <span class="ident">ex_entity_type</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>The ex_entity_type enum from the exodusII.h include file</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>EX_NODAL</code></strong></dt>
<dd>nodal "block" for variables</dd>
<dt><strong><code>EX_NODE_BLOCK</code></strong></dt>
<dd>alias for EX_NODAL</dd>
<dt><strong><code>EX_NODE_SET</code></strong></dt>
<dd>node set property code</dd>
<dt><strong><code>EX_EDGE_BLOCK</code></strong></dt>
<dd>edge block property code</dd>
<dt><strong><code>EX_EDGE_SET</code></strong></dt>
<dd>edge set property code</dd>
<dt><strong><code>EX_FACE_BLOCK</code></strong></dt>
<dd>face block property code</dd>
<dt><strong><code>EX_FACE_SET</code></strong></dt>
<dd>face set property code</dd>
<dt><strong><code>EX_ELEM_BLOCK</code></strong></dt>
<dd>element block property code</dd>
<dt><strong><code>EX_ELEM_SET</code></strong></dt>
<dd>face set property code</dd>
<dt><strong><code>EX_SIDE_SET</code></strong></dt>
<dd>side set property code</dd>
<dt><strong><code>EX_ELEM_MAP</code></strong></dt>
<dd>element map property code</dd>
<dt><strong><code>EX_NODE_MAP</code></strong></dt>
<dd>node map property code</dd>
<dt><strong><code>EX_EDGE_MAP</code></strong></dt>
<dd>edge map property code</dd>
<dt><strong><code>EX_FACE_MAP</code></strong></dt>
<dd>face map property code</dd>
<dt><strong><code>EX_GLOBAL</code></strong></dt>
<dd>global "block" for variables</dd>
<dt><strong><code>EX_COORDINATE</code></strong></dt>
<dd>kluge so some internal wrapper functions work</dd>
<dt><strong><code>EX_ASSEMBLY</code></strong></dt>
<dd>assemblies (collections of other entities)</dd>
<dt><strong><code>EX_BLOB</code></strong></dt>
<dd>blob (arbitrary sized binary object)</dd>
<dt><strong><code>EX_INVALID</code></strong></dt>
<dd>invalid</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ex_entity_type(Enum):
    &#34;&#34;&#34;
    The ex_entity_type enum from the exodusII.h include file

    Parameters
    ----------
    EX_NODAL
         nodal \&#34;block\&#34; for variables
    EX_NODE_BLOCK
         alias for EX_NODAL
    EX_NODE_SET
         node set property code
    EX_EDGE_BLOCK
         edge block property code
    EX_EDGE_SET
         edge set property code
    EX_FACE_BLOCK
         face block property code
    EX_FACE_SET
         face set property code
    EX_ELEM_BLOCK
         element block property code
    EX_ELEM_SET
         face set property code
    EX_SIDE_SET
         side set property code
    EX_ELEM_MAP
         element map property code
    EX_NODE_MAP
         node map property code
    EX_EDGE_MAP
         edge map property code
    EX_FACE_MAP
         face map property code
    EX_GLOBAL
         global \&#34;block\&#34; for variables
    EX_COORDINATE
         kluge so some internal wrapper functions work
    EX_ASSEMBLY
         assemblies (collections of other entities)
    EX_BLOB
         blob (arbitrary sized binary object)
    EX_INVALID
         invalid
    &#34;&#34;&#34;
    EX_NODAL      = 14
    EX_NODE_BLOCK = 14
    EX_NODE_SET   = 2
    EX_EDGE_BLOCK = 6
    EX_EDGE_SET   = 7
    EX_FACE_BLOCK = 8
    EX_FACE_SET   = 9
    EX_ELEM_BLOCK = 1
    EX_ELEM_SET   = 10
    EX_SIDE_SET = 3
    EX_ELEM_MAP = 4
    EX_NODE_MAP = 5
    EX_EDGE_MAP = 11
    EX_FACE_MAP = 12
    EX_GLOBAL     = 13
    EX_COORDINATE = 15
    EX_ASSEMBLY   = 16
    EX_BLOB   = 17
    EX_INVALID    = -1</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exodus3.ex_entity_type.EX_ASSEMBLY"><code class="name">var <span class="ident">EX_ASSEMBLY</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exodus3.ex_entity_type.EX_BLOB"><code class="name">var <span class="ident">EX_BLOB</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exodus3.ex_entity_type.EX_COORDINATE"><code class="name">var <span class="ident">EX_COORDINATE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exodus3.ex_entity_type.EX_EDGE_BLOCK"><code class="name">var <span class="ident">EX_EDGE_BLOCK</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exodus3.ex_entity_type.EX_EDGE_MAP"><code class="name">var <span class="ident">EX_EDGE_MAP</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exodus3.ex_entity_type.EX_EDGE_SET"><code class="name">var <span class="ident">EX_EDGE_SET</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exodus3.ex_entity_type.EX_ELEM_BLOCK"><code class="name">var <span class="ident">EX_ELEM_BLOCK</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exodus3.ex_entity_type.EX_ELEM_MAP"><code class="name">var <span class="ident">EX_ELEM_MAP</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exodus3.ex_entity_type.EX_ELEM_SET"><code class="name">var <span class="ident">EX_ELEM_SET</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exodus3.ex_entity_type.EX_FACE_BLOCK"><code class="name">var <span class="ident">EX_FACE_BLOCK</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exodus3.ex_entity_type.EX_FACE_MAP"><code class="name">var <span class="ident">EX_FACE_MAP</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exodus3.ex_entity_type.EX_FACE_SET"><code class="name">var <span class="ident">EX_FACE_SET</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exodus3.ex_entity_type.EX_GLOBAL"><code class="name">var <span class="ident">EX_GLOBAL</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exodus3.ex_entity_type.EX_INVALID"><code class="name">var <span class="ident">EX_INVALID</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exodus3.ex_entity_type.EX_NODAL"><code class="name">var <span class="ident">EX_NODAL</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exodus3.ex_entity_type.EX_NODE_BLOCK"><code class="name">var <span class="ident">EX_NODE_BLOCK</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exodus3.ex_entity_type.EX_NODE_MAP"><code class="name">var <span class="ident">EX_NODE_MAP</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exodus3.ex_entity_type.EX_NODE_SET"><code class="name">var <span class="ident">EX_NODE_SET</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exodus3.ex_entity_type.EX_SIDE_SET"><code class="name">var <span class="ident">EX_SIDE_SET</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="exodus3.ex_init_params"><code class="flex name class">
<span>class <span class="ident">ex_init_params</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Parameters defining the model dimension, note that many are optional.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>num_dim</code></strong> :&ensp;<code>int</code></dt>
<dd>number of model dimensions</dd>
<dt><strong><code>num_nodes</code></strong> :&ensp;<code>int</code></dt>
<dd>number of model nodes</dd>
<dt><strong><code>num_edge</code></strong> :&ensp;<code>int</code></dt>
<dd>number of model edges</dd>
<dt><strong><code>num_edge_blk</code></strong> :&ensp;<code>int</code></dt>
<dd>number of model edge blocks</dd>
<dt><strong><code>num_face</code></strong> :&ensp;<code>int</code></dt>
<dd>number of model faces</dd>
<dt><strong><code>num_face_blk</code></strong> :&ensp;<code>int</code></dt>
<dd>number of model face blocks</dd>
<dt><strong><code>num_elem</code></strong> :&ensp;<code>int</code></dt>
<dd>number of model elements</dd>
<dt><strong><code>num_elem_blk</code></strong> :&ensp;<code>int</code></dt>
<dd>number of model element blocks</dd>
<dt><strong><code>num_node_sets</code></strong> :&ensp;<code>int</code></dt>
<dd>number of model node sets</dd>
<dt><strong><code>num_edge_sets</code></strong> :&ensp;<code>int</code></dt>
<dd>number of model edge sets</dd>
<dt><strong><code>num_face_sets</code></strong> :&ensp;<code>int</code></dt>
<dd>number of model face sets</dd>
<dt><strong><code>num_side_sets</code></strong> :&ensp;<code>int</code></dt>
<dd>number of model side sets</dd>
<dt><strong><code>num_elem_sets</code></strong> :&ensp;<code>int</code></dt>
<dd>number of model elem sets</dd>
<dt><strong><code>num_node_maps</code></strong> :&ensp;<code>int</code></dt>
<dd>number of model node maps</dd>
<dt><strong><code>num_edge_maps</code></strong> :&ensp;<code>int</code></dt>
<dd>number of model edge maps</dd>
<dt><strong><code>num_face_maps</code></strong> :&ensp;<code>int</code></dt>
<dd>number of model face maps</dd>
<dt><strong><code>num_elem_maps</code></strong> :&ensp;<code>int</code></dt>
<dd>number of model elem maps</dd>
<dt><strong><code>num_assembly</code></strong> :&ensp;<code>int</code></dt>
<dd>number of assemblies</dd>
<dt><strong><code>num_blob</code></strong> :&ensp;<code>int</code></dt>
<dd>number of blobs</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ex_init_params(ctypes.Structure):
    &#34;&#34;&#34;
    Parameters defining the model dimension, note that many are optional.

    Parameters
    ----------
    num_dim : int
        number of model dimensions
    num_nodes : int
        number of model nodes
    num_edge : int
        number of model edges
    num_edge_blk : int
        number of model edge blocks
    num_face : int
        number of model faces
    num_face_blk : int
        number of model face blocks
    num_elem : int
        number of model elements
    num_elem_blk : int
        number of model element blocks
    num_node_sets : int
        number of model node sets
    num_edge_sets : int
        number of model edge sets
    num_face_sets : int
        number of model face sets
    num_side_sets : int
        number of model side sets
    num_elem_sets : int
        number of model elem sets
    num_node_maps : int
        number of model node maps
    num_edge_maps : int
        number of model edge maps
    num_face_maps : int
        number of model face maps
    num_elem_maps : int
        number of model elem maps
    num_assembly : int
        number of assemblies
    num_blob : int
        number of blobs
    &#34;&#34;&#34;
    _fields_ = [(&#34;title&#34;, ctypes.c_char * (MAX_LINE_LENGTH + 1)),
                (&#34;num_dim&#34;, ctypes.c_longlong),
                (&#34;num_nodes&#34;, ctypes.c_longlong),
                (&#34;num_edge&#34;, ctypes.c_longlong),
                (&#34;num_edge_blk&#34;, ctypes.c_longlong),
                (&#34;num_face&#34;, ctypes.c_longlong),
                (&#34;num_face_blk&#34;, ctypes.c_longlong),
                (&#34;num_elem&#34;, ctypes.c_longlong),
                (&#34;num_elem_blk&#34;, ctypes.c_longlong),
                (&#34;num_node_sets&#34;, ctypes.c_longlong),
                (&#34;num_edge_sets&#34;, ctypes.c_longlong),
                (&#34;num_face_sets&#34;, ctypes.c_longlong),
                (&#34;num_side_sets&#34;, ctypes.c_longlong),
                (&#34;num_elem_sets&#34;, ctypes.c_longlong),
                (&#34;num_node_maps&#34;, ctypes.c_longlong),
                (&#34;num_edge_maps&#34;, ctypes.c_longlong),
                (&#34;num_face_maps&#34;, ctypes.c_longlong),
                (&#34;num_elem_maps&#34;, ctypes.c_longlong),
                (&#34;num_assembly&#34;, ctypes.c_longlong),
                (&#34;num_blob&#34;, ctypes.c_longlong)]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>_ctypes.Structure</li>
<li>_ctypes._CData</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="exodus3.ex_init_params.num_assembly"><code class="name">var <span class="ident">num_assembly</span></code></dt>
<dd>
<div class="desc"><p>Structure/Union member</p></div>
</dd>
<dt id="exodus3.ex_init_params.num_blob"><code class="name">var <span class="ident">num_blob</span></code></dt>
<dd>
<div class="desc"><p>Structure/Union member</p></div>
</dd>
<dt id="exodus3.ex_init_params.num_dim"><code class="name">var <span class="ident">num_dim</span></code></dt>
<dd>
<div class="desc"><p>Structure/Union member</p></div>
</dd>
<dt id="exodus3.ex_init_params.num_edge"><code class="name">var <span class="ident">num_edge</span></code></dt>
<dd>
<div class="desc"><p>Structure/Union member</p></div>
</dd>
<dt id="exodus3.ex_init_params.num_edge_blk"><code class="name">var <span class="ident">num_edge_blk</span></code></dt>
<dd>
<div class="desc"><p>Structure/Union member</p></div>
</dd>
<dt id="exodus3.ex_init_params.num_edge_maps"><code class="name">var <span class="ident">num_edge_maps</span></code></dt>
<dd>
<div class="desc"><p>Structure/Union member</p></div>
</dd>
<dt id="exodus3.ex_init_params.num_edge_sets"><code class="name">var <span class="ident">num_edge_sets</span></code></dt>
<dd>
<div class="desc"><p>Structure/Union member</p></div>
</dd>
<dt id="exodus3.ex_init_params.num_elem"><code class="name">var <span class="ident">num_elem</span></code></dt>
<dd>
<div class="desc"><p>Structure/Union member</p></div>
</dd>
<dt id="exodus3.ex_init_params.num_elem_blk"><code class="name">var <span class="ident">num_elem_blk</span></code></dt>
<dd>
<div class="desc"><p>Structure/Union member</p></div>
</dd>
<dt id="exodus3.ex_init_params.num_elem_maps"><code class="name">var <span class="ident">num_elem_maps</span></code></dt>
<dd>
<div class="desc"><p>Structure/Union member</p></div>
</dd>
<dt id="exodus3.ex_init_params.num_elem_sets"><code class="name">var <span class="ident">num_elem_sets</span></code></dt>
<dd>
<div class="desc"><p>Structure/Union member</p></div>
</dd>
<dt id="exodus3.ex_init_params.num_face"><code class="name">var <span class="ident">num_face</span></code></dt>
<dd>
<div class="desc"><p>Structure/Union member</p></div>
</dd>
<dt id="exodus3.ex_init_params.num_face_blk"><code class="name">var <span class="ident">num_face_blk</span></code></dt>
<dd>
<div class="desc"><p>Structure/Union member</p></div>
</dd>
<dt id="exodus3.ex_init_params.num_face_maps"><code class="name">var <span class="ident">num_face_maps</span></code></dt>
<dd>
<div class="desc"><p>Structure/Union member</p></div>
</dd>
<dt id="exodus3.ex_init_params.num_face_sets"><code class="name">var <span class="ident">num_face_sets</span></code></dt>
<dd>
<div class="desc"><p>Structure/Union member</p></div>
</dd>
<dt id="exodus3.ex_init_params.num_node_maps"><code class="name">var <span class="ident">num_node_maps</span></code></dt>
<dd>
<div class="desc"><p>Structure/Union member</p></div>
</dd>
<dt id="exodus3.ex_init_params.num_node_sets"><code class="name">var <span class="ident">num_node_sets</span></code></dt>
<dd>
<div class="desc"><p>Structure/Union member</p></div>
</dd>
<dt id="exodus3.ex_init_params.num_nodes"><code class="name">var <span class="ident">num_nodes</span></code></dt>
<dd>
<div class="desc"><p>Structure/Union member</p></div>
</dd>
<dt id="exodus3.ex_init_params.num_side_sets"><code class="name">var <span class="ident">num_side_sets</span></code></dt>
<dd>
<div class="desc"><p>Structure/Union member</p></div>
</dd>
<dt id="exodus3.ex_init_params.title"><code class="name">var <span class="ident">title</span></code></dt>
<dd>
<div class="desc"><p>Structure/Union member</p></div>
</dd>
</dl>
</dd>
<dt id="exodus3.ex_inquiry"><code class="flex name class">
<span>class <span class="ident">ex_inquiry</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>An enumeration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ex_inquiry(Enum):
        EX_INQ_FILE_TYPE = 1                    # inquire EXODUS file type
        EX_INQ_API_VERS = 2                     # inquire API version number
        EX_INQ_DB_VERS = 3                      # inquire database version number
        EX_INQ_TITLE = 4                        # inquire database title
        EX_INQ_DIM = 5                          # inquire number of dimensions
        EX_INQ_NODES = 6                        # inquire number of nodes
        EX_INQ_ELEM = 7                         # inquire number of elements
        EX_INQ_ELEM_BLK = 8                     # inquire number of element blocks
        EX_INQ_NODE_SETS = 9                    # inquire number of node sets
        EX_INQ_NS_NODE_LEN = 10                 # inquire length of node set node list
        EX_INQ_SIDE_SETS = 11                   # inquire number of side sets
        EX_INQ_SS_NODE_LEN = 12                 # inquire length of side set node list
        EX_INQ_SS_ELEM_LEN = 13                 # inquire length of side set element list
        EX_INQ_QA = 14                          # inquire number of QA records
        EX_INQ_INFO = 15                        # inquire number of info records
        EX_INQ_TIME = 16                        # inquire number of time steps in the database
        EX_INQ_EB_PROP = 17                     # inquire number of element block properties
        EX_INQ_NS_PROP = 18                     # inquire number of node set properties
        EX_INQ_SS_PROP = 19                     # inquire number of side set properties
        # inquire length of node set distribution factor list
        EX_INQ_NS_DF_LEN = 20
        # inquire length of side set distribution factor list
        EX_INQ_SS_DF_LEN = 21
        EX_INQ_LIB_VERS = 22                    # inquire API Lib vers number
        EX_INQ_EM_PROP = 23                     # inquire number of element map properties
        EX_INQ_NM_PROP = 24                     # inquire number of node map properties
        EX_INQ_ELEM_MAP = 25                    # inquire number of element maps
        EX_INQ_NODE_MAP = 26                    # inquire number of node maps
        EX_INQ_EDGE = 27                        # inquire number of edges
        EX_INQ_EDGE_BLK = 28                    # inquire number of edge blocks
        EX_INQ_EDGE_SETS = 29                   # inquire number of edge sets
        # inquire length of concat edge set edge list
        EX_INQ_ES_LEN = 30
        # inquire length of concat edge set dist factor list
        EX_INQ_ES_DF_LEN = 31
        # inquire number of properties stored per edge block
        EX_INQ_EDGE_PROP = 32
        # inquire number of properties stored per edge set
        EX_INQ_ES_PROP = 33
        EX_INQ_FACE = 34                        # inquire number of faces
        EX_INQ_FACE_BLK = 35                    # inquire number of face blocks
        EX_INQ_FACE_SETS = 36                   # inquire number of face sets
        # inquire length of concat face set face list
        EX_INQ_FS_LEN = 37
        # inquire length of concat face set dist factor list
        EX_INQ_FS_DF_LEN = 38
        # inquire number of properties stored per face block
        EX_INQ_FACE_PROP = 39
        # inquire number of properties stored per face set
        EX_INQ_FS_PROP = 40
        EX_INQ_ELEM_SETS = 41                   # inquire number of element sets
        # inquire length of concat element set element list
        EX_INQ_ELS_LEN = 42
        # inquire length of concat element set dist factor list
        EX_INQ_ELS_DF_LEN = 43
        # inquire number of properties stored per elem set
        EX_INQ_ELS_PROP = 44
        EX_INQ_EDGE_MAP = 45                    # inquire number of edge maps
        EX_INQ_FACE_MAP = 46                    # inquire number of face maps
        EX_INQ_COORD_FRAMES = 47                # inquire number of coordinate frames
        # inquire size of MAX_NAME_LENGTH dimension on database
        EX_INQ_DB_MAX_ALLOWED_NAME_LENGTH = 48
        # inquire size of MAX_NAME_LENGTH dimension on database
        EX_INQ_DB_MAX_USED_NAME_LENGTH = 49
        # inquire client-specified max size of returned names
        EX_INQ_MAX_READ_NAME_LENGTH = 50
        # inquire size of floating-point values stored on database
        EX_INQ_DB_FLOAT_SIZE = 51
        EX_INQ_ASSEMBLY = 60
        EX_INQ_BLOB = 61
        EX_INQ_INVALID = -1</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exodus3.ex_inquiry.EX_INQ_API_VERS"><code class="name">var <span class="ident">EX_INQ_API_VERS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exodus3.ex_inquiry.EX_INQ_ASSEMBLY"><code class="name">var <span class="ident">EX_INQ_ASSEMBLY</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exodus3.ex_inquiry.EX_INQ_BLOB"><code class="name">var <span class="ident">EX_INQ_BLOB</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exodus3.ex_inquiry.EX_INQ_COORD_FRAMES"><code class="name">var <span class="ident">EX_INQ_COORD_FRAMES</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exodus3.ex_inquiry.EX_INQ_DB_FLOAT_SIZE"><code class="name">var <span class="ident">EX_INQ_DB_FLOAT_SIZE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exodus3.ex_inquiry.EX_INQ_DB_MAX_ALLOWED_NAME_LENGTH"><code class="name">var <span class="ident">EX_INQ_DB_MAX_ALLOWED_NAME_LENGTH</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exodus3.ex_inquiry.EX_INQ_DB_MAX_USED_NAME_LENGTH"><code class="name">var <span class="ident">EX_INQ_DB_MAX_USED_NAME_LENGTH</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exodus3.ex_inquiry.EX_INQ_DB_VERS"><code class="name">var <span class="ident">EX_INQ_DB_VERS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exodus3.ex_inquiry.EX_INQ_DIM"><code class="name">var <span class="ident">EX_INQ_DIM</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exodus3.ex_inquiry.EX_INQ_EB_PROP"><code class="name">var <span class="ident">EX_INQ_EB_PROP</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exodus3.ex_inquiry.EX_INQ_EDGE"><code class="name">var <span class="ident">EX_INQ_EDGE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exodus3.ex_inquiry.EX_INQ_EDGE_BLK"><code class="name">var <span class="ident">EX_INQ_EDGE_BLK</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exodus3.ex_inquiry.EX_INQ_EDGE_MAP"><code class="name">var <span class="ident">EX_INQ_EDGE_MAP</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exodus3.ex_inquiry.EX_INQ_EDGE_PROP"><code class="name">var <span class="ident">EX_INQ_EDGE_PROP</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exodus3.ex_inquiry.EX_INQ_EDGE_SETS"><code class="name">var <span class="ident">EX_INQ_EDGE_SETS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exodus3.ex_inquiry.EX_INQ_ELEM"><code class="name">var <span class="ident">EX_INQ_ELEM</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exodus3.ex_inquiry.EX_INQ_ELEM_BLK"><code class="name">var <span class="ident">EX_INQ_ELEM_BLK</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exodus3.ex_inquiry.EX_INQ_ELEM_MAP"><code class="name">var <span class="ident">EX_INQ_ELEM_MAP</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exodus3.ex_inquiry.EX_INQ_ELEM_SETS"><code class="name">var <span class="ident">EX_INQ_ELEM_SETS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exodus3.ex_inquiry.EX_INQ_ELS_DF_LEN"><code class="name">var <span class="ident">EX_INQ_ELS_DF_LEN</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exodus3.ex_inquiry.EX_INQ_ELS_LEN"><code class="name">var <span class="ident">EX_INQ_ELS_LEN</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exodus3.ex_inquiry.EX_INQ_ELS_PROP"><code class="name">var <span class="ident">EX_INQ_ELS_PROP</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exodus3.ex_inquiry.EX_INQ_EM_PROP"><code class="name">var <span class="ident">EX_INQ_EM_PROP</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exodus3.ex_inquiry.EX_INQ_ES_DF_LEN"><code class="name">var <span class="ident">EX_INQ_ES_DF_LEN</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exodus3.ex_inquiry.EX_INQ_ES_LEN"><code class="name">var <span class="ident">EX_INQ_ES_LEN</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exodus3.ex_inquiry.EX_INQ_ES_PROP"><code class="name">var <span class="ident">EX_INQ_ES_PROP</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exodus3.ex_inquiry.EX_INQ_FACE"><code class="name">var <span class="ident">EX_INQ_FACE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exodus3.ex_inquiry.EX_INQ_FACE_BLK"><code class="name">var <span class="ident">EX_INQ_FACE_BLK</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exodus3.ex_inquiry.EX_INQ_FACE_MAP"><code class="name">var <span class="ident">EX_INQ_FACE_MAP</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exodus3.ex_inquiry.EX_INQ_FACE_PROP"><code class="name">var <span class="ident">EX_INQ_FACE_PROP</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exodus3.ex_inquiry.EX_INQ_FACE_SETS"><code class="name">var <span class="ident">EX_INQ_FACE_SETS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exodus3.ex_inquiry.EX_INQ_FILE_TYPE"><code class="name">var <span class="ident">EX_INQ_FILE_TYPE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exodus3.ex_inquiry.EX_INQ_FS_DF_LEN"><code class="name">var <span class="ident">EX_INQ_FS_DF_LEN</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exodus3.ex_inquiry.EX_INQ_FS_LEN"><code class="name">var <span class="ident">EX_INQ_FS_LEN</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exodus3.ex_inquiry.EX_INQ_FS_PROP"><code class="name">var <span class="ident">EX_INQ_FS_PROP</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exodus3.ex_inquiry.EX_INQ_INFO"><code class="name">var <span class="ident">EX_INQ_INFO</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exodus3.ex_inquiry.EX_INQ_INVALID"><code class="name">var <span class="ident">EX_INQ_INVALID</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exodus3.ex_inquiry.EX_INQ_LIB_VERS"><code class="name">var <span class="ident">EX_INQ_LIB_VERS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exodus3.ex_inquiry.EX_INQ_MAX_READ_NAME_LENGTH"><code class="name">var <span class="ident">EX_INQ_MAX_READ_NAME_LENGTH</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exodus3.ex_inquiry.EX_INQ_NM_PROP"><code class="name">var <span class="ident">EX_INQ_NM_PROP</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exodus3.ex_inquiry.EX_INQ_NODES"><code class="name">var <span class="ident">EX_INQ_NODES</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exodus3.ex_inquiry.EX_INQ_NODE_MAP"><code class="name">var <span class="ident">EX_INQ_NODE_MAP</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exodus3.ex_inquiry.EX_INQ_NODE_SETS"><code class="name">var <span class="ident">EX_INQ_NODE_SETS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exodus3.ex_inquiry.EX_INQ_NS_DF_LEN"><code class="name">var <span class="ident">EX_INQ_NS_DF_LEN</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exodus3.ex_inquiry.EX_INQ_NS_NODE_LEN"><code class="name">var <span class="ident">EX_INQ_NS_NODE_LEN</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exodus3.ex_inquiry.EX_INQ_NS_PROP"><code class="name">var <span class="ident">EX_INQ_NS_PROP</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exodus3.ex_inquiry.EX_INQ_QA"><code class="name">var <span class="ident">EX_INQ_QA</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exodus3.ex_inquiry.EX_INQ_SIDE_SETS"><code class="name">var <span class="ident">EX_INQ_SIDE_SETS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exodus3.ex_inquiry.EX_INQ_SS_DF_LEN"><code class="name">var <span class="ident">EX_INQ_SS_DF_LEN</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exodus3.ex_inquiry.EX_INQ_SS_ELEM_LEN"><code class="name">var <span class="ident">EX_INQ_SS_ELEM_LEN</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exodus3.ex_inquiry.EX_INQ_SS_NODE_LEN"><code class="name">var <span class="ident">EX_INQ_SS_NODE_LEN</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exodus3.ex_inquiry.EX_INQ_SS_PROP"><code class="name">var <span class="ident">EX_INQ_SS_PROP</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exodus3.ex_inquiry.EX_INQ_TIME"><code class="name">var <span class="ident">EX_INQ_TIME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exodus3.ex_inquiry.EX_INQ_TITLE"><code class="name">var <span class="ident">EX_INQ_TITLE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="exodus3.ex_options"><code class="flex name class">
<span>class <span class="ident">ex_options</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p><code>ex_opts()</code> function codes - codes are OR'ed into exopts</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>EX_DEFAULT</code></strong></dt>
<dd>Application responsible for calling <code>ex_err()</code> to get error and warning messages to output; library is quiet</dd>
<dt><strong><code>EX_VERBOSE</code></strong></dt>
<dd>Verbose mode &ndash; output all error and warning messages</dd>
<dt><strong><code>EX_DEBUG</code></strong></dt>
<dd>Output Debug messages</dd>
<dt><strong><code>EX_ABORT</code></strong></dt>
<dd>If an error is detected, library will abort instead of letting application decide</dd>
<dt><strong><code>EX_NULLVERBOSE</code></strong></dt>
<dd>Output error and warning messages for NULL Entity errors and warnings</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ex_options(Enum):
    &#34;&#34;&#34;
    `ex_opts()` function codes - codes are OR&#39;ed into exopts

    Parameters
    ----------
    EX_DEFAULT
         Application responsible for calling `ex_err()` to get error and warning messages to output; library is quiet
    EX_VERBOSE
         Verbose mode -- output all error and warning messages
    EX_DEBUG
         Output Debug messages
    EX_ABORT
         If an error is detected, library will abort instead of letting application decide
    EX_NULLVERBOSE
         Output error and warning messages for NULL Entity errors and warnings
    &#34;&#34;&#34;
    EX_DEFAULT     = 0
    EX_VERBOSE     = 1
    EX_DEBUG       = 2
    EX_ABORT       = 4
    EX_NULLVERBOSE = 8</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exodus3.ex_options.EX_ABORT"><code class="name">var <span class="ident">EX_ABORT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exodus3.ex_options.EX_DEBUG"><code class="name">var <span class="ident">EX_DEBUG</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exodus3.ex_options.EX_DEFAULT"><code class="name">var <span class="ident">EX_DEFAULT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exodus3.ex_options.EX_NULLVERBOSE"><code class="name">var <span class="ident">EX_NULLVERBOSE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exodus3.ex_options.EX_VERBOSE"><code class="name">var <span class="ident">EX_VERBOSE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="exodus3.ex_type"><code class="flex name class">
<span>class <span class="ident">ex_type</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>An enumeration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ex_type(Enum):
    EX_INTEGER = 4 # NC_INT (from netcdf.h)
    EX_DOUBLE = 6  # NC_DOUBLE (from netcdf.h)
    EX_CHAR = 2 # NC_CHAR (from netcdf.h)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exodus3.ex_type.EX_CHAR"><code class="name">var <span class="ident">EX_CHAR</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exodus3.ex_type.EX_DOUBLE"><code class="name">var <span class="ident">EX_DOUBLE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exodus3.ex_type.EX_INTEGER"><code class="name">var <span class="ident">EX_INTEGER</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="exodus3.exodus"><code class="flex name class">
<span>class <span class="ident">exodus</span></span>
<span>(</span><span>file, mode=None, array_type='ctype', title=None, numDims=None, numNodes=None, numElems=None, numBlocks=None, numNodeSets=None, numSideSets=None, numAssembly=None, numBlob=None, init_params=None, io_size=0)</span>
</code></dt>
<dd>
<div class="desc"><p>The exodus model abstraction</p>
<p>Open exodus database for data insertion/extraction.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>file_name</code></strong> :&ensp;<code>string</code></dt>
<dd>&nbsp;</dd>
<dt>name of exodus file to open</dt>
<dt><strong><code>mode</code></strong> :&ensp;<code>string</code></dt>
<dd>&nbsp;</dd>
<dt>'r' for read, 'a' for append, 'w' for write</dt>
<dt><strong><code>title</code></strong> :&ensp;<code>string</code></dt>
<dd>&nbsp;</dd>
<dt>database title</dt>
<dt><strong><code>array_type</code></strong> :&ensp;<code>string</code></dt>
<dd>&nbsp;</dd>
<dt>'ctype' for c-type arrays, 'numpy' for numpy arrays</dt>
<dt><strong><code>num_dims</code></strong> :&ensp;<code>int</code></dt>
<dd>&nbsp;</dd>
<dt>number of model dimensions ('w' mode only)</dt>
<dt><strong><code>num_nodes</code></strong> :&ensp;<code>int</code></dt>
<dd>&nbsp;</dd>
<dt>number of model nodes ('w' mode only)</dt>
<dt><strong><code>num_elems</code></strong> :&ensp;<code>int</code></dt>
<dd>&nbsp;</dd>
<dt>number of model elements ('w' mode only)</dt>
<dt><strong><code>num_blocks</code></strong> :&ensp;<code>int</code></dt>
<dd>&nbsp;</dd>
<dt>number of model element blocks ('w' mode only)</dt>
<dt><strong><code>num_ns</code></strong> :&ensp;<code>int</code></dt>
<dd>&nbsp;</dd>
<dt>number of model node sets ('w' mode only)</dt>
<dt><strong><code>num_ss</code></strong> :&ensp;<code>int</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>number of model side sets ('w' mode only)</p>
<dl>
<dt><strong><code>init_params</code></strong> :&ensp;<code><a title="exodus3.ex_init_params" href="#exodus3.ex_init_params">ex_init_params</a></code></dt>
<dd>&nbsp;</dd>
</dl>
<p>see <code>exodus.ex_init_params</code> for more info.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>exo</code></strong> :&ensp;<code><a title="exodus3.exodus" href="#exodus3.exodus">exodus</a> object</code></dt>
<dd>the open exodus database</dd>
</dl>
<h2 id="usage">Usage</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; ex_pars = ex_init_params(num_dim=numDims, num_nodes=numNodes,
...                          num_elem=numElems, num_elem_blk=numElemBlocks, num_assembly=numAssembly)
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; exo = exodus(file_name, mode=mode, title=title,
...             array_type=array_type, init_params=ex_pars)
&gt;&gt;&gt; with exodus(file_name, mode=mode, title=title,        ...             array_type=array_type, init_params=ex_pars) as exo:
...     pass
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class exodus:
    &#34;&#34;&#34;
    The exodus model abstraction
    &#34;&#34;&#34;

    #
    # construction of a new exodus object
    #
    # --------------------------------------------------------------------

    def __init__(self, file, mode=None, array_type=&#39;ctype&#39;, title=None,
                 numDims=None, numNodes=None, numElems=None, numBlocks=None,
                 numNodeSets=None, numSideSets=None, numAssembly=None,
                 numBlob=None, init_params=None, io_size=0):
        &#34;&#34;&#34;
        Open exodus database for data insertion/extraction.

        Parameters
        ----------
        file_name : string
           name of exodus file to open
        mode : string
          &#39;r&#39; for read, &#39;a&#39; for append, &#39;w&#39; for write
        title : string
           database title
        array_type : string
           &#39;ctype&#39; for c-type arrays, &#39;numpy&#39; for numpy arrays
        num_dims : int
           number of model dimensions (&#39;w&#39; mode only)
        num_nodes : int
           number of model nodes (&#39;w&#39; mode only)
        num_elems : int
           number of model elements (&#39;w&#39; mode only)
        num_blocks : int
           number of model element blocks (&#39;w&#39; mode only)
        num_ns : int
           number of model node sets (&#39;w&#39; mode only)
        num_ss : int
           number of model side sets (&#39;w&#39; mode only)

        init_params : ex_init_params
           see `exodus.ex_init_params` for more info.

        Returns
        -------
        exo : exodus object
            the open exodus database

        Usage
        -----

        &gt;&gt;&gt; ex_pars = ex_init_params(num_dim=numDims, num_nodes=numNodes,
        ...                          num_elem=numElems, num_elem_blk=numElemBlocks, num_assembly=numAssembly)

        &gt;&gt;&gt; exo = exodus(file_name, mode=mode, title=title,
        ...             array_type=array_type, init_params=ex_pars)
        &gt;&gt;&gt; with exodus(file_name, mode=mode, title=title,\
        ...             array_type=array_type, init_params=ex_pars) as exo:
        ...     pass
        &#34;&#34;&#34;
        global SHOW_BANNER
        if SHOW_BANNER:
            print(EXODUS_PY_COPYRIGHT)
            SHOW_BANNER = False

        if mode is None:
            mode = &#39;r&#39;

        if array_type == &#39;numpy&#39;:
            # Import numpy to convert from c-type arrays to numpy arrays
            # (Numpy is imported here rather than at the module level, so that
            # the import only occurs if the user specifies a numpy array type.
            # This way, platforms without numpy installed can still import the
            # exodus.py module and just use ctype arrays.)
            import numpy as np
            self.np = np
            self.use_numpy = True
            # Warnings module is needed to suppress the invalid warning when
            # converting from c-type arrays to numpy arrays
            # http://stackoverflow.com/questions/4964101/pep-3118-warning-when-using-ctypes-array-as-numpy-array
            import warnings
            self.warnings = warnings
        else:
            self.use_numpy = False

        self.EXODUS_LIB = EXODUS_LIB
        self.fileName = str(file)
        self.basename = basename(file)
        self.modeChar = mode
        self.fileId = None
        self.__open(io_size=io_size)
        EXODUS_LIB.ex_set_max_name_length(self.fileId, MAX_NAME_LENGTH)
        if mode.lower() == &#39;w&#39;:
            if init_params is not None:
                self.init_params = init_params
                if title is not None:
                    self.init_params.title = title
                self.put_info_ext(self.init_params)
            else:
                if numNodeSets is None:
                    numNodeSets = 0
                if numSideSets is None:
                    numSideSets = 0
                if numNodes is None:
                    numNodes = 0
                if numElems is None:
                    numElems = 0
                if numBlocks is None:
                    numBlocks = 0

                info = [title, numDims, numNodes, numElems, numBlocks,
                        numNodeSets, numSideSets]
                assert None not in info
                self.__ex_put_info(info)

            self.numTimes = ctypes.c_int(0)
        else:
            self.__ex_get_info()
            self.numTimes = ctypes.c_int(
                self.__ex_inquire_int(
                    ex_inquiry_map(&#39;EX_INQ_TIME&#39;)))

        self.coordsX = None
        self.coordsY = None
        self.coordsZ = None
        self.times = None

    def __enter__(self):
        return self

    def __exit__(self, type, value, traceback):
        self.close()
        if not traceback:
            return True

    def summarize(self):
        &#34;&#34;&#34;
        Outputs a summary of the exodus file data. Output is similar to:
        ```
        Database: base_ioshell_copy.e
        Title:  This is the title

        Number of spatial dimensions = 3                                                 Number of global variables     = 10
        Number of node blocks        = 1         Number of nodes              = 1,331    Number of nodal variables      =  2
        Number of element blocks     = 1         Number of elements           = 1,000    Number of element variables    =  5
        Number of node sets          = 3         Length of node list          =   363    Number of nodeset variables    =  4
        Number of element side sets  = 3         Length of element sides      =   300    Number of sideset variables    =  3
        Number of assemblies         = 4                                                 Number of assembly variables   = 10
        Number of blobs              = 0                                                 Number of blob     variables   =  0
        Number of time steps         = 5
        ```
        &#34;&#34;&#34;

        total_sides = 0
        sidesets = self.get_ids(&#39;EX_SIDE_SET&#39;)
        for sideset in sidesets:
            total_sides += self.num_faces_in_side_set(sideset)

        total_ns_nodes = 0
        nodesets = self.get_ids(&#39;EX_NODE_SET&#39;)
        for nodeset in nodesets:
            total_ns_nodes += self.num_nodes_in_node_set(nodeset)

        num_glo_vars = self.get_variable_number(&#39;EX_GLOBAL&#39;)
        num_nod_vars = self.get_variable_number(&#39;EX_NODAL&#39;)
        num_ele_vars = self.get_variable_number(&#39;EX_ELEM_BLOCK&#39;)
        num_ns_vars = self.get_variable_number(&#39;EX_NODE_SET&#39;)
        num_ss_vars = self.get_variable_number(&#39;EX_SIDE_SET&#39;)
        num_assem_vars = self.get_reduction_variable_number(&#39;EX_ASSEMBLY&#39;)
        num_blob_vars = self.get_reduction_variable_number(&#39;EX_BLOB&#39;)

        print(&#34;\n Database: {0}\n&#34;
              &#34; Title:\t{17}\n\n&#34;
              &#34; Number of spatial dimensions = {1:3d}\t&#34;
              &#34;                                   {2:11s}\t&#34;
              &#34; Number of global variables     = {11:6d}\n&#34;
              &#34; Number of node blocks        = {5:3d}\t&#34;
              &#34; Number of nodes              = {3:10n}\t&#34;
              &#34; Number of nodal variables      = {12:6d}\n&#34;
              &#34; Number of element blocks     = {6:3n}\t&#34;
              &#34; Number of elements           = {4:10n}\t&#34;
              &#34; Number of element variables    = {13:6d}\n&#34;
              &#34; Number of node sets          = {7:3n}\t&#34;
              &#34; Length of node list          = {9:10n}\t&#34;
              &#34; Number of nodeset variables    = {14:6d}\n&#34;
              &#34; Number of element side sets  = {8:3n}\t&#34;
              &#34; Length of element sides      = {10:10n}\t&#34;
              &#34; Number of sideset variables    = {15:6d}\n&#34;
              &#34; Number of assemblies         = {18:3n}\t&#34;
              &#34;                                   {2:11s}\t&#34;
              &#34; Number of assembly red vars    = {19:6d}\n&#34;
              &#34; Number of blobs              = {20:3n}\t&#34;
              &#34;                                   {2:11s}\t&#34;
              &#34; Number of blob red vars        = {21:6d}\n&#34;
              &#34; Number of time steps         = {16:3n}\n&#34;
              .format(self.fileName,
                      self.num_dimensions(), &#34;&#34;,
                      self.num_nodes(),
                      self.num_elems(),
                      1,
                      self.num_blks(),
                      self.num_node_sets(),
                      self.num_side_sets(),
                      total_ns_nodes, total_sides,
                      num_glo_vars, num_nod_vars, num_ele_vars,
                      num_ns_vars, num_ss_vars, self.num_times(), self.title(),
                      self.num_assembly(), num_assem_vars,
                      self.num_blob(), num_blob_vars))
    #
    # build the info struct
    #
    # --------------------------------------------------------------------


    def put_info_ext(self, p):
        &#34;&#34;&#34;
        put initialization information into exodus file

        &gt;&gt;&gt; e.put_info_ext(info_struct)
        &#34;&#34;&#34;
        if len(p.title) &gt; MAX_LINE_LENGTH:
            print(&#34;WARNING: Exodus title \&#34;{}\&#34; exceeds maximum line length ({}). It will be truncated.&#34;
                  .format(p.title, MAX_LINE_LENGTH))
            p.title = p.title[-1*MAX_LINE_LENGTH:]

        self.Title = ctypes.create_string_buffer(p.title, MAX_LINE_LENGTH + 1)
        self.numDim = ctypes.c_longlong(p.num_dim)
        self.numNodes = ctypes.c_longlong(p.num_nodes)
        self.numElem = ctypes.c_longlong(p.num_elem)
        self.numElemBlk = ctypes.c_longlong(p.num_elem_blk)
        self.numNodeSets = ctypes.c_longlong(p.num_node_sets)
        self.numSideSets = ctypes.c_longlong(p.num_side_sets)
        self.numAssembly = ctypes.c_longlong(p.num_assembly)

        EXODUS_LIB.ex_put_init_ext(self.fileId, ctypes.byref(p))
        return True


    #
    # copy to a new database
    #
    # --------------------------------------------------------------------
    def copy(self, fileName, include_transient=False, mode=&#39;a&#39;):
        &#34;&#34;&#34;
        Copies exodus database to file_name and returns an opened copy as a
        new exodus object. This object will need to be closed when it is done
        being used.

        &gt;&gt;&gt; exo_copy = exo.copy(file_name)
        &gt;&gt;&gt; exo_copy.close()

        Parameters
        ----------
        file_name : str
            name of exodus file to open

        Returns
        -------
        exo_copy : exodus object opened in append mode by default
        &#34;&#34;&#34;
        i64Status = EXODUS_LIB.ex_int64_status(self.fileId)
        fileId = EXODUS_LIB.ex_create_int(fileName.encode(&#39;ascii&#39;), EX_NOCLOBBER|i64Status,
                                          ctypes.byref(self.comp_ws),
                                          ctypes.byref(self.io_ws),
                                          EX_API_VERSION_NODOT)

        self.__copy_file(fileId, include_transient)
        EXODUS_LIB.ex_close(fileId)

        return exodus(fileName, mode)


    #
    # general info
    #
    # --------------------------------------------------------------------

    def title(self):
        &#34;&#34;&#34;
        get the database title

        &gt;&gt;&gt; title = exo.title()

        Returns
        -------
        title : string
        &#34;&#34;&#34;
        return self.Title.value.decode(&#39;utf8&#39;)

    # --------------------------------------------------------------------

    def version_num(self):
        &#34;&#34;&#34;
        get exodus version number used to create the database

        &gt;&gt;&gt; version = exo.version_num()

        Returns
        -------
        version : string
            representation of version number
        &#34;&#34;&#34;
        return &#34;%1.2f&#34; % self.version.value

    # --------------------------------------------------------------------

    def put_info(self, Title, numDim, numNodes, numElem, numElemBlk,
                 numNodeSets, numSideSets):
        &#34;&#34;&#34;
        Initialize static metadata for the database.

        &gt;&gt;&gt; status = exo.put_info(title, num_dims, num_nodes, num_elems,
        ...                      num_blocks, num_ns, num_ss)

        Parameters
        ----------
        title : string
            database title
        num_dims : int
            number of model dimensions
        num_nodes : int
            number of model nodes
        num_elems : int
            number of model elements
        num_blocks : int
            number of model element blocks
        num_ns : int
            number of model node sets
        num_ss : int
            number of model side sets

        Returns
        -------
        status : bool
            True = successful execution

        &#34;&#34;&#34;
        self.__ex_put_info([Title, numDim, numNodes, numElem,
                            numElemBlk, numNodeSets, numSideSets])
        return True


    # --------------------------------------------------------------------

    def inquire(self, inquiry):
        &#34;&#34;&#34;
        Inquire about various properties of the database

        Returns
        -------
        inq_res : int
        &#34;&#34;&#34;
        return self.__ex_inquire_int(ex_inquiry_map(inquiry))

    # --------------------------------------------------------------------

    def num_qa_records(self):
        &#34;&#34;&#34;
        get the number of qa records

        &gt;&gt;&gt; num_qa_recs = exo.num_qa_records()

        Returns
        -------
        num_qa_recs : int
        &#34;&#34;&#34;
        return int(self.__ex_inquire_int(ex_inquiry_map(&#39;EX_INQ_QA&#39;)))

    # --------------------------------------------------------------------

    def get_qa_records(self):
        &#34;&#34;&#34;
        get a list of QA records where each QA record is a length-4 tuple of strings:
          1. the software name that accessed/modified the database
          2. the software descriptor, e.g. version
          3. additional software data
          4. time stamp

        &gt;&gt;&gt; qa_recs = exo.get_qa_records()


        Returns
        -------
        qa_recs : &lt;list&lt;tuple[4]&lt;string&gt;&gt;&gt;
        &#34;&#34;&#34;
        return self.__ex_get_qa()

    # --------------------------------------------------------------------

    def put_qa_records(self, records):
        &#34;&#34;&#34;
        store a list of QA records where each QA record is a length-4 tuple of strings:
          1. the software name that accessed/modified the database
          2. the software descriptor, e.g. version
          3. additional software data
          4. time stamp

        &gt;&gt;&gt; status = exo.put_qa_records()

        Parameter
        ---------
        qa_recs : &lt;list&lt;tuple[4]&lt;string&gt;&gt;&gt;

        Returns
        ------
        status : bool
            True = successful execution
        &#34;&#34;&#34;
        for rec in records:
            assert len(rec) == 4
            for recEntry in rec:
                assert len(str(recEntry).encode(&#39;ascii&#39;)) &lt; MAX_STR_LENGTH
        return self.__ex_put_qa(records)

    # --------------------------------------------------------------------

    def num_info_records(self):
        &#34;&#34;&#34;
        get the number of info records

        &gt;&gt;&gt; num_info_recs = exo.num_info_records()

        Returns
        -------
        num_info_recs : int
        &#34;&#34;&#34;
        return int(self.__ex_inquire_int(ex_inquiry_map(&#39;EX_INQ_INFO&#39;)))

    # --------------------------------------------------------------------
    def get_info_records(self):
        &#34;&#34;&#34;
        get a list info records where each entry in the list is one info
        record, e.g. a line of an input deck

        &gt;&gt;&gt; info_recs = exo.get_info_records()

        Returns
        -------
        info_recs : &lt;list&lt;string&gt;&gt;

        &#34;&#34;&#34;
        info_recs = self.__ex_get_info_recs()
        return info_recs

    # --------------------------------------------------------------------

    def put_info_records(self, info):
        &#34;&#34;&#34;
        store a list of info records where each entry in the list is
        one line of info, e.g. a line of an input deck

        &gt;&gt;&gt; status = exo.put_info_records(info)

        Parameters
        ----------
        info_recs : &lt;list&lt;tuple[4]&lt;string&gt;&gt;&gt;

        Returns
        -------
        status : bool
            True = successful execution
        &#34;&#34;&#34;
        for rec in info:
            if len(str(rec).encode(&#39;ascii&#39;)) &gt; MAX_LINE_LENGTH:
                print(&#34;WARNING: max line length reached for one or more info records;&#34;)
                print(
                    &#34;         info stored to exodus file is incomplete for these records&#34;)
                break
        return self.__ex_put_info_recs(info)

    # --------------------------------------------------------------------

    def get_sierra_input(self, inpFileName=None):
        &#34;&#34;&#34;
        parse sierra input deck from the info records if inp_file_name
        is passed the deck is written to this file; otherwise a list
        of input deck file lines is returned

        &gt;&gt;&gt; inp = exo.get_sierra_input(inpFileName=inp_file_name)

        Parameters
        ----------
        inp_file_name : string, optional
           Name of text file where info records corresponding to the Sierra input deck will be written

        Returns
        -------
        inp : list&lt;string&gt;
           lines if inp_file_name not provided; otherwise, an empty list

        &#34;&#34;&#34;
        info_recs = self.__ex_get_info_recs()
        sierra_inp = []
        begin = False
        for rec in info_recs:
            vals = rec.split()
            if not begin:  # have not reached Sierra block
                if len(vals) &gt;= 2 and vals[0].lower() == &#34;begin&#34; and vals[1].lower() == &#34;sierra&#34;:
                    begin = True
            if begin:  # inside Sierra block
                sierra_inp.append(rec)
                if len(rec) &gt; MAX_LINE_LENGTH:
                    print(
                        &#34;WARNING: max line length reached for one or more input lines;&#34;)
                    print(&#34;         input data might be incomplete for these lines&#34;)
                    break
                if len(vals) &gt;= 2 and vals[0].lower() == &#34;end&#34; and vals[1].lower() == &#34;sierra&#34;:
                    break  # end of Sierra block

        if inpFileName:
            fd = open(inpFileName.encode(&#39;ascii&#39;), &#34;w&#34;)
            for fileLine in sierra_inp:
                fd.write(fileLine+&#34;\n&#34;)
            fd.close()
            return []

        return sierra_inp

    #
    # time steps
    #
    # --------------------------------------------------------------------

    def num_times(self):
        &#34;&#34;&#34;
        get the number of time steps

        &gt;&gt;&gt; num_times = exo.num_times()

        Returns
        -------
        num_times : int
        &#34;&#34;&#34;
        return self.numTimes.value

    # --------------------------------------------------------------------

    def get_times(self):
        &#34;&#34;&#34;
        get the time values

        &gt;&gt;&gt; time_vals = exo.get_times()

        Returns
        -------
            if array_type == &#39;ctype&#39; :
              &lt;list&lt;ctypes.c_double&gt;&gt;  time_vals

            if array_type == &#39;numpy&#39; :
              &lt;np_array&lt;double&gt;&gt;  time_vals
        &#34;&#34;&#34;
        if self.numTimes.value == 0:
            self.times = []
        else:
            self.__ex_get_all_times()
        if self.use_numpy:
            self.times = ctype_to_numpy(self, self.times)
        return self.times

    # --------------------------------------------------------------------

    def put_time(self, step, value):
        &#34;&#34;&#34;
        store a new time

        &gt;&gt;&gt; exo.put_time(time_step, time_val)

        Parameters
        ----------
        time_step : int
            time step index (1-based)
        time_val : float
            time value for this step

        Returns
        -------
        status : bool
            True = successful execution
        &#34;&#34;&#34;
        self.__ex_put_time(step, value)
        self.numTimes = ctypes.c_int(self.__ex_inquire_int(ex_inquiry_map(&#39;EX_INQ_TIME&#39;)))
        return True

    #
    # coordinate system
    #
    # --------------------------------------------------------------------

    def num_dimensions(self):
        &#34;&#34;&#34;
        get the number of model spatial dimensions

        &gt;&gt;&gt; num_dims = exo.num_dimensions()

        Returns
        -------
        num_dims : &lt;int
        &#34;&#34;&#34;
        return self.numDim.value

    # --------------------------------------------------------------------

    def get_coord_names(self):
        &#34;&#34;&#34;
        get a list of length exo.num_dimensions() that has the name
        of each model coordinate direction, e.g. [&#39;x&#39;, &#39;y&#39;, &#39;z&#39;]

        &gt;&gt;&gt; coord_names = exo.get_coord_names()

        Returns
        -------
            &lt;list&lt;string&gt;&gt;  coord_names
        &#34;&#34;&#34;
        names = self.__ex_get_coord_names()
        return names

    # --------------------------------------------------------------------

    def put_coord_names(self, names):
        &#34;&#34;&#34;
        store a list of length exo.num_dimensions() that has the name
        of each model coordinate direction, e.g. [&#39;x&#39;, &#39;y&#39;, &#39;z&#39;]

        &gt;&gt;&gt; exo.put_coord_names()

        Parameters
        ----------
            &lt;list&lt;string&gt;&gt;  coord_names
        &#34;&#34;&#34;
        self.__ex_put_coord_names(names)

    #
    # nodes
    #
    # --------------------------------------------------------------------

    def num_nodes(self):
        &#34;&#34;&#34;
        get the number of nodes in the model

        &gt;&gt;&gt; num_nodes = exo.num_nodes()

        Returns
        -------
        num_nodes : int
        &#34;&#34;&#34;
        return self.numNodes.value

    # --------------------------------------------------------------------

    def get_coords(self):
        &#34;&#34;&#34;
        get model coordinates of all nodes; for each coordinate
        direction, a length exo.num_nodes() list is returned

        &gt;&gt;&gt; x_coords, y_coords, z_coords = exo.get_coords()

        Returns
        -------

            if array_type == &#39;ctype&#39;:
              &lt;list&lt;ctypes.c_double&gt;&gt;  x_coords  global x-direction coordinates
              &lt;list&lt;ctypes.c_double&gt;&gt;  y_coords  global y-direction coordinates
              &lt;list&lt;ctypes.c_double&gt;&gt;  z_coords  global z-direction coordinates

            if array_type == &#39;numpy&#39;:
              &lt;np_array&lt;double&gt;&gt;  x_coords  global x-direction coordinates
              &lt;np_array&lt;double&gt;&gt;  y_coords  global y-direction coordinates
              &lt;np_array&lt;double&gt;&gt;  z_coords  global z-direction coordinates
        &#34;&#34;&#34;
        self.__ex_get_coord()
        if self.use_numpy:
            self.coordsX = ctype_to_numpy(self, self.coordsX)
            self.coordsY = ctype_to_numpy(self, self.coordsY)
            self.coordsZ = ctype_to_numpy(self, self.coordsZ)
        return self.coordsX, self.coordsY, self.coordsZ

    # --------------------------------------------------------------------

    def get_coord(self, i):
        &#34;&#34;&#34;
        get model coordinates of a single node

        &gt;&gt;&gt; x_coord, y_coord, z_coord = exo.get_coord(node_index)

        Parameters
        ----------
        node_index : int
            the 1-based node index (indexing is from 1 to exo.num_nodes())

        Returns
        -------
        x_coord : double
            global x-direction coordinate
        y_coord : double
            global y-direction coordinate
        z_coord : double
            global z-direction coordinate

        Note:
        -----
        &gt;&gt;&gt; x_coords, y_coords, z_coords = exo.get_coords()
        &gt;&gt;&gt; x_coord = x_coords[node_index-1]
        &gt;&gt;&gt; y_coord = y_coords[node_index-1]
        &gt;&gt;&gt; z_coord = z_coords[node_index-1]
            ... is equivalent to ...
        &gt;&gt;&gt; x_coord, y_coord, z_coord = exo.get_coords(node_index)

        &#34;&#34;&#34;
        listX, listY, listZ = self.__ex_get_partial_coord(i, 1)
        return listX[0], listY[0], listZ[0]

    # --------------------------------------------------------------------

    def put_coords(self, xCoords, yCoords, zCoords):
        &#34;&#34;&#34;
        store model coordinates of all nodes; for each coordinate
        direction, a length exo.num_nodes() list is input

        &gt;&gt;&gt; status = exo.put_coords(x_coords, y_coords, z_coords)

        Parameters
        ----------
        x_coord : &lt;list&lt;float&gt;&gt;
            global x-direction coordinates
        y_coord : &lt;list&lt;float&gt;&gt;
            global y-direction coordinates
        z_coord : &lt;list&lt;float&gt;&gt;
            global z-direction coordinates

        Returns
        -------
        status : bool
            True = successful execution
        &#34;&#34;&#34;
        self.__ex_put_coord(xCoords, yCoords, zCoords)
        return True

    # --------------------------------------------------------------------

    def get_node_num_map(self):
        &#34;&#34;&#34;
        **DEPRECATED** use: `get_node_id_map()`

        get mapping of exodus node index to user- or application-
        defined node id; node_id_map is ordered the same as the nodal
        coordinate arrays returned by exo.get_coords() -- this ordering
        follows the exodus node *INDEX* order, a 1-based system going
        from 1 to exo.num_nodes(); a user or application can optionally
        use a separate node *ID* numbering system, so the node_id_map
        points to the node *ID* for each node *INDEX*

        &gt;&gt;&gt; node_id_map = exo.get_node_num_map()

        Returns
        -------
            &lt;list&lt;ctypes.c_int&gt;&gt;  node_id_map
        &#34;&#34;&#34;
        nodeNumMap = self.__ex_get_node_num_map()
        return nodeNumMap

    # --------------------------------------------------------------------

    def put_node_id_map(self, id_map):
        &#34;&#34;&#34;
        store mapping of exodus node index to user- or application-
        defined node id; node_id_map is ordered the same as the nodal
        coordinate arrays returned by exo.get_coords() -- this ordering
        follows the exodus node *INDEX* order, a 1-based system going
        from 1 to exo.num_nodes(); a user or application can optionally
        use a separate node *ID* numbering system, so the node_id_map
        points to the node *ID* for each node *INDEX*

        &gt;&gt;&gt; status = exo.put_node_id_map(node_id_map)

        Parameters
        ----------
            &lt;list&lt;int&gt;&gt;  node_id_map

        Returns
        -------
        status : bool
            True = successful execution
        &#34;&#34;&#34;
        return self.__ex_put_id_map(&#39;EX_NODE_MAP&#39;, id_map)

    # --------------------------------------------------------------------

    def get_node_variable_names(self):
        &#34;&#34;&#34;
        get the list of nodal variable names in the model

        &gt;&gt;&gt; nvar_names = exo.get_node_variable_names()

        Returns
        -------
              &lt;list&lt;string&gt;&gt;  nvar_names
        &#34;&#34;&#34;
        if self.__ex_get_variable_param(&#39;EX_NODAL&#39;).value == 0:
            return []
        return self.__ex_get_variable_names(&#39;EX_NODAL&#39;)

    # --------------------------------------------------------------------

    def get_node_variable_number(self):
        &#34;&#34;&#34;
        get the number of nodal variables in the model

        &gt;&gt;&gt; num_nvars = exo.get_node_variable_number()

        Returns
        -------
        num_nvars : int
        &#34;&#34;&#34;
        return self.__ex_get_variable_param(&#39;EX_NODAL&#39;).value

    # --------------------------------------------------------------------

    def set_node_variable_number(self, number):
        &#34;&#34;&#34;
        update the number of nodal variables in the model

        &gt;&gt;&gt; status = exo.set_node_variable_number(num_nvars)

        Parameters
        ----------
        num_nvars : int

        Returns
        -------
        status : bool
            True = successful execution
        &#34;&#34;&#34;
        self.__ex_put_variable_param(&#39;EX_NODAL&#39;, number)
        return True

    # --------------------------------------------------------------------

    def put_node_variable_name(self, name, index):
        &#34;&#34;&#34;
        add the name and index of a new nodal variable to the model;
        nodal variable indexing goes from 1 to exo.get_node_variable_number()

        &gt;&gt;&gt; status = exo.put_node_variable_name(nvar_name, nvar_index)

        Parameters
        ----------
            &lt;string&gt;  nvar_name   name of new nodal variable
            &lt;int&gt;     nvar_index  1-based index of new nodal variable

        Returns
        -------
        status : bool
            True = successful execution

        Note:
        ----
        this method is often called within the following sequence:

        &gt;&gt;&gt; num_nvars = exo.get_node_variable_number()
        &gt;&gt;&gt; new_nvar_index = num_nvars + 1
        &gt;&gt;&gt; num_nvars += 1
        &gt;&gt;&gt; exo.set_node_variable_number(num_nvars)
        &gt;&gt;&gt; exo.put_node_variable_name(&#34;new_nvar_name&#34;, new_nvar_index)
        &#34;&#34;&#34;
        NDvarNames = self.get_variable_names(&#39;EX_NODAL&#39;)
        if name in NDvarNames:
            print(&#34;WARNING: node variable \&#34;{}\&#34; already exists.&#34;.format(name))
        if index &gt; len(NDvarNames):
            raise Exception(&#34;ERROR: variable index out of range.&#34;)
        self.__ex_put_variable_name(&#39;EX_NODAL&#39;, index, name)
        return True

    # --------------------------------------------------------------------

    def get_node_variable_values(self, name, step):
        &#34;&#34;&#34;
        get list of nodal variable values for a nodal variable name
        and time step

        &gt;&gt;&gt; nvar_vals = exo.get_node_variable_values(nvar_name, time_step)

        Parameters
        ----------
            &lt;string&gt;  nvar_name  name of nodal variable
            &lt;int&gt;     time_step  1-based index of time step

        Returns
        -------

            if array_type == &#39;ctype&#39;:
              &lt;list&lt;ctypes.c_double&gt;&gt;  nvar_vals

            if array_type == &#39;numpy&#39;:
              &lt;np_array&lt;double&gt;&gt;  nvar_vals
        &#34;&#34;&#34;
        names = self.get_variable_names(&#39;EX_NODAL&#39;)
        var_id = names.index(name) + 1
        numVals = self.num_nodes()
        values = self.__ex_get_var(step, &#39;EX_NODAL&#39;, var_id, 0, numVals)
        if self.use_numpy:
            values = ctype_to_numpy(self, values)
        return values

    # --------------------------------------------------------------------

    def get_partial_node_variable_values(self, name, step, start_index, num_nodes):
        &#34;&#34;&#34;
        get partial list of nodal variable values for a nodal variable name
        and time step.  Start at node `node_index` (1-based) and return `num_nodes`
        from that point.

        &gt;&gt;&gt; nvar_vals = exo.get_partial_node_variable_values(nvar_name, time_step, 10, 100)

        Parameters
        ----------
            &lt;string&gt;  nvar_name   name of nodal variable
            &lt;int&gt;     time_step   1-based index of time step
            &lt;int&gt;     start_index 1-based index of node to start returning data
            &lt;int&gt;     num_nodes   number of nodes to return data for.

        Returns
        -------

            if array_type == &#39;ctype&#39;:
              &lt;list&lt;ctypes.c_double&gt;&gt;  nvar_vals

            if array_type == &#39;numpy&#39;:
              &lt;np_array&lt;double&gt;&gt;  nvar_vals
        &#34;&#34;&#34;
        names = self.get_variable_names(&#39;EX_NODAL&#39;)
        var_id = names.index(name) + 1
        values = self.__ex_get_partial_var(step, &#39;EX_NODAL&#39;, var_id, 0, start_index, num_nodes)
        if self.use_numpy:
            values = ctype_to_numpy(self, values)
        return values

    # --------------------------------------------------------------------

    def put_node_variable_values(self, name, step, values):
        &#34;&#34;&#34;
        store a list of nodal variable values for a nodal variable
        name and time step

        &gt;&gt;&gt; status = exo.put_node_variable_values(nvar_name, time_step, nvar_vals)

        Parameters
        ----------
            &lt;string&gt;       nvar_name  name of nodal variable
            &lt;int&gt;          time_step  1-based index of time step
            &lt;list&lt;float&gt;&gt;  nvar_vals

        Returns
        -------
        status : bool
            True = successful execution
        &#34;&#34;&#34;
        names = self.get_variable_names(&#39;EX_NODAL&#39;)
        var_id = names.index(name) + 1
        numVals = self.num_nodes()
        self.__ex_put_var(step, &#39;EX_NODAL&#39;, var_id, 0, numVals, values)
        return True

    #
    # elements
    #
    # --------------------------------------------------------------------

    def num_elems(self):
        &#34;&#34;&#34;
        get the number of elements in the model

        &gt;&gt;&gt; num_elems = exo.num_elems()

        Returns
        -------
        num_elems : int
        &#34;&#34;&#34;
        return self.numElem.value

    # --------------------------------------------------------------------

    def get_elem_id_map(self):
        &#34;&#34;&#34;
        get mapping of exodus element index to user- or application-
        defined element id; elem_id_map is ordered by the element
        *INDEX* ordering, a 1-based system going from 1 to
        exo.num_elems(), used by exodus for storage and input/output
        of array data stored on the elements; a user or application
        can optionally use a separate element *ID* numbering system,
        so the elem_id_map points to the element *ID* for each
        element *INDEX*

        &gt;&gt;&gt; elem_id_map = exo.get_elem_id_map()

        Returns
        -------

            if array_type == &#39;ctype&#39;:
              &lt;list&lt;int&gt;&gt;  elem_id_map

            if array_type == &#39;numpy&#39;:
              &lt;np_array&lt;int&gt;&gt;  elem_id_map
        &#34;&#34;&#34;
        return self.__ex_get_id_map(&#39;EX_ELEM_MAP&#39;)

    # --------------------------------------------------------------------

    def put_elem_id_map(self, id_map):
        &#34;&#34;&#34;
        store mapping of exodus element index to user- or application-
        defined element id; elem_id_map is ordered by the element
        *INDEX* ordering, a 1-based system going from 1 to
        exo.num_elems(), used by exodus for storage and input/output
        of array data stored on the elements; a user or application
        can optionally use a separate element *ID* numbering system,
        so the elem_id_map points to the element *ID* for each
        element *INDEX*

        &gt;&gt;&gt; status = exo.put_elem_id_map(elem_id_map)

        Parameters
        ----------
            &lt;list&lt;int&gt;&gt;  elem_id_map

        Returns
        -------
        status : bool
            True = successful execution
        &#34;&#34;&#34;
        return self.__ex_put_id_map(&#39;EX_ELEM_MAP&#39;, id_map)

    # --------------------------------------------------------------------

    def get_block_id_map(self, obj_type, entity_id):
        &#34;&#34;&#34;
        Gets the map of elements found in the given entity_id of an object
        of obj_type.

        *INDEX* ordering, a 1-based system going from 1 to
        number of elements in the elem_block, used by exodus for
        storage and input/output of array data stored on the elements;
        a user or application can optionally use a separate element *ID* numbering system,
        so the elem_id_map points to the element *ID* for each
        element *INDEX*

        &gt;&gt;&gt; elem_block_id_map = exo.get_block_id_map(&#34;EX_ELEM_BLOCK&#34;, 100)

        Returns
        -------

            if array_type == &#39;ctype&#39;:
              &lt;list&lt;int&gt;&gt;  elem_id_map

            if array_type == &#39;numpy&#39;:
              &lt;np_array&lt;int&gt;&gt;  elem_id_map
        &#34;&#34;&#34;
        return self.__ex_get_block_id_map(obj_type, entity_id)

    # --------------------------------------------------------------------

    def get_elem_num_map(self):
        &#34;&#34;&#34;
        **DEPRECATED** use: `get_elem_id_map()`

        get mapping of exodus element index to user- or application-
        defined element id; elem_id_map is ordered by the element
        *INDEX* ordering, a 1-based system going from 1 to
        exo.num_elems(), used by exodus for storage and input/output
        of array data stored on the elements; a user or application
        can optionally use a separate element *ID* numbering system,
        so the elem_id_map points to the element *ID* for each
        element *INDEX*

        &gt;&gt;&gt; elem_id_map = exo.get_elem_num_map()

        Returns
        -------
            &lt;list&lt;ctypes.c_int&gt;&gt;  elem_id_map
        &#34;&#34;&#34;
        elemNumMap = self.__ex_get_elem_num_map()
        return elemNumMap

    # --------------------------------------------------------------------

    def get_elem_order_map(self):
        &#34;&#34;&#34;
        get mapping of exodus element index to application-defined
        optimal ordering; elem_order_map is ordered by the element
        index ordering used by exodus for storage and input/output
        of array data stored on the elements; a user or application
        can optionally use a separate element ordering, e.g. for
        optimal solver performance, so the elem_order_map points to
        the index used by the application for each exodus element
        index

        &gt;&gt;&gt; elem_order_map = exo.get_elem_order_map()

        Returns
        -------

            if array_type == &#39;ctype&#39;:
              &lt;list&lt;int&gt;&gt;  elem_order_map

            if array_type == &#39;numpy&#39;:
              &lt;np_array&lt;int&gt;&gt;  elem_order_map
        &#34;&#34;&#34;

        elemOrderMap = self.__ex_get_elem_order_map()
        if self.use_numpy:
            elemOrderMap = ctype_to_numpy(self, elemOrderMap)
        return elemOrderMap

    # Generic (objType) get/put/query...
    # --------------------------------------------------------------------

    def put_id_map(self, objType, id_map):
        &#34;&#34;&#34;
        store mapping of exodus node index to user- or application-
        defined node id; node_id_map is ordered the same as the nodal
        coordinate arrays returned by exo.get_coords() -- this ordering
        follows the exodus node *INDEX* order, a 1-based system going
        from 1 to exo.num_nodes(); a user or application can optionally
        use a separate node *ID* numbering system, so the node_id_map
        points to the node *ID* for each node *INDEX*

        &gt;&gt;&gt; status = exo.put_node_id_map(node_id_map)

        Parameters
        ----------
            &lt;list&lt;int&gt;&gt;  node_id_map

        Returns
        -------
        status : bool
            True = successful execution
        &#34;&#34;&#34;
        return self.__ex_put_id_map(objType, id_map)

    # --------------------------------------------------------------------

    def get_id_map(self, objType):
        &#34;&#34;&#34;
        get mapping of exodus node index to user- or application-
        defined node id; node_id_map is ordered the same as the nodal
        coordinate arrays returned by exo.get_coords() -- this ordering
        follows the exodus node *INDEX* order, a 1-based system going
        from 1 to exo.num_nodes(); a user or application can optionally
        use a separate node *ID* numbering system, so the node_id_map
        points to the node *ID* for each node *INDEX*

        &gt;&gt;&gt; node_id_map = exo.get_node_id_map()

        Returns
        -------

            if array_type == &#39;ctype&#39;:
              &lt;list&lt;int&gt;&gt;  node_id_map

            if array_type == &#39;numpy&#39;:
              &lt;np_array&lt;int&gt;&gt;  node_id_map
        &#34;&#34;&#34;
        return self.__ex_get_id_map(objType)

    # --------------------------------------------------------------------

    def get_node_id_map(self):
        &#34;&#34;&#34;
        get mapping of exodus node index to user- or application-
        defined node id; node_id_map is ordered the same as the nodal
        coordinate arrays returned by exo.get_coords() -- this ordering
        follows the exodus node *INDEX* order, a 1-based system going
        from 1 to exo.num_nodes(); a user or application can optionally
        use a separate node *ID* numbering system, so the node_id_map
        points to the node *ID* for each node *INDEX*

        &gt;&gt;&gt; node_id_map = exo.get_node_id_map()

        Returns
        -------

            if array_type == &#39;ctype&#39;:
              &lt;list&lt;int&gt;&gt;  node_id_map

            if array_type == &#39;numpy&#39;:
              &lt;np_array&lt;int&gt;&gt;  node_id_map
        &#34;&#34;&#34;
        return self.__ex_get_id_map(&#39;EX_NODE_MAP&#39;)

    # --------------------------------------------------------------------

    def get_name(self, object_type, object_id):
        &#34;&#34;&#34;
        get the name of the specified entity_type and entity

        &gt;&gt;&gt; elem_blk_name = exo.get_name(&#39;EX_ELEM_BLOCK&#39;, elem_blk_id)

        Parameters
        ----------
        object_type : int
            block/set type
        object_id : int
            block/set *ID* (not *INDEX*)

        Returns
        -------
        name : string
        &#34;&#34;&#34;
        name = self.__ex_get_name(object_type, object_id)
        return name

    # --------------------------------------------------------------------

    def put_name(self, object_type, object_id, name):
        &#34;&#34;&#34;
        put the name of the specified entity_type and entity

        &gt;&gt;&gt; exo.put_name(&#39;EX_ELEM_BLOCK&#39;, elem_blk_id, block_name)

        Parameters
        ----------
        object_type : int
            block/set type
        object_id : int
            block/set *ID* (not *INDEX*)
        name : string
            block/set name

        Returns
        -------
        elem_blk_name : string
        &#34;&#34;&#34;
        self.__ex_put_name(object_type, object_id, name)

    # --------------------------------------------------------------------

    def get_names(self, object_type):
        &#34;&#34;&#34;
        get a list of all block/set names ordered by block/set *INDEX*;
        (see `exodus.get_ids` for explanation of the
        difference between *ID* and *INDEX*)

        &gt;&gt;&gt; blk_names = exo.get_names(&#39;EX_ELEM_BLOCK&#39;)

        Parameters
        ----------
        object_type : int
            block/set type

        Returns
        -------
            &lt;list&lt;string&gt;&gt;  names
        &#34;&#34;&#34;
        names = self.__ex_get_names(object_type)
        return names

    # --------------------------------------------------------------------

    def put_names(self, object_type, names):
        &#34;&#34;&#34;
        store a list of all block/set names of the specified
        `object_type` ordered by *INDEX*;
        (see `exodus.get_ids` for explanation of the
        difference between *ID* and *INDEX*)

        &gt;&gt;&gt; exo.put_names(&#39;EX_ELEM_BLOCK&#39;, elem_blk_names)

        Parameters
        ----------
        object_type : int
        names : &lt;list&lt;string&gt;&gt;
        &#34;&#34;&#34;

        self.__ex_put_names(object_type, names)

    # --------------------------------------------------------------------

    def get_reduction_variable_values(self, objType, id, step):
        &#34;&#34;&#34;
        get list of reduction variable values for a specified entity type and
        id, and time step

        &gt;&gt;&gt; evar_vals = exo.get_reduction_variable_values(&#39;EX_ELEM_BLOCK&#39;, elem_blk_id, time_step)

        Parameters
        ----------
        objType   : ex_entity_type
            type of object being queried
        id        : int
            entity *ID* (not *INDEX*)
        time_step : int
            1-based index of time step

        Returns
        -------

            if array_type == &#39;ctype&#39;:
              &lt;list&lt;ctypes.c_double&gt;&gt;  evar_vals

            if array_type == &#39;numpy&#39;:
              &lt;np_array&lt;double&gt;&gt;  evar_vals

        &#34;&#34;&#34;
        numVals = self.get_reduction_variable_number(objType)
        values = self.__ex_get_reduction_vars(step, objType, id, numVals)
        if self.use_numpy:
            values = ctype_to_numpy(self, values)
        return values

    # --------------------------------------------------------------------

    def put_reduction_variable_values(self, objType, id, step, values):
        &#34;&#34;&#34;
        store a list of &#39;objType&#39; variable values for a specified entity,
        and time step

        &gt;&gt;&gt; status = exo.put_redcution_variable_values(&#39;EX_ELEM_BLOCK&#39;, elem_blk_id,
        ...             time_step, evar_vals)

        Parameters
        ----------
        objType : ex_entity_type
            type of object begin queried
        id : int
            element block *ID* (not *INDEX*)
            &lt;int&gt;          time_step    1-based index of time step
            &lt;list&lt;float&gt;&gt;  evar_vals

        Returns
        -------
        status : bool
            True = successful execution
        &#34;&#34;&#34;
        numVals = self.get_reduction_variable_number(objType)
        self.__ex_put_reduction_vars(step, objType, id, numVals, values)
        return True

    # --------------------------------------------------------------------

    def get_ids(self, objType):
        &#34;&#34;&#34;
        get mapping of exodus block/set index to user- or application-
        defined block/set id; ids is ordered
        by the *INDEX* ordering, a 1-based system going from
        1 to number_set_or_block, used by exodus for storage
        and input/output of array data stored on the blocks/sets; a
        user or application can optionally use a separate block/set
        *ID* numbering system, so the ids array points to the
        block/set *ID* for each set *INDEX*

        &gt;&gt;&gt; node_set_ids = exo.get_ids(&#39;EX_NODE_SET&#39;)

        Returns
        -------

            if array_type == &#39;ctype&#39;:
              &lt;list&lt;int&gt;&gt;  ids

            if array_type == &#39;numpy&#39;:
              &lt;np_array&lt;int&gt;&gt;  ids
        &#34;&#34;&#34;
        ids = self.__ex_get_ids(objType)
        if self.use_numpy:
            ids = self.np.array(ids)
        return ids

    # --------------------------------------------------------------------
    def get_variable_truth_table(self, objType, entId=None):
        &#34;&#34;&#34;
        gets a truth table indicating which variables are defined for
        specified entity type; if entId is not passed, then a concatenated
        truth table for all entities is returned with variable index
        cycling faster than entity index

        &gt;&gt;&gt; ssvar_truth_tab = exo.get_variable_truth_table(&#39;EX_SIDE_SET&#39;, sideSetID=side_set_id)

        Parameters
        ----------
        entId : int, optional
            entity *ID* (not *INDEX*)

        Returns
        -------
        truth_tab : &lt;list&lt;bool&gt;&gt;
            True for variable defined in an entity, False otherwise
        &#34;&#34;&#34;
        if entId is None:
            truthTable = self.__ex_get_truth_table(objType)
        else:
            truthTable = self.__ex_get_object_truth_vector(objType, entId)
        return truthTable

    # --------------------------------------------------------------------

    def set_variable_truth_table(self, objType, table):
        &#34;&#34;&#34;
        stores a truth table indicating which variables are defined for
        all sets/blocks of the specified `objType` and all variables; variable index cycles
        faster than entity index

        &gt;&gt;&gt; status = exo.set_variable_truth_table(&#39;EX_NODE_SET&#39;, nsvar_truth_tab)

        Parameters
        ----------
        table : &lt;list&lt;bool&gt;&gt;
            True for variable defined in a node set, False otherwise

        Returns
        -------
        status : bool
            True = successful execution
        &#34;&#34;&#34;
        return self.__ex_put_truth_table(objType, table)

    # --------------------------------------------------------------------

    def get_variable_names(self, objType):
        &#34;&#34;&#34;
        get the list of variable names in the model for the specified object type.

        &gt;&gt;&gt; nar_names = exo.get_variable_names(&#39;EX_NODAL&#39;)

        Returns
        -------
              &lt;list&lt;string&gt;&gt;  nvar_names
        &#34;&#34;&#34;
        if self.__ex_get_variable_param(objType).value == 0:
            return []
        return self.__ex_get_variable_names(objType)

    # --------------------------------------------------------------------

    def get_reduction_variable_names(self, objType):
        &#34;&#34;&#34;
        get the list of reduction variable names in the model for the specified object type.

        &gt;&gt;&gt; nar_names = exo.get_reduction_variable_names(&#39;EX_ASSEMBL&#34;Y&#39;)

        Returns
        -------
              &lt;list&lt;string&gt;&gt;  nvar_names
        &#34;&#34;&#34;
        if self.__ex_get_reduction_variable_param(objType).value == 0:
            return []
        return self.__ex_get_reduction_variable_names(objType)

    # --------------------------------------------------------------------

    def get_reduction_variable_name(self, objType, varId):
        &#34;&#34;&#34;
        get a single reduction variable name in the model for the specified object type and index.

        &gt;&gt;&gt; nar_name = exo.get_reduction_variable_name(&#39;EX_ASSEMBL&#34;Y&#39;, 100)

        Returns
        -------
              string  nvar_name
        &#34;&#34;&#34;
        if self.__ex_get_reduction_variable_param(objType).value == 0:
            return &#34;&#34;
        return self.__ex_get_reduction_variable_name(objType, varId)

    # --------------------------------------------------------------------

    def get_variable_number(self, objType):
        &#34;&#34;&#34;
        get the number of variables of the specified type in the model

        &gt;&gt;&gt; num_nvars = exo.get_variable_number(&#39;EX_NODAL&#39;)

        Returns
        -------
        num_nvars :               &lt;int&gt;
        &#34;&#34;&#34;
        return self.__ex_get_variable_param(objType).value

    # --------------------------------------------------------------------

    def get_reduction_variable_number(self, objType):
        &#34;&#34;&#34;
        get the number of reduction variables of the specified type in the model

        &gt;&gt;&gt; num_nvars = exo.get_reduction_variable_number(&#39;EX_ASSEMBLY&#39;)

        Returns
        -------
        num_nvars :               &lt;int&gt;
        &#34;&#34;&#34;
        return self.__ex_get_reduction_variable_param(objType).value

    # --------------------------------------------------------------------

    def set_variable_number(self, objType, number):
        &#34;&#34;&#34;
        update the number of variables in the model

        &gt;&gt;&gt; status = exo.set_variable_number(&#39;EX_NODAL&#39;, num_nvars)

        Parameters
        ----------
        num_nvars :               &lt;int&gt;

        Returns
        -------
        status : bool
            True = successful execution
        &#34;&#34;&#34;
        self.__ex_put_variable_param(objType, number)
        return True

    # --------------------------------------------------------------------

    def set_reduction_variable_number(self, objType, number):
        &#34;&#34;&#34;
        update the number of reduction variables in the model

        &gt;&gt;&gt; status = exo.set_reduction_variable_number(&#39;EX_ASSEMBLY&#39;, num_nvars)

        Parameters
        ----------
        num_nvars :               &lt;int&gt;

        Returns
        -------
        status : bool
            True = successful execution
        &#34;&#34;&#34;
        self.__ex_put_reduction_variable_param(objType, number)
        return True

    # --------------------------------------------------------------------

    def put_variable_name(self, objType, name, index):
        &#34;&#34;&#34;
        add the name and index of a new variable to the model;
        variable indexing goes from 1 to exo.get_variable_number()

        &gt;&gt;&gt; status = exo.put_variable_name(&#39;EX_NODAL&#39;, nvar_name, nvar_index)

        Parameters
        ----------
        objType : string
            object type
        var_name : string
            name of new variable
        nvar_index : int
            1-based index of new nodal variable

        Returns
        -------
        status : bool
            True = successful execution

        Note:
        ----
        this method is often called within the following sequence:

        &gt;&gt;&gt; num_nvars = exo.get_variable_number(&#39;EX_NODAL&#39;)
        &gt;&gt;&gt; new_nvar_index = num_nvars + 1
        &gt;&gt;&gt; num_nvars += 1
        &gt;&gt;&gt; exo.set_variable_number(&#39;EX_NODAL&#39;, num_nvars)
        &gt;&gt;&gt; exo.put_variable_name(&#39;EX_NODAL&#39;, &#34;new_nvar_name&#34;, new_nvar_index)
        &#34;&#34;&#34;
        varNames = self.get_variable_names(objType)
        if name in varNames:
            print(&#34;WARNING: variable \&#34;{}\&#34; already exists.&#34;.format(name))
        if index &gt; len(varNames):
            raise Exception(&#34;ERROR: variable index out of range.&#34;)
        self.__ex_put_variable_name(objType, index, name)
        return True

    # --------------------------------------------------------------------

    def put_reduction_variable_name(self, objType, name, index):
        &#34;&#34;&#34;
        add the name and index of a new reduction variable to the model;
        variable indexing goes from 1 to exo.get_reductino_variable_number()

        &gt;&gt;&gt; status = exo.put_reduction_variable_name(&#39;EX_ASSEMBLY&#39;, assemvar_name, assemvar_index)

        Parameters
        ----------
        objType : string
            object type
        var_name : string
            name of new variable
        nvar_index : int
            1-based index of new nodal variable

        Returns
        -------
        status : bool
            True = successful execution

        Note:
        ----
        this method is often called within the following sequence:

        &gt;&gt;&gt; num_assem_vars = exo.get_reduction_variable_number(&#39;EX_ASSEMBLY&#39;)
        &gt;&gt;&gt; new_assem_var_index = num_assem_vars + 1
        &gt;&gt;&gt; num_assem_vars += 1
        &gt;&gt;&gt; exo.set_reduction_variable_number(&#39;EX_ASSEMBLY&#39;, num_assem_vars)
        &gt;&gt;&gt; exo.put_reduction_variable_name(&#39;EX_ASSEMBLY&#39;, &#34;new_assem_var_name&#34;, new_assem_var_index)
        &#34;&#34;&#34;
        varNames = self.get_reduction_variable_names(objType)
        if name in varNames:
            print(&#34;WARNING: variable \&#34;{}\&#34; already exists.&#34;.format(name))
        if index &gt; len(varNames):
            raise Exception(&#34;ERROR: variable index out of range.&#34;)
        self.__ex_put_reduction_variable_name(objType, index, name)
        return True

    # --------------------------------------------------------------------
    def get_variable_values(self, objType, entityId, name, step):
        &#34;&#34;&#34;
        get list of `objType` variable values for a specified object id
        block, variable name, and time step

        &gt;&gt;&gt; evar_vals = exo.get_variable_values(&#39;EX_ELEM_BLOCK&#39;, elem_blk_id,
        ...                                            evar_name, time_step)

        Parameters
        ----------
        objType   : ex_entity_type
            type of object being queried
        entityId : int
            id of the entity (block, set) *ID* (not *INDEX*)
        name : string
            name of variable
        time_step : int
            1-based index of time step

        Returns
        -------

            if array_type == &#39;ctype&#39;:
              &lt;list&lt;ctypes.c_double&gt;&gt;  evar_vals

            if array_type == &#39;numpy&#39;:
              &lt;np_array&lt;double&gt;&gt;  evar_vals
        &#34;&#34;&#34;
        names = self.get_variable_names(objType)
        var_id = names.index(name) + 1
        numVals = 0
        if objType == &#39;EX_NODAL&#39;:
            numVals = self.num_nodes()
        elif objType == &#39;EX_ELEM_BLOCK&#39;:
            numVals = self.num_elems_in_blk(entityId)
        elif objType == &#39;EX_NODE_SET&#39;:
            (numVals, _numDistFactInSet) = self.__ex_get_set_param(objType, entityId)
        elif objType == &#39;EX_EDGE_SET&#39;:
            (numVals, _numDistFactInSet) = self.__ex_get_set_param(objType, entityId)
        elif objType == &#39;EX_FACE_SET&#39;:
            (numVals, _numDistFactInSet) = self.__ex_get_set_param(objType, entityId)
        elif objType == &#39;EX_SIDE_SET&#39;:
            (numVals, _numDistFactInSet) = self.__ex_get_set_param(objType, entityId)

        values = self.__ex_get_var(step, objType, var_id, entityId, numVals)
        if self.use_numpy:
            values = ctype_to_numpy(self, values)
        return values


    # --------------------------------------------------------------------
    def put_variable_values(self, objType, entityId, name, step, values):
        &#34;&#34;&#34;
        store a list of element variable values for a specified element
        block, element variable name, and time step

        &gt;&gt;&gt; status = exo.put_variable_values(&#39;EX_ELEM_BLOCK&#39;, elem_blk_id,
        ...             evar_name, time_step, evar_vals)

        Parameters
        ----------
        entityId : int  entity *ID* (not *INDEX*)
            &lt;string&gt;    name    name of variable
            &lt;int&gt;          time_step    1-based index of time step
            &lt;list&lt;float&gt;&gt;  values the variable values to be output

        Returns
        -------
        status : bool
            True = successful execution
        &#34;&#34;&#34;
        names = self.get_variable_names(objType)
        var_id = names.index(name) + 1
        numVals = 0
        if objType == &#39;EX_NODAL&#39;:
            numVals = self.num_nodes()
        elif objType == &#39;EX_ELEM_BLOCK&#39;:
            numVals = self.num_elems_in_blk(entityId)
        elif objType == &#39;EX_NODE_SET&#39;:
            (numVals, _numDistFactInSet) = self.__ex_get_set_param(objType, entityId)
        elif objType == &#39;EX_EDGE_SET&#39;:
            (numVals, _numDistFactInSet) = self.__ex_get_set_param(objType, entityId)
        elif objType == &#39;EX_FACE_SET&#39;:
            (numVals, _numDistFactInSet) = self.__ex_get_set_param(objType, entityId)
        elif objType == &#39;EX_SIDE_SET&#39;:
            (numVals, _numDistFactInSet) = self.__ex_get_set_param(objType, entityId)

        self.__ex_put_var(step, objType, var_id, entityId, numVals, values)
        return True

    # Attributes (meta-data attributes; not the per-element bulk-data kind)
    # --------------------------------------------------------------------
    def get_attribute_count(self, objType, objId):
        &#34;&#34;&#34;
        IS THIS NEEDED, PYTHONIC WAY MAY BE TO JUST GET THEM...

        get the number of attributes on the specified entity

        &gt;&gt;&gt; num_attribute = exo.get_attribute_count(&#39;EX_ASSEMBLY&#39;, 100)

        Parameters
        ----------
        objType   : ex_entity_type
            type of object being queried
        id        : int
            entity *ID* (not *INDEX*)

        Returns
        -------
            &lt;int&gt;  num_attribute
        &#34;&#34;&#34;
        return self.__ex_get_attribute_count(objType, objId)

    def get_attributes(self, objType, objId):
        &#34;&#34;&#34;
        &gt;&gt;&gt; attributes = exo.get_attributes(&#39;EX_ASSEMBLY&#39;, 100)

        Returns
        -------
            &lt;ex_attribute list&gt; attributes
        &#34;&#34;&#34;

        return self.__ex_get_attributes(objType, objId)


    def put_attribute(self, attribute):
        &#34;&#34;&#34;
        &gt;&gt;&gt; attribute = exodus.attribute(&#39;Scale&#39;, &#39;EX_ASSEMBLY&#39;, 100)
        &gt;&gt;&gt; attribute.values = [1.1, 1.0, 1.2]
        &gt;&gt;&gt; attributes = exo.put_attribute(attribute)

        Returns
        -------
            &lt;ex_attribute list&gt; attributes
        &#34;&#34;&#34;

        return self.__ex_put_attribute(attribute)


    # Assemblies...
    # --------------------------------------------------------------------
    def num_assembly(self):
        &#34;&#34;&#34;
        get the number of assemblies in the model

        &gt;&gt;&gt; num_assembly = exo.num_assembly()

        Returns
        -------
            &lt;int&gt;  num_assembly
        &#34;&#34;&#34;
        return self.inquire(&#39;EX_INQ_ASSEMBLY&#39;)


    def get_assembly(self, object_id):
        &#34;&#34;&#34;
        reads the assembly parameters and assembly data for one assembly
        &#34;&#34;&#34;
        assem = ex_assembly(id=object_id)
        self.__ex_get_assembly(assem)
        assmbly = assembly(assem.name.decode(&#39;utf8&#39;), assem.id, assem.type)
        for j in range(assem.entity_count):
            assmbly.entity_list.append(assem.entity_list[j])
        return assmbly

    def get_assemblies(self, object_ids):
        &#34;&#34;&#34;
        reads the assembly parameters and assembly data for all assemblies
        with ids in object_ids
        &#34;&#34;&#34;
        assemblies = [ex_assembly(id=object_id) for object_id in object_ids]
        assems = (ex_assembly * len(assemblies))(*assemblies)
        self.__ex_get_assemblies(assems)
        assembs = [assembly(assem.name.decode(&#39;utf8&#39;), assem.id, assem.type) for assem in
                   assems]
        for i, a in enumerate(assems):
            for j in range(a.entity_count):
                assembs[i].entity_list.append(a.entity_list[j])
        return assembs

    def put_assembly(self, assembly):
        &#34;&#34;&#34;
        writes the assembly parameters and assembly data for one assembly
        &#34;&#34;&#34;
        self.__ex_put_assembly(assembly)

    def put_assemblies(self, assemblies):
        &#34;&#34;&#34;
        writes the assembly parameters and assembly data for multiple assemblies
        &#34;&#34;&#34;
        self.__ex_put_assemblies(assemblies)


    # Blobs...
    # --------------------------------------------------------------------
    def num_blob(self):
        &#34;&#34;&#34;
        get the number of blobs in the model

        &gt;&gt;&gt; num_assembly = exo.num_blob()

        Returns
        -------
            &lt;int&gt;  num_blob
        &#34;&#34;&#34;
        return self.numBlob.value


    def get_blob(self, object_id):
        &#34;&#34;&#34;
        reads the blob parameters and blob data for one blob
        &#34;&#34;&#34;
        assem = ex_blob(id=object_id)
        self.__ex_get_blob(assem)
        return assem


    # element blocks
    # --------------------------------------------------------------------

    def num_blks(self):
        &#34;&#34;&#34;
        get the number of element blocks in the model

        &gt;&gt;&gt; num_elem_blks = exo.num_blks()

        Returns
        -------
        num_elem_blks : int
        &#34;&#34;&#34;
        return self.numElemBlk.value

    # --------------------------------------------------------------------

    def get_elem_blk_ids(self):
        &#34;&#34;&#34;
        get mapping of exodus element block index to user- or
        application-defined element block id; elem_blk_ids is ordered
        by the element block *INDEX* ordering, a 1-based system going
        from 1 to exo.num_blks(), used by exodus for storage
        and input/output of array data stored on the element blocks; a
        user or application can optionally use a separate element block
        *ID* numbering system, so the elem_blk_ids array points to the
        element block *ID* for each element block *INDEX*

        &gt;&gt;&gt; elem_blk_ids = exo.get_elem_blk_ids()

        Returns
        -------

            if array_type == &#39;ctype&#39;:
              &lt;list&lt;int&gt;&gt;  elem_blk_ids

            if array_type == &#39;numpy&#39;:
              &lt;np_array&lt;int&gt;&gt;  elem_blk_ids
        &#34;&#34;&#34;
        return self.get_ids(&#39;EX_ELEM_BLOCK&#39;)

    # --------------------------------------------------------------------

    def get_elem_blk_name(self, object_id):
        &#34;&#34;&#34;
        get the element block name

        &gt;&gt;&gt; elem_blk_name = exo.get_elem_blk_name(elem_blk_id)

        Parameters
        ----------
        elem_blk_id : int
            element block *ID* (not *INDEX*)

        Returns
        -------
        elem_blk_name : string
        &#34;&#34;&#34;
        return self.__ex_get_name(&#39;EX_ELEM_BLOCK&#39;, object_id)

    # --------------------------------------------------------------------

    def put_elem_blk_name(self, object_id, name):
        &#34;&#34;&#34;
        store the element block name

        &gt;&gt;&gt; exo.put_elem_blk_name(elem_blk_id, elem_blk_name)

        Parameters
        ----------
        elem_blk_id : int
            element block *ID* (not *INDEX*)
        elem_blk_name : string
        &#34;&#34;&#34;
        self.__ex_put_name(&#39;EX_ELEM_BLOCK&#39;, object_id, name)

    # --------------------------------------------------------------------

    def get_elem_blk_names(self):
        &#34;&#34;&#34;
        get a list of all element block names ordered by block *INDEX*;
        (see `exodus.get_ids` for explanation of the
        difference between block *ID* and block *INDEX*)

        &gt;&gt;&gt; elem_blk_names = exo.get_elem_blk_names()

        Returns
        -------
        elem_blk_names : &lt;list&lt;string&gt;&gt;
        &#34;&#34;&#34;
        elemBlkNames = self.__ex_get_names(&#39;EX_ELEM_BLOCK&#39;)
        return elemBlkNames

    # --------------------------------------------------------------------

    def put_elem_blk_names(self, names):
        &#34;&#34;&#34;
        store a list of all element block names ordered by block *INDEX*;
        (see `exodus.get_ids` for explanation of the
        difference between block *ID* and block *INDEX*)

        &gt;&gt;&gt; exo.put_elem_blk_names(elem_blk_names)

        Parameters
        ----------
        elem_blk_names : &lt;list&lt;string&gt;&gt;
        &#34;&#34;&#34;
        self.__ex_put_names(&#39;EX_ELEM_BLOCK&#39;, names)

    # --------------------------------------------------------------------

    def elem_blk_info(self, object_id):
        &#34;&#34;&#34;
        get the element block info

        &gt;&gt;&gt; elem_type, num_blk_elems, num_elem_nodes, num_elem_attrs
        ...       = exo.elem_blk_info(elem_blk_id)

        Parameters
        ----------
        elem_blk_id : int
            element block *ID* (not *INDEX*)

        Returns
        -------
            &lt;string&gt;  elem_type       element type, e.g. &#39;HEX8&#39;
            &lt;int&gt;     num_blk_elems   number of elements in the block
            &lt;int&gt;     num_elem_nodes  number of nodes per element
            &lt;int&gt;     num_elem_attrs  number of attributes per element
        &#34;&#34;&#34;
        (elemType, numElem, nodesPerElem, numAttr) = self.__ex_get_block(&#39;EX_ELEM_BLOCK&#39;, object_id)
        return elemType.value, numElem.value, nodesPerElem.value, numAttr.value

    # --------------------------------------------------------------------

    def put_elem_blk_info(self, elem_blk_id, elem_type, num_blk_elems,
                          num_elem_nodes, num_elem_attrs):
        &#34;&#34;&#34;
        store the element block *ID* and element block info

        &gt;&gt;&gt; exo.put_elem_blk_info(elem_blk_id, elem_type, num_blk_elems,
        ...                      num_elem_nodes, num_elem_attrs)

        Parameters
        ----------
        elem_blk_id : int
            element block *ID* (not *INDEX*)
        elem_type : string
            element type (all caps), e.g. &#39;HEX8&#39;
        num_blk_elems : int
            number of elements in the block
        num_elem_nodes : int
            number of nodes per element
        num_elem_attrs : int
            number of attributes per element
        &#34;&#34;&#34;
        self.__ex_put_block(&#39;EX_ELEM_BLOCK&#39;, elem_blk_id, elem_type, num_blk_elems,
                            num_elem_nodes, num_elem_attrs)

    # --------------------------------------------------------------------

    def put_concat_elem_blk(self, elem_blk_ids, elem_type, num_blk_elems,
                            num_elem_nodes, num_elem_attrs, defineMaps):
        &#34;&#34;&#34;
        same as exo.put_elem_blk_info() but for all blocks at once

        &gt;&gt;&gt; status = exo.put_concat_elem_blk(elem_blk_ids, elem_types,
        ...                                 num_blk_elems, num_elem_nodes, num_elem_attrs)

        Parameters
        ----------
            &lt;list&lt;int&gt;&gt;     elem_blk_ids     element block *ID* (not *INDEX*)
              for each block
            &lt;list&lt;string&gt;&gt;  elem_types       element type for each block
            &lt;list&lt;int&gt;&gt;     num_blk_elems    number of elements for each
              block
            &lt;list&lt;int&gt;&gt;     num_elem_nodes   number of nodes per element
              for each block
            &lt;list&lt;int&gt;&gt;     num_elem_attrs   number of attributes per
              element for each block

        Returns
        -------
        status : bool
            True = successful execution
        &#34;&#34;&#34;
        self.__ex_put_concat_elem_blk(
            elem_blk_ids,
            elem_type,
            num_blk_elems,
            num_elem_nodes,
            num_elem_attrs,
            defineMaps)
        return True

    # --------------------------------------------------------------------

    def get_elem_connectivity(self, object_id):
        &#34;&#34;&#34;
        get the nodal connectivity, number of elements, and
        number of nodes per element for a single block

        &gt;&gt;&gt; elem_conn, num_blk_elems, num_elem_nodes
        ...        = exo.get_elem_connectivity(elem_blk_id)

        Parameters
        ----------
        elem_blk_id : int
            element block *ID* (not *INDEX*)

        Returns
        -------

            if array_type == &#39;ctype&#39;:
              &lt;list&lt;int&gt;&gt;  elem_conn  ordered list of node *INDICES* that
                define the connectivity of each element
                in the block; the list cycles through
                all nodes of the first element, then
                all nodes of the second element, etc.
                (see `exodus.get_id_map` for explanation
                of node *INDEX* versus node *ID*)

            if array_type == &#39;numpy&#39;:
              &lt;np_array&lt;int&gt;&gt;  elem_conn  (same description)

            &lt;int&gt;  num_blk_elems    number of elements in the block
            &lt;int&gt;  num_elem_nodes   number of nodes per element
        &#34;&#34;&#34;
        (elem_block_connectivity, num_elem_this_blk,
         num_nodes_per_elem) = self.__ex_get_elem_conn(object_id)
        if self.use_numpy:
            elem_block_connectivity = ctype_to_numpy(
                self, elem_block_connectivity)
        return elem_block_connectivity, num_elem_this_blk.value, num_nodes_per_elem.value

    # --------------------------------------------------------------------

    def put_elem_connectivity(self, object_id, connectivity):
        &#34;&#34;&#34;
        store the nodal connectivity, number of elements, and
        number of nodes per element for a single block

        &gt;&gt;&gt; exo.put_elem_connectivity(elem_blk_id, elem_conn)

        Parameters
        ----------
        elem_blk_id : int
            element block *ID* (not *INDEX*)
            &lt;list&lt;int&gt;&gt;  elem_conn    ordered list of node *INDICES* that
              define the connectivity of each
              element in the block; the list cycles
              through all nodes of the first element,
              then all nodes of the second element,
              etc.
              (see `exodus.get_id_map` for explanation
              of node *INDEX* versus node *ID*)
        &#34;&#34;&#34;
        _d1, numBlkElems, numNodesPerElem, _d2 = self.elem_blk_info(object_id)
        assert len(connectivity) == (numBlkElems * numNodesPerElem)
        self.__ex_put_elem_conn(object_id, connectivity)

    # --------------------------------------------------------------------

    def get_elem_attr(self, elem_blk_id):
        &#34;&#34;&#34;
        get all attributes for each element in a block

        &gt;&gt;&gt; elem_attrs = exo.get_elem_attr(elem_blk_id)

        Parameters
        ----------
        elem_blk_id : int
            element block *ID* (not *INDEX*)

        Returns
        -------
            if array_type == &#39;ctype&#39; : &lt;list&lt;float&gt;&gt; elem_attrs
            if array_type == &#39;numpy&#39; : &lt;np_array&lt;float&gt;&gt; elem_attrs
                list of attribute values for all
                elements in the block; the list cycles
                through all attributes of the first
                element, then all attributes of the
                second element, etc. Attributes are
                ordered by the ordering of the names
                returned by exo.get_element_attribute_names()
        &#34;&#34;&#34;
        elem_attrs = self.__ex_get_elem_attr(elem_blk_id)
        if self.use_numpy:
            elem_attrs = ctype_to_numpy(self, elem_attrs)
        return elem_attrs

    # --------------------------------------------------------------------

    def get_elem_attr_values(self, elem_blk_id, elem_attr_name):
        &#34;&#34;&#34;
        get an attribute for each element in a block

        &gt;&gt;&gt; elem_attrs = exo.get_elem_attr(elem_blk_id)

        Parameters
        ----------
            &lt;int&gt;    elem_blk_id     element block *ID* (not *INDEX*)
            &lt;string&gt; elem_attr_name  element attribute name

        Returns
        -------
            if array_type == &#39;ctype&#39;: &lt;list&lt;float&gt;&gt;  values
            if array_type == &#39;numpy&#39;: &lt;np_array&lt;float&gt;&gt;  values
                array of values for the requested
                attribute.  Array has dimensions of
                1 x num_elem, where num_elem is the
                number of elements on the element block.
        &#34;&#34;&#34;
        # Determine index of requested attribute in attribute list
        elem_attr_names = self.get_element_attribute_names(elem_blk_id)
        a_ndx = elem_attr_names.index(elem_attr_name)

        values = self.__ex_get_one_attr(&#39;EX_ELEM_BLOCK&#39;, elem_blk_id, a_ndx)
        if self.use_numpy:
            values = ctype_to_numpy(self, values)
        return values

    # --------------------------------------------------------------------

    def put_elem_attr(self, elem_blk_id, elem_attrs):
        &#34;&#34;&#34;
        store all attributes for each element in a block

        &gt;&gt;&gt; exo.put_elem_attr(elem_blk_id, elem_attrs)

        Parameters
        ----------
        elem_blk_id : int
            element block *ID* (not *INDEX*)
            &lt;list&lt;float&gt;&gt;  elem_attrs     list of all attribute values for all
              elements in the block; the list
              cycles through all attributes of
              the first element, then all attributes
              of the second element, etc. Attributes
              are ordered by the ordering of the
              names returned by
              exo.get_element_attribute_names()
        &#34;&#34;&#34;
        self.__ex_put_elem_attr(elem_blk_id, elem_attrs)

    # --------------------------------------------------------------------

    def put_elem_attr_values(self, elem_blk_id, elem_attr_name, values):
        &#34;&#34;&#34;
        store an attribute for each element in a block

        &gt;&gt;&gt; exo.put_elem_attr_values(elem_blk_id, elem_attr_name, values)

        Parameters
        ----------
        elem_blk_id : int
            element block *ID* (not *INDEX*)
            &lt;string&gt;       elem_attr_name element attribute name
            &lt;list&lt;float&gt;&gt;  values         list of values for a single attribute
                                          on a element block.  List dimensions
                                          should be 1 x N_elem, where N_elem is
                                          the number of elements on the element
                                          block.
        &#34;&#34;&#34;
        # Determine index of requested attribute in attribute list
        elem_attr_names = self.get_element_attribute_names(elem_blk_id)
        a_ndx = elem_attr_names.index(elem_attr_name)
        self.__ex_put_one_attr(&#39;EX_ELEM_BLOCK&#39;, elem_blk_id, a_ndx, values)

    # --------------------------------------------------------------------

    def elem_type(self, object_id):
        &#34;&#34;&#34;
        get the element type, e.g. &#34;HEX8&#34;, for an element block

        &gt;&gt;&gt; elem_type = exo.elem_type(elem_blk_id)

        Parameters
        ----------
        elem_blk_id : int
            element block *ID* (not *INDEX*)

        Returns
        -------
            &lt;string&gt;  elem_type
        &#34;&#34;&#34;
        (elemType, _numElem, _nodesPerElem, _numAttr) = self.__ex_get_block(&#39;EX_ELEM_BLOCK&#39;, object_id)
        return elemType.value

    # --------------------------------------------------------------------

    def num_attr(self, object_id):
        &#34;&#34;&#34;
        get the number of attributes per element for an element block

        &gt;&gt;&gt; num_elem_attrs = exo.num_attr(elem_blk_id)

        Parameters
        ----------
        elem_blk_id : int
            element block *ID* (not *INDEX*)

        Returns
        -------
            &lt;int&gt;  num_elem_attrs
        &#34;&#34;&#34;
        (_elemType, _numElem, _nodesPerElem, numAttr) = self.__ex_get_block(&#39;EX_ELEM_BLOCK&#39;, object_id)
        return numAttr.value

    # --------------------------------------------------------------------

    def num_elems_in_blk(self, object_id):
        &#34;&#34;&#34;
        get the number of elements in an element block

        &gt;&gt;&gt; num_blk_elems = exo.num_elems_in_blk(elem_blk_id)

        Parameters
        ----------
        elem_blk_id : int
            element block *ID* (not *INDEX*)

        Returns
        -------
            &lt;int&gt;  num_blk_elems
        &#34;&#34;&#34;
        (_elemType, numElem, _nodesPerElem, _numAttr) = self.__ex_get_block(&#39;EX_ELEM_BLOCK&#39;, object_id)
        return numElem.value

    # --------------------------------------------------------------------

    def num_nodes_per_elem(self, object_id):
        &#34;&#34;&#34;
        get the number of nodes per element for an element block

        &gt;&gt;&gt; num_elem_nodes = exo.num_nodes_per_elem(elem_blk_id)

        Parameters
        ----------
        elem_blk_id : int
            element block *ID* (not *INDEX*)

        Returns
        -------
            &lt;int&gt;  num_elem_nodes
        &#34;&#34;&#34;
        (_elemType, _numElem, nodesPerElem, _numAttr) = self.__ex_get_block(&#39;EX_ELEM_BLOCK&#39;, object_id)
        return nodesPerElem.value

    # --------------------------------------------------------------------

    def get_element_variable_truth_table(self, entId=None):
        &#34;&#34;&#34;
        See `exodus.get_variable_truth_table`
        &#34;&#34;&#34;
        return self.get_variable_truth_table(&#39;EX_ELEM_BLOCK&#39;, entId)

    # --------------------------------------------------------------------

    def set_element_variable_truth_table(self, table):
        &#34;&#34;&#34;
        See `exodus.set_variable_truth_table`
        &#34;&#34;&#34;
        return self.set_variable_truth_table(&#39;EX_ELEM_BLOCK&#39;, table)

    # --------------------------------------------------------------------

    def get_element_variable_values(self, blockId, name, step):
        &#34;&#34;&#34;
        get list of element variable values for a specified element
        block, element variable name, and time step

        &gt;&gt;&gt; evar_vals = exo.get_element_variable_values(elem_blk_id,
        ...                                            evar_name, time_step)

        Parameters
        ----------
        elem_blk_id : int
            element block *ID* (not *INDEX*)
        evar_name : string
            name of element variable
        time_step : int
            1-based index of time step

        Returns
        -------

            if array_type == &#39;ctype&#39;:
              &lt;list&lt;ctypes.c_double&gt;&gt;  evar_vals

            if array_type == &#39;numpy&#39;:
              &lt;np_array&lt;double&gt;&gt;  evar_vals
        &#34;&#34;&#34;
        values = self.get_variable_values(&#39;EX_ELEM_BLOCK&#39;, blockId, name, step)
        return values

    # --------------------------------------------------------------------

    def get_partial_element_variable_values(self, blockId, name, step, start_index, num_elements):
        &#34;&#34;&#34;
        get list of element variable values for a specified element
        block, element variable name, and time step

        &gt;&gt;&gt; evar_vals = exo.get_element_variable_values(elem_blk_id,
        ...                                            evar_name, time_step)

        Parameters
        ----------
        elem_blk_id : int
            element block *ID* (not *INDEX*)
        evar_name : string
            name of element variable
        time_step : int
            1-based index of time step
        start_index: int
            1-based index of element in block to start returning data
        num_elements: int
            number of elements to return data for.

        Returns
        -------

            if array_type == &#39;ctype&#39;:
              &lt;list&lt;ctypes.c_double&gt;&gt;  evar_vals

            if array_type == &#39;numpy&#39;:
              &lt;np_array&lt;double&gt;&gt;  evar_vals
        &#34;&#34;&#34;
        names = self.get_variable_names(&#39;EX_ELEM_BLOCK&#39;)
        var_id = names.index(name) + 1
        values = self.__ex_get_partial_var(step, &#39;EX_ELEM_BLOCK&#39;, var_id, blockId, start_index, num_elements)
        if self.use_numpy:
            values = ctype_to_numpy(self, values)
        return values

    # --------------------------------------------------------------------

    def put_element_variable_values(self, blockId, name, step, values):
        &#34;&#34;&#34;
        store a list of element variable values for a specified element
        block, element variable name, and time step

        &gt;&gt;&gt; status = exo.put_element_variable_values(elem_blk_id,
        ...             evar_name, time_step, evar_vals)

        Parameters
        ----------
        elem_blk_id : int
            element block *ID* (not *INDEX*)
            &lt;string&gt;       evar_name    name of element variable
            &lt;int&gt;          time_step    1-based index of time step
            &lt;list&lt;float&gt;&gt;  evar_vals

        Returns
        -------
        status : bool
            True = successful execution
        &#34;&#34;&#34;
        self.put_variable_values(&#39;EX_ELEM_BLOCK&#39;, blockId, name, step, values)
        return True

    # --------------------------------------------------------------------

    def get_element_variable_number(self):
        &#34;&#34;&#34;
        get the number of element variables in the model

        &gt;&gt;&gt; num_evars = exo.get_element_variable_number()

        Returns
        -------
              &lt;int&gt;  num_evars
        &#34;&#34;&#34;
        return self.__ex_get_variable_param(&#39;EX_ELEM_BLOCK&#39;).value

    # --------------------------------------------------------------------

    def set_element_variable_number(self, number):
        &#34;&#34;&#34;
        update the number of element variables in the model

        &gt;&gt;&gt; status = exo.set_element_variable_number(num_evars)

        Parameters
        ----------
              &lt;int&gt;  num_evars

        Returns
        -------
        status : bool
            True = successful execution
        &#34;&#34;&#34;
        self.__ex_put_variable_param(&#39;EX_ELEM_BLOCK&#39;, number)
        return True

    # --------------------------------------------------------------------

    def get_element_variable_names(self):
        &#34;&#34;&#34;
        get the list of element variable names in the model

        &gt;&gt;&gt; evar_names = exo.get_element_variable_names()

        Returns
        -------
              &lt;list&lt;string&gt;&gt;  evar_names
        &#34;&#34;&#34;
        if self.__ex_get_variable_param(&#39;EX_ELEM_BLOCK&#39;).value == 0:
            return []
        return self.__ex_get_variable_names(&#39;EX_ELEM_BLOCK&#39;)

    # --------------------------------------------------------------------

    def put_element_variable_name(self, name, index):
        &#34;&#34;&#34;
        add the name and index of a new element variable to the model;
        element variable indexing goes from 1 to
        exo.get_element_variable_number()

        &gt;&gt;&gt; status = exo.put_element_variable_name(evar_name, evar_index)

        Parameters
        ----------
            &lt;string&gt;  evar_name   name of new element variable
            &lt;int&gt;     evar_index  1-based index of new element variable

        Returns
        -------
        status : bool
            True = successful execution

        Note:
        ----
        this method is often called within the following sequence:

        &gt;&gt;&gt; num_evars = exo.get_element_variable_number()
        &gt;&gt;&gt; new_evar_index = num_evars + 1
        &gt;&gt;&gt; num_evars += 1
        &gt;&gt;&gt; exo.set_element_variable_number(num_evars)
        &gt;&gt;&gt; exo.put_element_variable_name(&#34;new_evar&#34;, new_evar_index)
        &#34;&#34;&#34;
        EBvarNames = self.get_variable_names(&#39;EX_ELEM_BLOCK&#39;)
        if name in EBvarNames:
            print(&#34;WARNING: element variable \&#34;{}\&#34; already exists.&#34;.format(name))
        if index &gt; len(EBvarNames):
            print((&#34;index&#34;, index, &#34;len&#34;, len(EBvarNames)))
            raise Exception(&#34;ERROR: variable index out of range.&#34;)
        self.__ex_put_variable_name(&#39;EX_ELEM_BLOCK&#39;, index, name)
        return True

    # --------------------------------------------------------------------

    def get_element_attribute_names(self, blkId):
        &#34;&#34;&#34;
        get the list of element attribute names for a block

        &gt;&gt;&gt; attr_names = exo.get_element_attribute_names(elem_blk_id)

        Parameters
        ----------
        elem_blk_id : int
            element block *ID* (not *INDEX*)

        Returns
        -------
            &lt;list&lt;string&gt;&gt;  attr_names
        &#34;&#34;&#34;
        names = self.__ex_get_elem_attr_names(blkId)
        return list(names)

    # --------------------------------------------------------------------

    def put_element_attribute_names(self, blkId, names):
        &#34;&#34;&#34;
        store the list of element attribute names for a block

        &gt;&gt;&gt; status = exo.put_element_attribute_names(elem_blk_id, attr_names)

        Parameters
        ----------
        elem_blk_id : int
            element block *ID* (not *INDEX*)
            &lt;list&lt;string&gt;&gt;  attr_names

        Returns
        -------
        status : bool
            True = successful execution
        &#34;&#34;&#34;
        return self.__ex_put_elem_attr_names(blkId, names)

    # --------------------------------------------------------------------

    def get_element_property_names(self):
        &#34;&#34;&#34;
        get the list of element property names for all element blocks
        in the model

        &gt;&gt;&gt; eprop_names = exo.get_element_property_names()

        Returns
        -------
            &lt;list&lt;string&gt;&gt;  eprop_names
        &#34;&#34;&#34;
        names = self.__ex_get_prop_names(&#39;EX_ELEM_BLOCK&#39;, &#39;EX_INQ_EB_PROP&#39;)
        return list(names)

    # --------------------------------------------------------------------

    def get_element_property_value(self, object_id, name):
        &#34;&#34;&#34;
        get element property value (an integer) for a specified element
        block and element property name

        &gt;&gt;&gt; eprop_val = exo.get_element_property_value(elem_blk_id, eprop_name)

        Parameters
        ----------
        elem_blk_id : int
            element block *ID* (not *INDEX*)
            &lt;string&gt;  eprop_name

        Returns
        -------
            &lt;int&gt;  eprop_val
        &#34;&#34;&#34;
        propVal = self.__ex_get_prop(&#39;EX_ELEM_BLOCK&#39;, object_id, name)
        return int(propVal)

    # --------------------------------------------------------------------

    def put_element_property_value(self, object_id, name, value):
        &#34;&#34;&#34;
        store an element property name and its integer value for an
        element block

        &gt;&gt;&gt; status = exo.put_element_property_value(elem_blk_id,
        ...                                         eprop_name, eprop_val)


        Parameters
        ----------
        elem_blk_id : int
            element block *ID* (not *INDEX*)
            &lt;string&gt;  eprop_name
            &lt;int&gt;     eprop_val

        Returns
        -------
        status : bool
            True = successful execution
        &#34;&#34;&#34;
        return self.__ex_put_prop(&#39;EX_ELEM_BLOCK&#39;, object_id, name, value)

    # --------------------------------------------------------------------

    #
    # nodesets
    #
    # --------------------------------------------------------------------

    def num_node_sets(self):
        &#34;&#34;&#34;
        get the number of node sets in the model

        &gt;&gt;&gt; num_node_sets = exo.num_node_sets()

        Returns
        -------
            &lt;int&gt;  num_node_sets
        &#34;&#34;&#34;
        return self.numNodeSets.value

    # --------------------------------------------------------------------

    def get_node_set_ids(self):
        &#34;&#34;&#34;
        get mapping of exodus node set index to user- or application-
        defined node set id; node_set_ids is ordered
        by the *INDEX* ordering, a 1-based system going from
        1 to exo.num_node_sets(), used by exodus for storage
        and input/output of array data stored on the node sets; a
        user or application can optionally use a separate node set
        *ID* numbering system, so the node_set_ids array points to the
        node set *ID* for each node set *INDEX*

        &gt;&gt;&gt; node_set_ids = exo.get_ids(&#39;EX_NODE_SET&#39;)

        Returns
        -------

            if array_type == &#39;ctype&#39;:
              &lt;list&lt;int&gt;&gt;  node_set_ids

            if array_type == &#39;numpy&#39;:
              &lt;np_array&lt;int&gt;&gt;  node_set_ids
        &#34;&#34;&#34;
        return self.get_ids(&#39;EX_NODE_SET&#39;)

    # --------------------------------------------------------------------

    def get_node_set_name(self, object_id):
        &#34;&#34;&#34;
        get the name of a node set

        &gt;&gt;&gt; node_set_name = exo.get_node_set_name(node_set_id)

        Parameters
        ----------
            &lt;int&gt;  node_set_id  node set *ID* (not *INDEX*)

        Returns
        -------
            &lt;string&gt;  node_set_name
        &#34;&#34;&#34;
        return self.__ex_get_name(&#39;EX_NODE_SET&#39;, object_id)

    # --------------------------------------------------------------------

    def put_node_set_name(self, object_id, name):
        &#34;&#34;&#34;
        store the name of a node set

        &gt;&gt;&gt; exo.put_node_set_name(node_set_id, node_set_name)

        Parameters
        ----------
            &lt;int&gt;     node_set_id    node set *ID* (not *INDEX*)
            &lt;string&gt;  node_set_name
        &#34;&#34;&#34;
        self.__ex_put_name(&#39;EX_NODE_SET&#39;, object_id, name)

    # --------------------------------------------------------------------

    def get_node_set_names(self):
        &#34;&#34;&#34;
        get a list of all node set names ordered by node set *INDEX*;
        (see `exodus.get_ids` for explanation of the
        difference between node set *ID* and node set *INDEX*)

        &gt;&gt;&gt; node_set_names = exo.get_node_set_names()

        Returns
        -------
            &lt;list&lt;string&gt;&gt;  node_set_names
        &#34;&#34;&#34;
        nodeSetNames = self.__ex_get_names(&#39;EX_NODE_SET&#39;)
        return nodeSetNames

    # --------------------------------------------------------------------

    def put_node_set_names(self, names):
        &#34;&#34;&#34;
        store a list of all node set names ordered by node set *INDEX*;
        (see `exodus.get_ids` for explanation of the
        difference between node set *ID* and node set *INDEX*)

        &gt;&gt;&gt; exo.put_node_set_names(node_set_names)

        Parameters
        ----------
            &lt;list&lt;string&gt;&gt;  node_set_names
        &#34;&#34;&#34;
        self.__ex_put_names(&#39;EX_NODE_SET&#39;, names)

    # --------------------------------------------------------------------

    def num_nodes_in_node_set(self, object_id):
        &#34;&#34;&#34;
        get the number of nodes in a node set

        &gt;&gt;&gt; num_ns_nodes = exo.num_nodes_in_node_set(node_set_id)

        Parameters
        ----------
            &lt;int&gt;  node_set_id  node set *ID* (not *INDEX*)

        Returns
        -------
            &lt;int&gt;  num_ns_nodes
        &#34;&#34;&#34;
        node_set_nodes = self.get_node_set_nodes(object_id)
        return len(node_set_nodes)

    # --------------------------------------------------------------------

    def get_node_set_nodes(self, object_id):
        &#34;&#34;&#34;
        get the list of node *INDICES* in a node set
        (see `exodus.get_id_map` for explanation of node *INDEX*
        versus node *ID*)

        &gt;&gt;&gt; ns_nodes = exo.get_node_set_nodes(node_set_id)

        Parameters
        ----------
            &lt;int&gt;  node_set_id  node set *ID* (not *INDEX*)

        Returns
        -------

            if array_type == &#39;ctype&#39;:
              &lt;list&lt;int&gt;&gt;  ns_nodes

            if array_type == &#39;numpy&#39;:
              &lt;np_array&lt;int&gt;&gt;  ns_nodes
        &#34;&#34;&#34;
        node_set_ids = self.get_ids(&#39;EX_NODE_SET&#39;)
        assert object_id in node_set_ids
        node_set_nodes = self.__ex_get_node_set(object_id)
        node_set_nodes = list(node_set_nodes)
        if self.use_numpy:
            node_set_nodes = self.np.array(node_set_nodes)
        return node_set_nodes

    # --------------------------------------------------------------------

    def put_node_set(self, object_id, nodeSetNodes):
        &#34;&#34;&#34;
        store a node set by its id and the list of node *INDICES* in
        the node set (see `exodus.get_id_map` for explanation of node
        *INDEX* versus node *ID*)

        &gt;&gt;&gt; exo.put_node_set(node_set_id, ns_nodes)

        Parameters
        ----------
            &lt;int&gt;        node_set_id  node set *ID* (not *INDEX*)
            &lt;list&lt;int&gt;&gt;  ns_nodes
        &#34;&#34;&#34;
        self.__ex_put_node_set(object_id, nodeSetNodes)

    # --------------------------------------------------------------------

    def get_node_set_dist_facts(self, object_id):
        &#34;&#34;&#34;
        get the list of distribution factors for nodes in a node set

        &gt;&gt;&gt; ns_dist_facts = exo.get_node_set_dist_facts(node_set_id)

        Parameters
        ----------
            &lt;int&gt;        node_set_id  node set *ID* (not *INDEX*)

        Returns
        -------

            if array_type == &#39;ctype&#39;:
              &lt;list&lt;float&gt;&gt;  ns_dist_facts  a list of distribution factors,
                e.g. nodal &#39;weights&#39;

            if array_type == &#39;numpy&#39;:
              &lt;np_array&lt;double&gt;&gt;  ns_dist_facts  a list of distribution
                factors, e.g. nodal
                &#39;weights&#39;
        &#34;&#34;&#34;
        node_set_dfs = self.__ex_get_node_set_dist_fact(object_id)
        node_set_dfs = list(node_set_dfs)
        if self.use_numpy:
            node_set_dfs = self.np.array(node_set_dfs)
        return node_set_dfs

    # --------------------------------------------------------------------

    def put_node_set_dist_fact(self, object_id, nodeSetDistFact):
        &#34;&#34;&#34;
        store the list of distribution factors for nodes in a node set

        &gt;&gt;&gt; exo.put_node_set_dist_fact(node_set_id, ns_dist_facts)

        Parameters
        ----------
            &lt;int&gt;          node_set_id    node set *ID* (not *INDEX*)
            &lt;list&lt;float&gt;&gt;  ns_dist_facts  a list of distribution factors,
              e.g. nodal &#39;weights&#39;
        &#34;&#34;&#34;
        self.__ex_put_node_set_dist_fact(object_id, nodeSetDistFact)

    # --------------------------------------------------------------------

    def get_node_set_variable_number(self):
        &#34;&#34;&#34;
        get the number of node set variables in the model

        &gt;&gt;&gt; num_nsvars = exo.get_node_set_variable_number()

        Returns
        -------
              &lt;int&gt;  num_nsvars
        &#34;&#34;&#34;
        return self.__ex_get_variable_param(&#39;EX_NODE_SET&#39;).value

    # --------------------------------------------------------------------

    def set_node_set_variable_number(self, number):
        &#34;&#34;&#34;
        update the number of node set variables in the model

        &gt;&gt;&gt; status = exo.set_node_set_variable_number(num_nsvars)

        Parameters
        ----------
              &lt;int&gt;  num_nsvars

        Returns
        -------
        status : bool
            True = successful execution
        &#34;&#34;&#34;
        self.__ex_put_variable_param(&#39;EX_NODE_SET&#39;, number)
        return True

    # --------------------------------------------------------------------

    def get_node_set_variable_truth_table(self, entId=None):
        &#34;&#34;&#34;
        See `exodus.get_variable_truth_table`
        &#34;&#34;&#34;
        return self.get_variable_truth_table(&#39;EX_NODE_SET&#39;, entId)

    # --------------------------------------------------------------------

    def set_node_set_variable_truth_table(self, table):
        &#34;&#34;&#34;
        See `exodus.set_variable_truth_table`
        &#34;&#34;&#34;
        return self.set_variable_truth_table(&#39;EX_NODE_SET&#39;, table)

    # --------------------------------------------------------------------

    def get_node_set_variable_names(self):
        &#34;&#34;&#34;
        get the list of node set variable names in the model

        &gt;&gt;&gt; nsvar_names = exo.get_node_set_variable_names()

        Returns
        -------
              &lt;list&lt;string&gt;&gt;  nsvar_names
        &#34;&#34;&#34;
        if self.__ex_get_variable_param(&#39;EX_NODE_SET&#39;).value == 0:
            return []
        return self.__ex_get_variable_names(&#39;EX_NODE_SET&#39;)

    # --------------------------------------------------------------------

    def put_node_set_variable_name(self, name, index):
        &#34;&#34;&#34;
        add the name and index of a new node set variable to the model;
        node set variable indexing goes from 1 to
        exo.get_node_set_variable_number()

        &gt;&gt;&gt; status = exo.put_node_set_variable_name(nsvar_name, nsvar_index)

        Parameters
        ----------
            &lt;string&gt;  nsvar_name   name of new node set variable
            &lt;int&gt;     nsvar_index  1-based index of new node set variable

        Returns
        -------
        status : bool
            True = successful execution

        Note:
        -----
        this method is often called within the following sequence:

        &gt;&gt;&gt; num_nsvars = exo.get_node_set_variable_number()
        &gt;&gt;&gt; new_nsvar_index = num_nsvars + 1
        &gt;&gt;&gt; num_nsvars += 1
        &gt;&gt;&gt; exo.set_node_set_variable_number(num_nsvars)
        &gt;&gt;&gt; exo.put_node_set_variable_name(&#34;new_nsvar&#34;, new_nsvar_index)
        &#34;&#34;&#34;
        NSvarNames = self.get_variable_names(&#39;EX_NODE_SET&#39;)
        if name in NSvarNames:
            print(&#34;WARNING: Node set variable \&#34;{}\&#34; already exists.&#34;.format(name))
        if index &gt; len(NSvarNames):
            raise Exception(&#34;ERROR: variable index out of range.&#34;)
        self.__ex_put_variable_name(&#39;EX_NODE_SET&#39;, index, name)
        return True

    # --------------------------------------------------------------------

    def get_node_set_variable_values(self, object_id, name, step):
        &#34;&#34;&#34;
        get list of node set variable values for a specified node
        set, node set variable name, and time step; the list has
        one variable value per node in the set

        &gt;&gt;&gt; nsvar_vals =
        ...   exo.get_node_set_variable_values(node_set_id,
        ...    nsvar_name, time_step)

        Parameters
        ----------
            &lt;int&gt;     node_set_id  node set *ID* (not *INDEX*)
            &lt;string&gt;  nsvar_name   name of node set variable
            &lt;int&gt;     time_step    1-based index of time step

        Returns
        -------

            if array_type == &#39;ctype&#39;:
              &lt;list&lt;ctypes.c_double&gt;&gt;  nsvar_vals

            if array_type == &#39;numpy&#39;:
              &lt;np_array&lt;double&gt;&gt;  nsvar_vals
        &#34;&#34;&#34;
        values = self.get_variable_values(&#39;EX_NODE_SET&#39;, object_id, name, step)
        return values

    # --------------------------------------------------------------------

    def get_partial_node_set_variable_values(self, object_id, name, step, start_index, num_nodes):
        &#34;&#34;&#34;
        get list of node set variable values for a specified node
        set, node set variable name, and time step; the list has
        one variable value per node in the set

        &gt;&gt;&gt; nsvar_vals =
        ...   exo.get_node_set_variable_values(node_set_id,
        ...    nsvar_name, time_step)

        Parameters
        ----------
            &lt;int&gt;     node_set_id  node set *ID* (not *INDEX*)
            &lt;string&gt;  nsvar_name   name of node set variable
            &lt;int&gt;     time_step    1-based index of time step
            &lt;int&gt;     start_index 1-based index of node to start returning data
            &lt;int&gt;     num_nodes   number of nodes to return data for.

        Returns
        -------

            if array_type == &#39;ctype&#39;:
              &lt;list&lt;ctypes.c_double&gt;&gt;  nsvar_vals

            if array_type == &#39;numpy&#39;:
              &lt;np_array&lt;double&gt;&gt;  nsvar_vals
        &#34;&#34;&#34;
        names = self.get_variable_names(&#39;EX_NODE_SET&#39;)
        var_id = names.index(name) + 1
        values = self.__ex_get_partial_var(step, &#39;EX_NODE_SET&#39;, var_id, object_id, start_index, num_nodes)
        if self.use_numpy:
            values = ctype_to_numpy(self, values)
        return values

    # --------------------------------------------------------------------

    def put_node_set_variable_values(self, object_id, name, step, values):
        &#34;&#34;&#34;
        store a list of node set variable values for a specified node
        set, node set variable name, and time step; the list has one
        variable value per node in the set

        &gt;&gt;&gt; status =
        ... exo.put_node_set_variable_values(node_set_id,
        ...     nsvar_name, time_step, nsvar_vals)

        Parameters
        ----------
            &lt;int&gt;          node_set_id  node set *ID* (not *INDEX*)
            &lt;string&gt;       nsvar_name   name of node set variable
            &lt;int&gt;          time_step    1-based index of time step
            &lt;list&lt;float&gt;&gt;  nsvar_vals

        Returns
        -------
        status : bool
            True = successful execution
        &#34;&#34;&#34;
        self.put_variable_values(&#39;EX_NODE_SET&#39;, object_id, name, step, values)
        return True

    # --------------------------------------------------------------------

    def get_all_node_set_params(self):
        &#34;&#34;&#34;
        get total number of nodes and distribution factors (e.g. nodal
        &#39;weights&#39;) combined among all node sets

        &gt;&gt;&gt; tot_num_ns_nodes,
        ... tot_num_ns_dist_facts = exo.get_all_node_set_params()

        Returns
        -------
            &lt;int&gt;  tot_num_ns_nodes
            &lt;int&gt;  tot_num_ns_dist_facts
        &#34;&#34;&#34;
        nodeSetIds = self.__ex_get_ids(&#39;EX_NODE_SET&#39;)
        totNumSetNodes, totNumSetDistFacts = 0, 0
        for nodeSetId in nodeSetIds:
            (numSetNodes, numSetDistFacts) = self.__ex_get_set_param(&#39;EX_NODE_SET&#39;, nodeSetId)
            totNumSetNodes += numSetNodes
            totNumSetDistFacts += numSetDistFacts
        return totNumSetNodes, totNumSetDistFacts

    # --------------------------------------------------------------------

    def get_set_params(self, object_type, object_id):
        &#34;&#34;&#34;
        get number of entities and distribution factors (e.g. nodal
        &#39;weights&#39;) in the specified set

        &gt;&gt;&gt; num_ns_nodes, num_ns_dist_facts =
        ...     exo.get_set_params(&#39;EX_NODE_SET&#39;, node_set_id)

        Parameters
        ----------
        set_id : int
            set *ID* (not *INDEX*)

        Returns
        -------
        num_set_entities : int
        num_set_dist_facts : int
        &#34;&#34;&#34;
        (numSetEntities, numSetDistFacts) = self.__ex_get_set_param(object_type, object_id)
        return numSetEntities, numSetDistFacts

    # --------------------------------------------------------------------

    def put_set_params(self, object_type, object_id, numSetEntity, numSetDistFacts=None):
        &#34;&#34;&#34;
        initialize a new set of the specified type

        &gt;&gt;&gt; exo.put_set_params(&#39;EX_NODE_SET&#39;, node_set_id,
        ...                 num_ns_nodes, num_ns_dist_facts)

        Parameters
        ----------
        set_id : int
            set *ID* (not *INDEX*)
        num_set_entity : int
            number of nodes/edges/faces/elements to be added to set
        num_dist_facts : int, optional
            number of distribution factors (e.g. nodal &#39;weights&#39;) --
            must be equal to zero or num_set_entity
        &#34;&#34;&#34;
        if numSetDistFacts is None:
            numSetDistFacts = numSetEntity
        assert numSetDistFacts in (0, numSetEntity)
        self.__ex_put_set_param(object_type, object_id, numSetEntity, numSetDistFacts)

    # --------------------------------------------------------------------

    def get_node_set_params(self, object_id):
        &#34;&#34;&#34; See `exodus.put_set_params` &#34;&#34;&#34;

        (numSetNodes, numSetDistFacts) = self.__ex_get_set_param(&#39;EX_NODE_SET&#39;, object_id)
        return numSetNodes, numSetDistFacts

    # --------------------------------------------------------------------

    def put_node_set_params(self, object_id, numSetNodes, numSetDistFacts=None):
        &#34;&#34;&#34; See `exodus.put_set_params` &#34;&#34;&#34;
        if numSetDistFacts is None:
            numSetDistFacts = numSetNodes
        assert numSetDistFacts in (0, numSetNodes)
        self.__ex_put_set_param(&#39;EX_NODE_SET&#39;, object_id, numSetNodes, numSetDistFacts)

    # --------------------------------------------------------------------

    def get_node_set_property_names(self):
        &#34;&#34;&#34;
        get the list of node set property names for all node sets in
        the model

        &gt;&gt;&gt; nsprop_names = exo.get_node_set_property_names()

        Returns
        -------
            &lt;list&lt;string&gt;&gt;  nsprop_names
        &#34;&#34;&#34;
        names = self.__ex_get_prop_names(&#39;EX_NODE_SET&#39;, &#39;EX_INQ_NS_PROP&#39;)
        return list(names)

    # --------------------------------------------------------------------

    def get_node_set_property_value(self, object_id, name):
        &#34;&#34;&#34;
        get node set property value (an integer) for a specified node
        set and node set property name

        &gt;&gt;&gt; nsprop_val = exo.get_node_set_property_value(node_set_id, nsprop_name)

        Parameters
        ----------
            &lt;int&gt;     node_set_id  node set *ID* (not *INDEX*)
            &lt;string&gt;  nsprop_name

        Returns
        -------
            &lt;int&gt;  nsprop_val
        &#34;&#34;&#34;
        propVal = self.__ex_get_prop(&#39;EX_NODE_SET&#39;, object_id, name)
        return int(propVal)

    # --------------------------------------------------------------------

    def put_node_set_property_value(self, object_id, name, value):
        &#34;&#34;&#34;
        store a node set property name and its integer value for a
        node set

        &gt;&gt;&gt; status = exo.put_node_set_property_value(node_set_id,
        ...                   nsprop_name, nsprop_val)

        Parameters
        ----------
            &lt;int&gt;     node_set_id  node set *ID* (not *INDEX*)
            &lt;string&gt;  nsprop_name
            &lt;int&gt;     nsprop_val

        Returns
        -------
        status : bool
            True = successful execution
        &#34;&#34;&#34;
        return self.__ex_put_prop(&#39;EX_NODE_SET&#39;, object_id, name, value)

    #
    # sidesets
    #
    # --------------------------------------------------------------------

    def num_side_sets(self):
        &#34;&#34;&#34;
        get the number of side sets in the model

        &gt;&gt;&gt; num_side_sets = exo.num_side_sets()

        Returns
        -------
            &lt;int&gt;  num_side_sets
        &#34;&#34;&#34;
        return self.numSideSets.value

    # --------------------------------------------------------------------

    def get_side_set_ids(self):
        &#34;&#34;&#34;
        get mapping of exodus side set index to user- or application-
        defined side set id; side_set_ids is ordered
        by the *INDEX* ordering, a 1-based system going from
        1 to exo.num_side_sets(), used by exodus for storage
        and input/output of array data stored on the side sets; a
        user or application can optionally use a separate side set
        *ID* numbering system, so the side_set_ids array points to the
        side set *ID* for each side set *INDEX*

        &gt;&gt;&gt; side_set_ids = exo.get_ids(&#39;EX_SIDE_SET&#39;)

        Returns
        -------

            if array_type == &#39;ctype&#39;:
              &lt;list&lt;int&gt;&gt;  side_set_ids

            if array_type == &#39;numpy&#39;:
              &lt;np_array&lt;int&gt;&gt;  side_set_ids
        &#34;&#34;&#34;
        return self.get_ids(&#39;EX_SIDE_SET&#39;)

    # --------------------------------------------------------------------

    def get_side_set_name(self, object_id):
        &#34;&#34;&#34;
        get the name of a side set

        &gt;&gt;&gt; side_set_name = exo.get_side_set_name(side_set_id)

        Parameters
        ----------
            &lt;int&gt;  side_set_id  side set *ID* (not *INDEX*)

        Returns
        -------
            &lt;string&gt;  side_set_name
        &#34;&#34;&#34;
        return self.__ex_get_name(&#39;EX_SIDE_SET&#39;, object_id)

    # --------------------------------------------------------------------

    def put_side_set_name(self, object_id, name):
        &#34;&#34;&#34;
        store the name of a side set

        &gt;&gt;&gt; exo.put_side_set_name(side_set_id, side_set_name)

        Parameters
        ----------
            &lt;int&gt;     side_set_id    side set *ID* (not *INDEX*)
            &lt;string&gt;  side_set_name
        &#34;&#34;&#34;
        self.__ex_put_name(&#39;EX_SIDE_SET&#39;, object_id, name)

    # --------------------------------------------------------------------

    def get_side_set_names(self):
        &#34;&#34;&#34;
        get a list of all side set names ordered by side set *INDEX*;
        (see `exodus.get_ids` for explanation of the
        difference between side set *ID* and side set *INDEX*)

        &gt;&gt;&gt; side_set_names = exo.get_side_set_names()

        Returns
        -------
            &lt;list&lt;string&gt;&gt;  side_set_names
        &#34;&#34;&#34;
        return self.__ex_get_names(&#39;EX_SIDE_SET&#39;)

    # --------------------------------------------------------------------

    def put_side_set_names(self, names):
        &#34;&#34;&#34;
        store a list of all side set names ordered by side set *INDEX*;
        (see `exodus.get_ids` for explanation of the
        difference between side set *ID* and side set *INDEX*)

        &gt;&gt;&gt; exo.put_side_set_names(side_set_names)

        Parameters
        ----------
            &lt;list&lt;string&gt;&gt;  side_set_names
        &#34;&#34;&#34;
        self.__ex_put_names(&#39;EX_SIDE_SET&#39;, names)

    # --------------------------------------------------------------------

    def num_faces_in_side_set(self, object_id):
        &#34;&#34;&#34;
        get the number of faces in a side set

        &gt;&gt;&gt; num_ss_faces = exo.num_faces_in_side_set(side_set_id)

        Parameters
        ----------
            &lt;int&gt;  side_set_id  side set *ID* (not *INDEX*)

        Returns
        -------
            &lt;int&gt;  num_ss_faces
        &#34;&#34;&#34;
        ssids = self.get_ids(&#39;EX_SIDE_SET&#39;)
        if object_id not in ssids:
            print(&#34;WARNING: queried side set ID does not exist in database&#34;)
            return 0
        (num_side_in_set, _num_dist_fact_in_set) = self.__ex_get_set_param(&#39;EX_SIDE_SET&#39;, object_id)
        return num_side_in_set

    # --------------------------------------------------------------------

    def get_all_side_set_params(self):
        &#34;&#34;&#34;
        get total number of sides, nodes, and distribution factors
        (e.g. nodal &#39;weights&#39;) combined among all side sets

        &gt;&gt;&gt; tot_num_ss_sides, tot_num_ss_nodes, tot_num_ss_dist_facts =
        ...          exo.get_all_side_set_params()

        Returns
        -------
            &lt;int&gt;  tot_num_ss_sides
            &lt;int&gt;  tot_num_ss_nodes
            &lt;int&gt;  tot_num_ss_dist_facts

        Note:
        -----
        The number of nodes (and distribution factors) in a side set is
        the sum of all face nodes.  A single node can be counted more
        than once, i.e. once for each face it belongs to in the side set.
        &#34;&#34;&#34;
        ids = self.__ex_get_ids(&#39;EX_SIDE_SET&#39;)
        totNumSetSides, totNumSetDistFacts = 0, 0  # totNumSetDistFacts = totNumSetNodes
        for sideSetId in ids:
            (numSetSides, numSetDistFacts) = self.__ex_get_set_param(&#39;EX_SIDE_SET&#39;, sideSetId)
            totNumSetSides += numSetSides
            totNumSetDistFacts += numSetDistFacts
        totNumSetNodes = totNumSetDistFacts
        return totNumSetSides, totNumSetNodes, totNumSetDistFacts

    # --------------------------------------------------------------------

    def get_side_set_params(self, object_id):
        &#34;&#34;&#34;
        get number of sides and nodal distribution factors (e.g. nodal
        &#39;weights&#39;) in a side set

        &gt;&gt;&gt; num_ss_sides, num_ss_dist_facts = exo.get_side_set_params(side_set_id)

        Parameters
        ----------
            &lt;int&gt;  side_set_id  side set *ID* (not *INDEX*)

        Returns
        -------
            &lt;int&gt;  num_ss_sides
            &lt;int&gt;  num_ss_dist_facts

        Note:
        -----
        The number of nodes (and distribution factors) in a side set is
        the sum of all face nodes.  A single node can be counted more
        than once, i.e. once for each face it belongs to in the side set.
        &#34;&#34;&#34;
        (numSetSides, numSetDistFacts) = self.__ex_get_set_param(&#39;EX_SIDE_SET&#39;, object_id)
        return numSetSides, numSetDistFacts

    # --------------------------------------------------------------------

    def put_side_set_params(self, object_id, numSetSides, numSetDistFacts):
        &#34;&#34;&#34;
        initialize a new side set

        &gt;&gt;&gt; exo.put_side_set_params(side_set_id, num_ss_sides, num_ss_dist_facts)

        Parameters
        ----------
            &lt;int&gt;  side_set_id        side set *ID* (not *INDEX*)
            &lt;int&gt;  num_ss_sides       number of sides to be added to set
            &lt;int&gt;  num_ss_dist_facts  number of nodal distribution factors
              (e.g. nodal &#39;weights&#39;)

        Note:
        -----
        The number of nodes (and distribution factors) in a side set is
        the sum of all face nodes.  A single node can be counted more
        than once, i.e. once for each face it belongs to in the side set.
        &#34;&#34;&#34;
        self.__ex_put_set_param(&#39;EX_SIDE_SET&#39;, object_id, numSetSides, numSetDistFacts)

    # --------------------------------------------------------------------

    def get_side_set(self, object_id):
        &#34;&#34;&#34;
        get the lists of element and side indices in a side set; the
        two lists correspond: together, ss_elems[i] and ss_sides[i]
        define the face of an element

        &gt;&gt;&gt; ss_elems, ss_sides = exo.get_side_set(side_set_id)

        Parameters
        ----------
            &lt;int&gt;  side_set_id  side set *ID* (not *INDEX*)

        Returns
        -------

            if array_type == &#39;ctype&#39;:
              &lt;list&lt;int&gt;&gt;  ss_elems
              &lt;list&lt;int&gt;&gt;  ss_sides

            if array_type == &#39;numpy&#39;:
              &lt;np_array&lt;int&gt;&gt;  ss_elems
              &lt;np_array&lt;int&gt;&gt;  ss_sides
        &#34;&#34;&#34;
        (side_set_elem_list, side_set_side_list) = self.__ex_get_side_set(object_id)
        if self.use_numpy:
            side_set_elem_list = ctype_to_numpy(self, side_set_elem_list)
            side_set_side_list = ctype_to_numpy(self, side_set_side_list)
        return side_set_elem_list, side_set_side_list

    # --------------------------------------------------------------------

    def put_side_set(self, object_id, sideSetElements, sideSetSides):
        &#34;&#34;&#34;
        store a side set by its id and the lists of element and side
        indices in the side set; the two lists correspond: together,
        ss_elems[i] and ss_sides[i] define the face of an element

        &gt;&gt;&gt; exo.put_side_set(side_set_id, ss_elems, ss_sides)

        Parameters
        ----------
            &lt;int&gt;        side_set_id  side set *ID* (not *INDEX*)
            &lt;list&lt;int&gt;&gt;  ss_elems
            &lt;list&lt;int&gt;&gt;  ss_sides
        &#34;&#34;&#34;
        self.__ex_put_side_set(object_id, sideSetElements, sideSetSides)

    # --------------------------------------------------------------------

    def get_side_set_dist_fact(self, object_id):
        &#34;&#34;&#34;
        get the list of distribution factors for nodes in a side set

        &gt;&gt;&gt; ss_dist_facts = exo.get_side_set_dist_fact(side_set_id)

        Parameters
        ----------
            &lt;int&gt;        side_set_id  side set *ID* (not *INDEX*)

        Returns
        -------

            if array_type == &#39;ctype&#39;:
              &lt;list&lt;float&gt;&gt;  ss_dist_facts  a list of distribution factors,
                e.g. nodal &#39;weights&#39;

            if array_type == &#39;numpy&#39;:
              &lt;np_array&lt;double&gt;&gt;  ss_dist_facts  a list of distribution
                factors, e.g. nodal
                &#39;weights&#39;

        Note:
        -----
        The number of nodes (and distribution factors) in a side set is
        the sum of all face nodes.  A single node can be counted more
        than once, i.e. once for each face it belongs to in the side set.
        &#34;&#34;&#34;
        side_set_dfs = list(self.__ex_get_side_set_dist_fact(object_id))
        if self.use_numpy:
            side_set_dfs = self.np.array(side_set_dfs)
        return side_set_dfs

    # --------------------------------------------------------------------

    def put_side_set_dist_fact(self, object_id, sideSetDistFact):
        &#34;&#34;&#34;
        store the list of distribution factors for nodes in a side set

        &gt;&gt;&gt; exo.put_side_set_dist_fact(side_set_id, ss_dist_facts)

        Parameters
        ----------
            &lt;int&gt;          node_set_id    node set *ID* (not *INDEX*)
            &lt;list&lt;float&gt;&gt;  ns_dist_facts  a list of distribution factors,
              e.g. nodal &#39;weights&#39;

        Note:
        -----
        The number of nodes (and distribution factors) in a side set is
        the sum of all face nodes.  A single node can be counted more
        than once, i.e. once for each face it belongs to in the side set.
        &#34;&#34;&#34;
        self.__ex_put_side_set_dist_fact(object_id, sideSetDistFact)

    # --------------------------------------------------------------------

    def get_side_set_node_list(self, object_id):
        &#34;&#34;&#34;
        get two lists:
         1. number of nodes for each side in the set
         2. concatenation of the nodes for each side in the set

        &gt;&gt;&gt; ss_num_nodes_per_side, ss_nodes = exo.get_side_set_node_list(side_set_id)

        Parameters
        ----------
            &lt;int&gt;        side_set_id  side set *ID* (not *INDEX*)

        Returns
        -------

            if array_type == &#39;ctype&#39;:
              &lt;list&lt;int&gt;&gt;  ss_num_side_nodes
              &lt;list&lt;int&gt;&gt;  ss_nodes

            if array_type == &#39;numpy&#39;:
              &lt;np_array&lt;int&gt;&gt;  ss_num_side_nodes
              &lt;np_array&lt;int&gt;&gt;  ss_nodes

        Note:
        -----
        The number of nodes (and distribution factors) in a side set is
        the sum of all face nodes.  A single node can be counted more
        than once, i.e. once for each face it belongs to in the side set.
        &#34;&#34;&#34;
        (side_set_node_cnt_list,
         side_set_node_list) = self.__ex_get_side_set_node_list(object_id)
        if self.use_numpy:
            side_set_node_cnt_list = ctype_to_numpy(
                self, side_set_node_cnt_list)
            side_set_node_list = ctype_to_numpy(self, side_set_node_list)
        return side_set_node_cnt_list, side_set_node_list

    # --------------------------------------------------------------------

    def get_side_set_variable_truth_table(self, entId=None):
        &#34;&#34;&#34;
        See `exodus.get_variable_truth_table`
        &#34;&#34;&#34;
        return self.get_variable_truth_table(&#39;EX_SIDE_SET&#39;, entId)

    # --------------------------------------------------------------------

    def set_side_set_variable_truth_table(self, table):
        &#34;&#34;&#34;
        See `exodus.set_variable_truth_table`
        &#34;&#34;&#34;
        return self.set_variable_truth_table(&#39;EX_SIDE_SET&#39;, table)

    # --------------------------------------------------------------------

    def get_side_set_variable_number(self):
        &#34;&#34;&#34;
        get the number of side set variables in the model

        &gt;&gt;&gt; num_ssvars = exo.get_side_set_variable_number()

        Returns
        -------
              &lt;int&gt;  num_ssvars
        &#34;&#34;&#34;
        return self.__ex_get_variable_param(&#39;EX_SIDE_SET&#39;).value

    # --------------------------------------------------------------------

    def set_side_set_variable_number(self, number):
        &#34;&#34;&#34;
        update the number of side set variables in the model

        &gt;&gt;&gt; status = exo.set_side_set_variable_number(num_ssvars)

        Parameters
        ----------
              &lt;int&gt;  num_ssvars

        Returns
        -------
        status : bool
            True = successful execution
        &#34;&#34;&#34;
        self.__ex_put_variable_param(&#39;EX_SIDE_SET&#39;, number)
        return True

    # --------------------------------------------------------------------

    def get_side_set_variable_names(self):
        &#34;&#34;&#34;
        get the list of side set variable names in the model

        &gt;&gt;&gt; ssvar_names = exo.get_side_set_variable_names()

        Returns
        -------
              &lt;list&lt;string&gt;&gt;  ssvar_names
        &#34;&#34;&#34;
        if self.__ex_get_variable_param(&#39;EX_SIDE_SET&#39;).value == 0:
            return []
        return self.__ex_get_variable_names(&#39;EX_SIDE_SET&#39;)

    # --------------------------------------------------------------------

    def put_side_set_variable_name(self, name, index):
        &#34;&#34;&#34;
        add the name and index of a new side set variable to the model;
        side set variable indexing goes from 1 to
        exo.get_side_set_variable_number()

        &gt;&gt;&gt; status = exo.put_side_set_variable_name(ssvar_name, ssvar_index)

        Parameters
        ----------
            &lt;string&gt;  ssvar_name   name of new side set variable
            &lt;int&gt;     ssvar_index  1-based index of new side set variable

        Returns
        -------
        status : bool
            True = successful execution

        Note:
        -----
        this method is often called within the following sequence:

        &gt;&gt;&gt; num_ssvars = exo.get_side_set_variable_number()
        &gt;&gt;&gt; new_ssvar_index = num_ssvars + 1
        &gt;&gt;&gt; num_ssvars += 1
        &gt;&gt;&gt; exo.set_side_set_variable_number(num_ssvars)
        &gt;&gt;&gt; exo.put_side_set_variable_name(&#34;new_ssvar&#34;, new_ssvar_index)

        &#34;&#34;&#34;
        SSvarNames = self.get_variable_names(&#39;EX_SIDE_SET&#39;)
        if name in SSvarNames:
            print(&#34;WARNING: Side set variable \&#34;{}\&#34; already exists.&#34;.format(name))
        if index &gt; len(SSvarNames):
            raise Exception(&#34;ERROR: variable index out of range.&#34;)
        self.__ex_put_variable_name(&#39;EX_SIDE_SET&#39;, index, name)
        return True

    # --------------------------------------------------------------------

    def get_side_set_variable_values(self, object_id, name, step):
        &#34;&#34;&#34;
        get list of side set variable values for a specified side
        set, side set variable name, and time step; the list has
        one variable value per side in the set

        &gt;&gt;&gt; ssvar_vals = exo.get_side_set_variable_values(side_set_id,
        ...    ssvar_name, time_step)

        Parameters
        ----------
            &lt;int&gt;     side_set_id  side set *ID* (not *INDEX*)
            &lt;string&gt;  ssvar_name   name of side set variable
            &lt;int&gt;     time_step    1-based index of time step

        Returns
        -------

            if array_type == &#39;ctype&#39;:
              &lt;list&lt;ctypes.c_double&gt;&gt;  ssvar_vals

            if array_type == &#39;numpy&#39;:
              &lt;np_array&lt;double&gt;&gt;  ssvar_vals
        &#34;&#34;&#34;
        values = self.get_variable_values(&#39;EX_SIDE_SET&#39;, object_id, name, step)
        return values

    # --------------------------------------------------------------------

    def get_partial_side_set_variable_values(self, object_id, name, step, start_index, num_sides):
        &#34;&#34;&#34;
        get list of side set variable values for a specified side
        set, side set variable name, and time step; the list has
        one variable value per side in the set

        &gt;&gt;&gt; ssvar_vals = exo.get_side_set_variable_values(side_set_id,
        ...    ssvar_name, time_step)

        Parameters
        ----------
            &lt;int&gt;     side_set_id  side set *ID* (not *INDEX*)
            &lt;string&gt;  ssvar_name   name of side set variable
            &lt;int&gt;     time_step    1-based index of time step
            &lt;int&gt;     start_index 1-based index of side to start returning data
            &lt;int&gt;     num_nodes   number of sides to return data for.

        Returns
        -------

            if array_type == &#39;ctype&#39;:
              &lt;list&lt;ctypes.c_double&gt;&gt;  ssvar_vals

            if array_type == &#39;numpy&#39;:
              &lt;np_array&lt;double&gt;&gt;  ssvar_vals
        &#34;&#34;&#34;
        names = self.get_variable_names(&#39;EX_SIDE_SET&#39;)
        var_id = names.index(name) + 1
        values = self.__ex_get_partial_var(step, &#39;EX_SIDE_SET&#39;, var_id, object_id, start_index, num_sides)
        if self.use_numpy:
            values = ctype_to_numpy(self, values)
        return values

    # --------------------------------------------------------------------

    def put_side_set_variable_values(self, object_id, name, step, values):
        &#34;&#34;&#34;
        store a list of side set variable values for a specified side
        set, side set variable name, and time step; the list has one
        variable value per side in the set

        &gt;&gt;&gt; status = exo.put_side_set_variable_values(side_set_id,
        ...              ssvar_name, time_step, ssvar_vals)

        Parameters
        ----------
            &lt;int&gt;          side_set_id  side set *ID* (not *INDEX*)
            &lt;string&gt;       ssvar_name   name of side set variable
            &lt;int&gt;          time_step    1-based index of time step
            &lt;list&lt;float&gt;&gt;  ssvar_vals

        Returns
        -------
        status : bool
            True = successful execution
        &#34;&#34;&#34;
        self.put_variable_values(&#39;EX_SIDE_SET&#39;, object_id, name, step, values)
        return True

    # --------------------------------------------------------------------

    def get_side_set_property_names(self):
        &#34;&#34;&#34;
        get the list of side set property names for all side sets in
        the model

        &gt;&gt;&gt; ssprop_names = exo.get_side_set_property_names()

        Returns
        -------
            &lt;list&lt;string&gt;&gt;  ssprop_names
        &#34;&#34;&#34;
        names = self.__ex_get_prop_names(&#39;EX_SIDE_SET&#39;, &#39;EX_INQ_SS_PROP&#39;)
        return list(names)

    # --------------------------------------------------------------------

    def get_side_set_property_value(self, object_id, name):
        &#34;&#34;&#34;
        get side set property value (an integer) for a specified side
        set and side set property name

        &gt;&gt;&gt; ssprop_val = exo.get_side_set_property_value(side_set_id, ssprop_name)

        Parameters
        ----------
            &lt;int&gt;     side_set_id  side set *ID* (not *INDEX*)
            &lt;string&gt;  ssprop_name

        Returns
        -------
            &lt;int&gt;  ssprop_val
        &#34;&#34;&#34;
        propVal = self.__ex_get_prop(&#39;EX_SIDE_SET&#39;, object_id, name)
        return int(propVal)

    # --------------------------------------------------------------------

    def put_side_set_property_value(self, object_id, name, value):
        &#34;&#34;&#34;
        store a side set property name and its integer value for a
        side set

        &gt;&gt;&gt; status = exo.put_side_set_property_value(side_set_id,
        ...               ssprop_name, ssprop_val)

        Parameters
        ----------
            &lt;int&gt;     side_set_id  side set *ID* (not *INDEX*)
            &lt;string&gt;  ssprop_name
            &lt;int&gt;     ssprop_val

        Returns
        -------
        status : bool
            True = successful execution
        &#34;&#34;&#34;
        return self.__ex_put_prop(&#39;EX_SIDE_SET&#39;, object_id, name, value)

    #
    # global variables
    #
    # --------------------------------------------------------------------

    def get_global_variable_number(self):
        &#34;&#34;&#34;
        get the number of global variables in the model

        &gt;&gt;&gt; num_gvars = exo.get_global_variable_number()

        Returns
        -------
              &lt;int&gt;  num_gvars
        &#34;&#34;&#34;
        return self.__ex_get_variable_param(&#39;EX_GLOBAL&#39;).value

    # --------------------------------------------------------------------

    def set_global_variable_number(self, number):
        &#34;&#34;&#34;
        update the number of global variables in the model

        &gt;&gt;&gt; status = exo.set_global_variable_number(num_gvars)

        Parameters
        ----------
              &lt;int&gt;  num_gvars

        Returns
        -------
        status : bool
            True = successful execution
        &#34;&#34;&#34;
        self.__ex_put_variable_param(&#39;EX_GLOBAL&#39;, number)
        return True

    # --------------------------------------------------------------------

    def get_global_variable_names(self):
        &#34;&#34;&#34;
        get the list of global variable names in the model

        &gt;&gt;&gt; gvar_names = exo.get_global_variable_names()

        Returns
        -------
              &lt;list&lt;string&gt;&gt;  gvar_names
        &#34;&#34;&#34;
        if self.get_variable_number(&#39;EX_GLOBAL&#39;) == 0:
            return []
        return self.__ex_get_variable_names(&#39;EX_GLOBAL&#39;)

    # --------------------------------------------------------------------

    def put_global_variable_name(self, name, index):
        &#34;&#34;&#34;
        add the name and index of a new global variable to the model;
        global variable indexing goes from 1 to
        exo.get_global_variable_number()

        &gt;&gt;&gt; status = exo.put_global_variable_name(gvar_name, gvar_index)

        Parameters
        ----------
            &lt;string&gt;  gvar_name   name of new global variable
            &lt;int&gt;     gvar_index  1-based index of new global variable

        Returns
        -------
        status : bool
            True = successful execution

        Note:
        -----
        this method is often called within the following sequence:

        &gt;&gt;&gt; num_gvars = exo.get_global_variable_number()
        &gt;&gt;&gt; new_gvar_index = num_gvars + 1
        &gt;&gt;&gt; num_gvars += 1
        &gt;&gt;&gt; exo.set_global_variable_number(num_gvars)
        &gt;&gt;&gt; exo.put_global_variable_name(&#34;new_gvar&#34;, new_gvar_index)
        &#34;&#34;&#34;
        GlobVarNames = self.get_variable_names(&#39;EX_GLOBAL&#39;)
        if name in GlobVarNames:
            print(&#34;WARNING: Global variable \&#34;{}\&#34; already exists.&#34;.format(name))
        if index &gt; len(GlobVarNames):
            print((&#34;index&#34;, index, &#34;len&#34;, len(GlobVarNames)))
            raise Exception(&#34;ERROR: variable index out of range.&#34;)
        self.__ex_put_variable_name(&#39;EX_GLOBAL&#39;, index, name)
        return True

    # --------------------------------------------------------------------

    def get_global_variable_value(self, name, step):
        &#34;&#34;&#34;
        get a global variable value for a specified global variable
        name and time step

        &gt;&gt;&gt; gvar_val = exo.get_global_variable_value(gvar_name, time_step)

        Parameters
        ----------
            &lt;string&gt;  gvar_name  name of global variable
            &lt;int&gt;     time_step  1-based index of time step

        Returns
        -------
            &lt;float&gt;  gvar_val
        &#34;&#34;&#34;
        names = self.get_variable_names(&#39;EX_GLOBAL&#39;)
        var_id = names.index(name)
        num = self.__ex_get_variable_param(&#39;EX_GLOBAL&#39;)
        gvalues = self.__ex_get_var(step, &#39;EX_GLOBAL&#39;, 0, 1, num.value)
        return gvalues[var_id]

    # --------------------------------------------------------------------

    def get_all_global_variable_values(self, step):
        &#34;&#34;&#34;
        get all global variable values (one for each global variable
        name, and in the order given by exo.get_global_variable_names())
        at a specified time step

        &gt;&gt;&gt; gvar_vals = exo.get_all_global_variable_values(time_step)

        Parameters
        ----------
            &lt;int&gt;     time_step  1-based index of time step

        Returns
        -------

            if array_type == &#39;ctype&#39;:
              &lt;list&lt;float&gt;&gt;  gvar_vals

            if array_type == &#39;numpy&#39;:
              &lt;np_array&lt;double&gt;&gt;  gvar_vals
        &#34;&#34;&#34;
        num = self.__ex_get_variable_param(&#39;EX_GLOBAL&#39;)
        gvalues = self.__ex_get_var(step, &#39;EX_GLOBAL&#39;, 0, 1, num.value)
        values = []
        for i in range(num.value):
            values.append(gvalues[i])
        if self.use_numpy:
            values = self.np.array(values)
        return values

    # --------------------------------------------------------------------

    def put_global_variable_value(self, name, step, value):
        &#34;&#34;&#34;
        store a global variable value for a specified global variable
        name and time step

        &gt;&gt;&gt; status = exo.put_global_variable_value(gvar_name, time_step, gvar_val)

        Parameters
        ----------
            &lt;string&gt;  gvar_name  name of global variable
            &lt;int&gt;     time_step  1-based index of time step
            &lt;float&gt;   gvar_val

        Returns
        -------
        status : bool
            True = successful execution
        &#34;&#34;&#34;
        # we must write all values at once, not individually
        names = self.get_variable_names(&#39;EX_GLOBAL&#39;)
        # get all values
        numVals = self.get_variable_number(&#39;EX_GLOBAL&#39;)
        values = (ctypes.c_double * numVals)()
        for i in range(numVals):
            values[i] = ctypes.c_double(
                self.get_global_variable_value(
                    names[i], step))
        # adjust one of them
        values[names.index(name)] = ctypes.c_double(value)
        # write them all
        EXODUS_LIB.ex_put_glob_vars(self.fileId,
                                    ctypes.c_int(step),
                                    ctypes.c_int(numVals),
                                    values)
        return True

    # --------------------------------------------------------------------

    def put_all_global_variable_values(self, step, values):
        &#34;&#34;&#34;
        store all global variable values (one for each global variable
        name, and in the order given by exo.get_global_variable_names())
        at a specified time step

        &gt;&gt;&gt; status = exo.put_all_global_variable_values(time_step, gvar_vals)

        Parameters
        ----------
            &lt;int&gt;          time_step  1-based index of time step
            &lt;list&lt;float&gt;&gt;  gvar_vals

        Returns
        -------
        status : bool
            True = successful execution
        &#34;&#34;&#34;
        numVals = self.get_variable_number(&#39;EX_GLOBAL&#39;)
        gvalues = (ctypes.c_double * numVals)()
        for i in range(numVals):
            gvalues[i] = ctypes.c_double(values[i])
        EXODUS_LIB.ex_put_glob_vars(self.fileId,
                                    ctypes.c_int(step),
                                    ctypes.c_int(numVals),
                                    gvalues)
        return True

    # --------------------------------------------------------------------

    def get_global_variable_values(self, name):
        &#34;&#34;&#34;
        get global variable values over all time steps for one global
        variable name

        &gt;&gt;&gt; gvar_vals = exo.get_global_variable_values(gvar_name)

        Parameters
        ----------
            &lt;string&gt;  gvar_name  name of global variable

        Returns
        -------

            if array_type == &#39;ctype&#39;:
              &lt;list&lt;float&gt;&gt;  gvar_vals

            if array_type == &#39;numpy&#39;:
              &lt;np_array&lt;double&gt;&gt;  gvar_vals
        &#34;&#34;&#34;
        names = self.get_variable_names(&#39;EX_GLOBAL&#39;)
        var_id = names.index(name)
        num = self.__ex_get_variable_param(&#39;EX_GLOBAL&#39;)
        values = []
        for i in range(self.numTimes.value):
            gvalues = self.__ex_get_var(i + 1, &#39;EX_GLOBAL&#39;, 0, 1, num.value)
            values.append(gvalues[var_id])
        if self.use_numpy:
            values = self.np.array(values)
        return values

    # --------------------------------------------------------------------

    def put_polyhedra_elem_blk(self, blkID,
                               num_elems_this_blk,
                               num_faces,
                               num_attr_per_elem):
        &#34;&#34;&#34;
        put in an element block with polyhedral elements

        &gt;&gt;&gt; status = exo.put_polyhedra_elem_blk(blkID, num_elems_this_blk,
        ...                                     num_faces, num_attr_per_elem)

        Parameters
        ----------
            &lt;int&gt;     blkID               id of the block to be added
            &lt;int&gt;     num_elems_this_blk
            &lt;int&gt;     num_faces  total number of faces in this block
            &lt;int&gt;     num_attr_per_elem

        Returns
        -------
        status : bool
            True = successful execution
        &#34;&#34;&#34;

        ebType = ctypes.c_int(get_entity_type(&#39;EX_ELEM_BLOCK&#39;))
        EXODUS_LIB.ex_put_block(self.fileId, ebType, ctypes.c_longlong(blkID),
                                ctypes.create_string_buffer(b&#34;NFACED&#34;),
                                ctypes.c_longlong(num_elems_this_blk),
                                ctypes.c_longlong(0),
                                ctypes.c_longlong(0),
                                ctypes.c_longlong(num_faces),
                                ctypes.c_longlong(num_attr_per_elem))
        return True

    # --------------------------------------------------------------------

    def put_polyhedra_face_blk(self, blkID,
                               num_faces_this_blk,
                               num_nodes,
                               num_attr_per_face):
        &#34;&#34;&#34;
        put in a block of faces

        &gt;&gt;&gt; status = exo.put_polyhedra_face_blk(blkID, num_faces_this_blk,
        ...                                     num_nodes, num_attr_per_face)

        Parameters
        ----------
            &lt;int&gt;     blkID               id of the block to be added
            &lt;int&gt;     num_faces_this_blk
            &lt;int&gt;     num_nodes           total number of nodes in this block
            &lt;int&gt;     num_attr_per_face

        Returns
        -------
        status : bool
            True = successful execution
        &#34;&#34;&#34;
        fbType = ctypes.c_int(get_entity_type(&#39;EX_FACE_BLOCK&#39;))
        EXODUS_LIB.ex_put_block(self.fileId, fbType, ctypes.c_longlong(blkID),
                                ctypes.create_string_buffer(b&#34;NSIDED&#34;),
                                ctypes.c_longlong(num_faces_this_blk),
                                ctypes.c_longlong(num_nodes),
                                ctypes.c_longlong(0),
                                ctypes.c_longlong(0),
                                ctypes.c_longlong(num_attr_per_face))
        return True

    # --------------------------------------------------------------------

    def put_face_count_per_polyhedra(self, blkID, entityCounts):
        &#34;&#34;&#34;
        put in a count of faces in for each polyhedra in an elem block

        &gt;&gt;&gt; status = exo.put_face_count_per_polyhedra(blkID, entityCounts)

        Parameters
        ----------
            &lt;int&gt;     blkID               id of the block to be added

            if array_type == &#39;ctype&#39;:
              &lt;list&lt;float&gt;&gt;  entityCounts

            if array_type == &#39;numpy&#39;:
              &lt;np_array&lt;double&gt;&gt;  entityCounts

        Returns
        -------
        status : bool
            True = successful execution
        &#34;&#34;&#34;
        ebType = ctypes.c_int(get_entity_type(&#39;EX_ELEM_BLOCK&#39;))
        entity_counts = (ctypes.c_int * len(entityCounts))()
        entity_counts[:] = entityCounts
        EXODUS_LIB.ex_put_entity_count_per_polyhedra(
            self.fileId, ebType, ctypes.c_longlong(blkID), entity_counts)
        return True

    # --------------------------------------------------------------------

    def put_node_count_per_face(self, blkID, entityCounts):
        &#34;&#34;&#34;
        put in a count of nodes in for each face in a polygonal face block

        &gt;&gt;&gt; status = exo.put_node_count_per_face(blkID, entityCounts)

        Parameters
        ----------
            &lt;int&gt;     blkID               id of the block to be added

            if array_type == &#39;ctype&#39;:
              &lt;list&lt;float&gt;&gt;  entityCounts

            if array_type == &#39;numpy&#39;:
              &lt;np_array&lt;double&gt;&gt;  entityCounts

        Returns
        -------
        status : bool
            True = successful execution
        &#34;&#34;&#34;
        ebType = ctypes.c_int(get_entity_type(&#39;EX_FACE_BLOCK&#39;))
        entity_counts = (ctypes.c_int * len(entityCounts))()
        entity_counts[:] = entityCounts
        EXODUS_LIB.ex_put_entity_count_per_polyhedra(
            self.fileId, ebType, ctypes.c_longlong(blkID), entity_counts)
        return True

    # --------------------------------------------------------------------

    def put_elem_face_conn(self, blkId, elemFaceConn):
        &#34;&#34;&#34;
        put in connectivity information from elems to faces

        &gt;&gt;&gt; status = exo.put_elem_face_conn(blkID, elemFaceConn)

        Parameters
        ----------
            &lt;int&gt;     blkID               id of the elem block to be added

            if array_type == &#39;ctype&#39;:
              &lt;list&lt;float&gt;&gt;  elemFaceConn  (raveled/flat list)

            if array_type == &#39;numpy&#39;:
              &lt;np_array&lt;double&gt;&gt;  elemFaceConn  (raveled/flat array)

        Returns
        -------
        status : bool
            True = successful execution
        &#34;&#34;&#34;
        ebType = ctypes.c_int(get_entity_type(&#39;EX_ELEM_BLOCK&#39;))
        elem_face_conn = (ctypes.c_int * len(elemFaceConn))()
        elem_face_conn[:] = elemFaceConn
        EXODUS_LIB.ex_put_conn(self.fileId, ebType, ctypes.c_longlong(blkId),
                               None, None, elem_face_conn)
        return True

    # --------------------------------------------------------------------

    def put_face_node_conn(self, blkId, faceNodeConn):
        &#34;&#34;&#34;
        put in connectivity information from faces to nodes

        &gt;&gt;&gt; status = exo.put_face_node_conn(blkID, faceNodeConn)

        Parameters
        ----------
            &lt;int&gt;     blkID               id of the face block to be added

            if array_type == &#39;ctype&#39;:
              &lt;list&lt;float&gt;&gt;  faceNodeConn  (raveled/flat list)

            if array_type == &#39;numpy&#39;:
              &lt;np_array&lt;double&gt;&gt;  faceNodeConn  (raveled/flat array)

        Returns
        -------
        status : bool
            True = successful execution
        &#34;&#34;&#34;
        ebType = ctypes.c_int(get_entity_type(&#39;EX_FACE_BLOCK&#39;))
        node_conn = (ctypes.c_int * len(faceNodeConn))()
        node_conn[:] = faceNodeConn
        EXODUS_LIB.ex_put_conn(self.fileId, ebType, ctypes.c_longlong(blkId),
                               node_conn, None, None)
        return True

    # --------------------------------------------------------------------

    def close(self):
        &#34;&#34;&#34;
        close the exodus file

        &gt;&gt;&gt; exo.close()

        Note:
        -----
        Can only be called once for an exodus object, and once called
        all methods for that object become inoperable
        &#34;&#34;&#34;
        print((&#34;Closing exodus file: &#34; + self.fileName))
        errorInt = EXODUS_LIB.ex_close(self.fileId)
        if errorInt != 0:
            raise Exception(
                &#34;ERROR: Closing file &#34; +
                self.fileName +
                &#34; had problems.&#34;)

    # --------------------------------------------------------------------
    #
    # Private Exodus API calls
    #
    # --------------------------------------------------------------------

    def __open(self, io_size=0):
        print((&#34;Opening exodus file: &#34; + self.fileName))
        self.mode = EX_READ
        if self.modeChar.lower() == &#34;a&#34;:
            self.mode = EX_WRITE
        if self.modeChar.lower() == &#34;w+&#34;:
            self.mode = EX_CLOBBER

        if self.modeChar.lower() in [
                &#34;a&#34;, &#34;r&#34;] and not os.path.isfile(self.fileName):
            raise Exception(
                &#34;ERROR: Cannot open &#34; +
                self.fileName +
                &#34; for read. Does not exist.&#34;)
        elif self.modeChar.lower() == &#34;w&#34; and os.path.isfile(self.fileName):
            raise Exception(&#34;ERROR: Cowardly not opening &#34; + self.fileName +
                            &#34; for write. File already exists.&#34;)
        elif self.modeChar.lower() not in [&#34;a&#34;, &#34;r&#34;, &#34;w&#34;, &#34;w+&#34;]:
            raise Exception(
                &#34;ERROR: File open mode &#34; +
                self.modeChar +
                &#34; unrecognized.&#34;)

        self.comp_ws = ctypes.c_int(8)
        self.io_ws = ctypes.c_int(io_size)
        self.version = ctypes.c_float(0.0)
        if self.modeChar.lower() in [&#34;a&#34;, &#34;r&#34;]:  # open existing file
            self.fileId = EXODUS_LIB.ex_open_int(self.fileName.encode(&#39;ascii&#39;), self.mode,
                                                 ctypes.byref(self.comp_ws),
                                                 ctypes.byref(self.io_ws),
                                                 ctypes.byref(self.version),
                                                 EX_API_VERSION_NODOT)
        else:  # create file
            if io_size == 0:
                io_size = 8
                self.io_ws = ctypes.c_int(io_size)
            self.__create()

    # --------------------------------------------------------------------

    def __create(self):
        self.fileId = EXODUS_LIB.ex_create_int(self.fileName.encode(&#39;ascii&#39;), self.mode,
                                               ctypes.byref(self.comp_ws),
                                               ctypes.byref(self.io_ws),
                                               EX_API_VERSION_NODOT)

    # --------------------------------------------------------------------

    def __copy_file(self, fileId, include_transient=False):
        if include_transient:
            EXODUS_LIB.ex_copy(self.fileId, fileId)
            EXODUS_LIB.ex_copy_transient(self.fileId, fileId)
        else:
            EXODUS_LIB.ex_copy(self.fileId, fileId)

    # --------------------------------------------------------------------

    def __ex_get_info(self):
        self.Title = ctypes.create_string_buffer(MAX_LINE_LENGTH + 1)
        if EXODUS_LIB.ex_int64_status(self.fileId) &amp; EX_BULK_INT64_API:
            self.numDim = ctypes.c_longlong(0)
            self.numNodes = ctypes.c_longlong(0)
            self.numElem = ctypes.c_longlong(0)
            self.numElemBlk = ctypes.c_longlong(0)
            self.numNodeSets = ctypes.c_longlong(0)
            self.numSideSets = ctypes.c_longlong(0)
            self.numAssembly = ctypes.c_longlong(0)
            self.numBlob = ctypes.c_longlong(0)
        else:
            self.numDim = ctypes.c_int(0)
            self.numNodes = ctypes.c_int(0)
            self.numElem = ctypes.c_int(0)
            self.numElemBlk = ctypes.c_int(0)
            self.numNodeSets = ctypes.c_int(0)
            self.numSideSets = ctypes.c_int(0)
            self.numAssembly = ctypes.c_int(0)
            self.numBlob = ctypes.c_int(0)
        EXODUS_LIB.ex_get_init(
            self.fileId, self.Title,
            ctypes.byref(self.numDim),
            ctypes.byref(self.numNodes),
            ctypes.byref(self.numElem),
            ctypes.byref(self.numElemBlk),
            ctypes.byref(self.numNodeSets),
            ctypes.byref(self.numSideSets))

    # --------------------------------------------------------------------

    def __ex_put_info(self, info):
        self.Title = ctypes.create_string_buffer(info[0].encode(&#39;ascii&#39;), MAX_LINE_LENGTH + 1)
        self.numDim = ctypes.c_longlong(info[1])
        self.numNodes = ctypes.c_longlong(info[2])
        self.numElem = ctypes.c_longlong(info[3])
        self.numElemBlk = ctypes.c_longlong(info[4])
        self.numNodeSets = ctypes.c_longlong(info[5])
        self.numSideSets = ctypes.c_longlong(info[6])
        EXODUS_LIB.ex_put_init(
            self.fileId,
            self.Title,
            self.numDim,
            self.numNodes,
            self.numElem,
            self.numElemBlk,
            self.numNodeSets,
            self.numSideSets)
        self.version = self.__ex_inquire_float(ex_inquiry_map(&#39;EX_INQ_DB_VERS&#39;))

    # --------------------------------------------------------------------

    def __ex_put_concat_elem_blk(self, elemBlkIDs, elemType, numElemThisBlk,
                                 numNodesPerElem, numAttr, defineMaps):
        if EXODUS_LIB.ex_int64_status(self.fileId) &amp; EX_IDS_INT64_API:
            elem_blk_ids = (ctypes.c_longlong * len(elemBlkIDs))()
            elem_blk_ids[:] = elemBlkIDs
            num_elem_this_blk = (ctypes.c_longlong
                                 * len(elemBlkIDs))()
            num_elem_this_blk[:] = numElemThisBlk
            num_nodes_per_elem = (ctypes.c_longlong * len(elemBlkIDs))()
            num_nodes_per_elem[:] = numNodesPerElem
            num_attr = (ctypes.c_longlong * len(elemBlkIDs))()
            num_attr[:] = numAttr
        else:
            elem_blk_ids = (ctypes.c_int * len(elemBlkIDs))()
            elem_blk_ids[:] = elemBlkIDs
            num_elem_this_blk = (ctypes.c_int * len(elemBlkIDs))()
            num_elem_this_blk[:] = numElemThisBlk
            num_nodes_per_elem = (ctypes.c_int * len(elemBlkIDs))()
            num_nodes_per_elem[:] = numNodesPerElem
            num_attr = (ctypes.c_int * len(elemBlkIDs))()
            num_attr[:] = numAttr
        elem_type = (ctypes.c_char_p * len(elemBlkIDs))()
        elem_type[:] = elemType
        define_maps = ctypes.c_int(defineMaps)
        EXODUS_LIB.ex_put_concat_elem_block(
            self.fileId,
            elem_blk_ids,
            elem_type,
            num_elem_this_blk,
            num_nodes_per_elem,
            num_attr,
            define_maps)

    # --------------------------------------------------------------------

    def __ex_get_qa(self):
        num_qa_recs = ctypes.c_int(self.__ex_inquire_int(ex_inquiry_map(&#39;EX_INQ_QA&#39;)))
        qa_rec_ptrs = ((ctypes.POINTER(ctypes.c_char * (MAX_STR_LENGTH + 1)) * 4) * num_qa_recs.value)()
        for i in range(num_qa_recs.value):
            for j in range(4):
                qa_rec_ptrs[i][j] = ctypes.pointer(
                    ctypes.create_string_buffer(MAX_STR_LENGTH + 1))
        if num_qa_recs.value:
            EXODUS_LIB.ex_get_qa(self.fileId, ctypes.byref(qa_rec_ptrs))
        qa_recs = []
        for qara in qa_rec_ptrs:
            qa_rec_list = []
            for ptr in qara:
                qa_rec_list.append(ptr.contents.value.decode(&#34;utf8&#34;))
            qa_rec_tuple = tuple(qa_rec_list)
            assert len(qa_rec_tuple) == 4
            qa_recs.append(qa_rec_tuple)
        return qa_recs

    # --------------------------------------------------------------------

    def __ex_put_qa(self, qaRecs):
        num_qa_recs = ctypes.c_int(len(qaRecs))
        qa_rec_ptrs = ((ctypes.POINTER(ctypes.c_char * (MAX_STR_LENGTH + 1)) * 4) * num_qa_recs.value)()
        for i in range(num_qa_recs.value):
            for j in range(4):
                qa_rec_ptrs[i][j] = ctypes.pointer(ctypes.create_string_buffer(
                    str(qaRecs[i][j]).encode(&#39;ascii&#39;), MAX_STR_LENGTH + 1))
        EXODUS_LIB.ex_put_qa(self.fileId, num_qa_recs, ctypes.byref(qa_rec_ptrs))
        return True

    # --------------------------------------------------------------------

    def _ex_get_info_recs_quietly(self):
        num_infos = ctypes.c_int(self.__ex_inquire_int(ex_inquiry_map(&#39;EX_INQ_INFO&#39;)))
        info_ptrs = (ctypes.POINTER(ctypes.c_char * (MAX_LINE_LENGTH + 1)) * num_infos.value)()
        for i in range(num_infos.value):
            info_ptrs[i] = ctypes.pointer(ctypes.create_string_buffer(MAX_LINE_LENGTH + 1))
        if num_infos.value:
            EXODUS_LIB.ex_get_info(self.fileId, ctypes.byref(info_ptrs))
        info_recs = []
        for irp in info_ptrs:
            info_recs.append(irp.contents.value.decode(&#34;utf8&#34;))
        return info_recs

    # --------------------------------------------------------------------

    def __ex_get_info_recs(self):
        num_infos = ctypes.c_int(self.__ex_inquire_int(ex_inquiry_map(&#39;EX_INQ_INFO&#39;)))
        info_ptrs = (ctypes.POINTER(ctypes.c_char * (MAX_LINE_LENGTH + 1)) * num_infos.value)()
        for i in range(num_infos.value):
            info_ptrs[i] = ctypes.pointer(ctypes.create_string_buffer(MAX_LINE_LENGTH + 1))
        EXODUS_LIB.ex_get_info(self.fileId, ctypes.byref(info_ptrs))
        info_recs = []
        for irp in info_ptrs:
            info_recs.append(irp.contents.value.decode(&#34;utf8&#34;))
        for rec in info_recs:
            if len(rec) &gt; MAX_LINE_LENGTH:
                print(&#34;WARNING: max line length reached for one or more info records;&#34;)
                print(&#34;         info might be incomplete for these records&#34;)
                break
        return info_recs

    # --------------------------------------------------------------------

    def __ex_put_info_recs(self, infoRecs):
        num_infos = ctypes.c_int(len(infoRecs))
        info_ptrs = (ctypes.POINTER(ctypes.c_char * (MAX_LINE_LENGTH + 1)) * num_infos.value)()
        for i in range(num_infos.value):
            info_ptrs[i] = ctypes.pointer(ctypes.create_string_buffer(
                str(infoRecs[i]).encode(&#39;ascii&#39;), MAX_LINE_LENGTH + 1))
        EXODUS_LIB.ex_put_info(self.fileId, num_infos, ctypes.byref(info_ptrs))
        return True

    # --------------------------------------------------------------------

    def __ex_inquire_float(self, inq_id):
        dummy_char = ctypes.create_string_buffer(MAX_LINE_LENGTH + 1)
        ret_float = ctypes.c_float(0.0)
        if EXODUS_LIB.ex_int64_status(self.fileId) &amp; EX_INQ_INT64_API:
            dummy_int = ctypes.c_longlong(0)
        else:
            dummy_int = ctypes.c_int(0)
        val = EXODUS_LIB.ex_inquire(
            self.fileId,
            inq_id,
            ctypes.byref(dummy_int),
            ctypes.byref(ret_float),
            dummy_char)
        if val &lt; 0:
            raise Exception(
                &#34;ERROR: ex_inquire(&#34; +
                str(inq_id) +
                &#34;) failed on &#34; +
                self.fileName)
        return ret_float

    # --------------------------------------------------------------------

    def __ex_inquire_int(self, inq_id):
        val = EXODUS_LIB.ex_inquire_int(self.fileId, inq_id)
        if val &lt; 0:
            raise Exception(
                &#34;ERROR: ex_inquire_int(&#34; +
                str(inq_id) +
                &#34;) failed on &#34; +
                self.fileName)
        return val

    # --------------------------------------------------------------------

    def __ex_get_coord_names(self):
        coord_name_ptrs = (
            ctypes.POINTER(ctypes.c_char * (MAX_NAME_LENGTH + 1)) * self.numDim.value)()
        for i in range(self.numDim.value):
            coord_name_ptrs[i] = ctypes.pointer(
                ctypes.create_string_buffer(
                    MAX_NAME_LENGTH + 1))
        EXODUS_LIB.ex_get_coord_names(self.fileId, ctypes.byref(coord_name_ptrs))
        coord_names = []
        for cnp in coord_name_ptrs:
            coord_names.append(cnp.contents.value.decode(&#39;utf8&#39;))
        return coord_names

    # --------------------------------------------------------------------

    def __ex_put_coord_names(self, names):
        coord_name_ptrs = (
            ctypes.POINTER(ctypes.c_char * (MAX_NAME_LENGTH + 1)) * self.numDim.value)()
        assert len(names) == self.numDim.value
        for i in range(self.numDim.value):
            coord_name_ptrs[i] = ctypes.pointer(
                ctypes.create_string_buffer(
                    names[i].encode(&#39;ascii&#39;), MAX_NAME_LENGTH + 1))
        EXODUS_LIB.ex_put_coord_names(self.fileId, ctypes.byref(coord_name_ptrs))

    # --------------------------------------------------------------------

    def __ex_get_all_times(self):
        self.times = (ctypes.c_double * self.numTimes.value)()
        EXODUS_LIB.ex_get_all_times(self.fileId, ctypes.byref(self.times))

    # --------------------------------------------------------------------

    def __ex_get_time(self, timeStep):
        time_step = ctypes.c_int(timeStep)
        time_val = ctypes.c_double(0.0)
        EXODUS_LIB.ex_get_time(self.fileId, time_step, ctypes.byref(time_val))
        return time_val.value()

    # --------------------------------------------------------------------

    def __ex_put_time(self, timeStep, timeVal):
        time_step = ctypes.c_int(timeStep)
        time_val = ctypes.c_double(timeVal)
        EXODUS_LIB.ex_put_time(self.fileId, time_step, ctypes.byref(time_val))
        return True

    # --------------------------------------------------------------------

    def __ex_get_name(self, objType, objId):
        obj_type = ctypes.c_int(get_entity_type(objType))
        obj_id = ctypes.c_longlong(objId)
        obj_name = ctypes.create_string_buffer(MAX_NAME_LENGTH + 1)
        EXODUS_LIB.ex_get_name(self.fileId, obj_type, obj_id, ctypes.byref(obj_name))
        return obj_name.value.decode(&#39;utf8&#39;)

    # --------------------------------------------------------------------

    def __ex_put_name(self, objType, objId, objName):
        obj_type = ctypes.c_int(get_entity_type(objType))
        obj_id = ctypes.c_longlong(objId)
        obj_name = ctypes.create_string_buffer(objName.encode(&#39;ascii&#39;), MAX_NAME_LENGTH + 1)
        EXODUS_LIB.ex_put_name(self.fileId, obj_type, obj_id, obj_name)

    # --------------------------------------------------------------------

    def __ex_get_names(self, objType):
        inqType = ex_inquiry_map(ex_obj_to_inq(objType))
        num_objs = ctypes.c_int(self.__ex_inquire_int(inqType)).value
        obj_name_ptrs = (ctypes.POINTER(ctypes.c_char * (MAX_NAME_LENGTH + 1)) * num_objs)()
        for i in range(num_objs):
            obj_type = ctypes.c_int(get_entity_type(objType))
            obj_name_ptrs[i] = ctypes.pointer(
                    ctypes.create_string_buffer(
                            MAX_NAME_LENGTH + 1))

        EXODUS_LIB.ex_get_names(self.fileId, obj_type, ctypes.byref(obj_name_ptrs))
        obj_names = []
        for onp in obj_name_ptrs:
            obj_names.append(onp.contents.value.decode(&#39;utf8&#39;))
        return obj_names

    # --------------------------------------------------------------------

    def __ex_put_names(self, objType, objNames):
        inqType = ex_inquiry_map(ex_obj_to_inq(objType))
        numObjs = ctypes.c_int(self.__ex_inquire_int(inqType)).value
        assert numObjs == len(objNames)
        obj_name_ptrs = (ctypes.POINTER(ctypes.c_char * (MAX_NAME_LENGTH + 1)) * numObjs)()
        obj_type = ctypes.c_int(get_entity_type(objType))
        for i in range(numObjs):
            obj_name_ptrs[i] = ctypes.pointer(
                ctypes.create_string_buffer(
                    objNames[i].encode(&#39;ascii&#39;), MAX_NAME_LENGTH + 1))
        EXODUS_LIB.ex_put_names(self.fileId, obj_type, ctypes.byref(obj_name_ptrs))

    # --------------------------------------------------------------------

    def __ex_get_ids(self, objType):
        inqType = ex_inquiry_map(ex_obj_to_inq(objType))
        numObjs = ctypes.c_int(self.__ex_inquire_int(inqType)).value
        if EXODUS_LIB.ex_int64_status(self.fileId) &amp; EX_IDS_INT64_API:
            ids = (ctypes.c_longlong * numObjs)()
        else:
            ids = (ctypes.c_int * numObjs)()
        if numObjs &gt; 0:
            obj_type = ctypes.c_int(get_entity_type(objType))
            EXODUS_LIB.ex_get_ids(self.fileId, obj_type, ctypes.byref(ids))
        return ids

    # --------------------------------------------------------------------

    def __ex_get_assembly(self, assem_struct):
        EXODUS_LIB.ex_get_assembly(self.fileId, ctypes.byref(assem_struct))
        ptr = ctypes.create_string_buffer(MAX_NAME_LENGTH+1)
        assem_struct.name = ctypes.cast(ptr, ctypes.c_char_p)
        eptr = (ctypes.c_longlong * assem_struct.entity_count)()
        assem_struct.entity_list = eptr
        EXODUS_LIB.ex_get_assembly(self.fileId, ctypes.byref(assem_struct))

    # --------------------------------------------------------------------

    def __ex_get_assemblies(self, assem_list):
        EXODUS_LIB.ex_get_assemblies(self.fileId, assem_list)
        for assem_struct in assem_list:
            ptr = ctypes.create_string_buffer(MAX_NAME_LENGTH + 1)
            assem_struct.name = ctypes.cast(ptr, ctypes.c_char_p)
            eptr = (ctypes.c_longlong * assem_struct.entity_count)()
            assem_struct.entity_list = eptr
        EXODUS_LIB.ex_get_assemblies(self.fileId, assem_list)

    # --------------------------------------------------------------------

    def __ex_get_blob(self, blob_struct):
        EXODUS_LIB.ex_get_blob(self.fileId, ctypes.byref(blob_struct))
        ptr = ctypes.create_string_buffer(MAX_NAME_LENGTH+1)
        blob_struct.name = ctypes.cast(ptr, ctypes.c_char_p)
        EXODUS_LIB.ex_get_blob(self.fileId, ctypes.byref(blob_struct))


    # --------------------------------------------------------------------

    def __ex_put_assembly(self, assembly):
        assem = setup_ex_assembly(assembly)
        EXODUS_LIB.ex_put_assembly(self.fileId, assem)

    # --------------------------------------------------------------------

    def __ex_put_assemblies(self, assemblies):
        assembly_list = []
        for assembly in assemblies:
            assem = setup_ex_assembly(assembly)
            assembly_list.append(assem)
        assems = (ex_assembly * len(assemblies))(*assembly_list)

        EXODUS_LIB.ex_put_assemblies(self.fileId, len(assembly_list), assems)


    # --------------------------------------------------------------------

    def __ex_get_attributes(self, objType, objId):
        # Get attribute count...
        obj_type = ctypes.c_int(get_entity_type(objType))
        obj_id = ctypes.c_longlong(objId)
        att_count = EXODUS_LIB.ex_get_attribute_count(self.fileId, obj_type, obj_id)

        attributes = dict()
        if att_count &gt; 0:
            att = (ex_attribute * att_count)()
            EXODUS_LIB.ex_get_attribute_param(self.fileId, obj_type, obj_id, ctypes.byref(att))
            for i in range(att_count):
                EXODUS_LIB.ex_get_attribute(self.fileId, ctypes.byref(att[i]))
                tmp_att = attribute(att[i].name.decode(&#39;utf8&#39;), ex_obj_to_name(att[i].entity_type), att[i].entity_id)

                if (att[i].type == 2):
                    vals = ctypes.cast(att[i].values, ctypes.POINTER(ctypes.c_char))
                    tmp = []
                    for j in range(att[i].value_count-1):
                        tmp.append(vals[j])
                    tmp_att.values = b&#39;&#39;.join(tmp).decode(&#39;utf8&#39;)

                if (att[i].type == 4):
                    vals = ctypes.cast(att[i].values, ctypes.POINTER(ctypes.c_int))
                    for j in range(att[i].value_count):
                        tmp_att.values.append(vals[j])

                if (att[i].type == 6):
                    vals = ctypes.cast(att[i].values, ctypes.POINTER(ctypes.c_double))
                    for j in range(att[i].value_count):
                        tmp_att.values.append(vals[j])

                attributes[att[i].name.decode(&#39;utf8&#39;)] = tmp_att

        return attributes

    # --------------------------------------------------------------------

    def __ex_put_attribute(self, attribute):
        att_id = ctypes.c_longlong(attribute.entity_id)
        att = ex_attribute(entity_id=att_id)
        att.name = attribute.name.encode(&#39;ascii&#39;)
        att.entity_type = ctypes.c_int(get_entity_type(attribute.entity_type))
        att.value_count = len(attribute.values)

        if (isinstance(attribute.values[0], int)):
            eptr = (c_int * len(attribute.values))()
            for i in range(len(attribute.values)):
               eptr[i] = ctypes.c_int(attribute.values[i])
            att.values = ctypes.cast(eptr, ctypes.c_void_p)
            att.type = 4

        elif (isinstance(attribute.values[0], float)):
            eptr = (c_double * len(attribute.values))()
            for i in range(len(attribute.values)):
              eptr[i] = ctypes.c_double(attribute.values[i])
            att.values = ctypes.cast(eptr, ctypes.c_void_p)
            att.type = 6

        elif (isinstance(attribute.values[0], str)):
            eptr = (c_char * (len(attribute.values)+1))()
            eptr = attribute.values[0].encode(&#39;ascii&#39;)
            att.values = ctypes.cast(eptr, ctypes.c_void_p)
            att.type = 2

        EXODUS_LIB.ex_put_attribute(self.fileId, att)

    # --------------------------------------------------------------------

    def __ex_get_node_set(self, nodeSetId):
        node_set_id = ctypes.c_longlong(nodeSetId)
        num_node_set_nodes = self.__ex_get_set_param(&#39;EX_NODE_SET&#39;, nodeSetId)[0]
        if num_node_set_nodes == 0:
            return []
        if EXODUS_LIB.ex_int64_status(self.fileId) &amp; EX_BULK_INT64_API:
            set_nodes = (ctypes.c_longlong * num_node_set_nodes)()
        else:
            set_nodes = (ctypes.c_int * num_node_set_nodes)()
        EXODUS_LIB.ex_get_node_set(self.fileId, node_set_id, ctypes.byref(set_nodes))
        return set_nodes

    # --------------------------------------------------------------------

    def __ex_put_node_set(self, nodeSetId, nodeSetNodes):
        node_set_id = ctypes.c_longlong(nodeSetId)
        if EXODUS_LIB.ex_int64_status(self.fileId) &amp; EX_BULK_INT64_API:
            node_set_nodes = (ctypes.c_longlong * len(nodeSetNodes))()
            for i, node_set_node in enumerate(nodeSetNodes):
                node_set_nodes[i] = ctypes.c_longlong(node_set_node)
        else:
            node_set_nodes = (ctypes.c_int * len(nodeSetNodes))()
            for i, node_set_node in enumerate(nodeSetNodes):
                node_set_nodes[i] = ctypes.c_int(node_set_node)
        EXODUS_LIB.ex_put_node_set(self.fileId, node_set_id, node_set_nodes)

    # --------------------------------------------------------------------

    def __ex_get_node_set_dist_fact(self, nodeSetId):
        node_set_id = ctypes.c_longlong(nodeSetId)
        num_node_set_nodes = self.__ex_get_set_param(&#39;EX_NODE_SET&#39;, nodeSetId)[0]
        set_dfs = (ctypes.c_double * num_node_set_nodes)()
        EXODUS_LIB.ex_get_node_set_dist_fact(
            self.fileId, node_set_id, ctypes.byref(set_dfs))
        return set_dfs

    # --------------------------------------------------------------------

    def __ex_put_node_set_dist_fact(self, nodeSetId, nodeSetDistFact):
        node_set_id = ctypes.c_longlong(nodeSetId)
        node_set_dist_fact = (ctypes.c_double * len(nodeSetDistFact))()
        for i, dist_fact in enumerate(nodeSetDistFact):
            node_set_dist_fact[i] = ctypes.c_double(dist_fact)
        EXODUS_LIB.ex_put_node_set_dist_fact(
            self.fileId, node_set_id, node_set_dist_fact)

    # --------------------------------------------------------------------

    def __ex_get_object_truth_vector(self, objType, entId):
        obj_type = ctypes.c_int(get_entity_type(objType))
        entity_id = ctypes.c_longlong(entId)
        variable_count = self.__ex_get_variable_param(objType)
        truth_table = (ctypes.c_int * (variable_count.value))()

        EXODUS_LIB.ex_get_object_truth_vector(self.fileId, obj_type,
                                              entity_id, variable_count,
                                              ctypes.byref(truth_table))
        truthTab = []
        for val in truth_table:
            if val:
                truthTab.append(True)
            else:
                truthTab.append(False)
        return truthTab

    # --------------------------------------------------------------------

    def __ex_get_truth_table(self, objType):
        inqType = ex_inquiry_map(ex_obj_to_inq(objType))
        num_objs = ctypes.c_int(self.__ex_inquire_int(inqType)).value

        obj_type = ctypes.c_int(get_entity_type(objType))
        variable_count = self.__ex_get_variable_param(objType)

        truth_table = (ctypes.c_int * (num_objs * variable_count.value))()
        EXODUS_LIB.ex_get_truth_table(self.fileId, obj_type,
                                      num_objs, variable_count,
                                      ctypes.byref(truth_table))
        truthTab = []
        for val in truth_table:
            if val:
                truthTab.append(True)
            else:
                truthTab.append(False)
        return truthTab

    # --------------------------------------------------------------------

    def __ex_put_truth_table(self, objType, truthTab):
        inqType = ex_inquiry_map(ex_obj_to_inq(objType))
        num_objs = ctypes.c_int(self.__ex_inquire_int(inqType)).value

        obj_type = ctypes.c_int(get_entity_type(objType))
        num_vars = self.__ex_get_variable_param(objType).value

        assert len(truthTab) == (num_objs * num_vars)

        truth_tab = (ctypes.c_int * (num_objs * num_vars))()
        for i, boolVal in enumerate(truthTab):
            if boolVal:
                truth_tab[i] = ctypes.c_int(1)
            else:
                truth_tab[i] = ctypes.c_int(0)

        EXODUS_LIB.ex_put_truth_table(
            self.fileId, obj_type, num_objs, num_vars, truth_tab)
        return True

    # --------------------------------------------------------------------

    def __ex_get_coord(self):
        self.coordsX = (ctypes.c_double * self.numNodes.value)()
        self.coordsY = (ctypes.c_double * self.numNodes.value)()
        self.coordsZ = (ctypes.c_double * self.numNodes.value)()
        EXODUS_LIB.ex_get_coord(
            self.fileId,
            ctypes.byref(self.coordsX),
            ctypes.byref(self.coordsY),
            ctypes.byref(self.coordsZ))

    # --------------------------------------------------------------------

    def __ex_put_coord(self, xCoords, yCoords, zCoords):
        self.coordsX = (ctypes.c_double * self.numNodes.value)()
        self.coordsY = (ctypes.c_double * self.numNodes.value)()
        self.coordsZ = (ctypes.c_double * self.numNodes.value)()
        for i in range(self.numNodes.value):
            self.coordsX[i] = float(xCoords[i])
            self.coordsY[i] = float(yCoords[i])
            self.coordsZ[i] = float(zCoords[i])
        EXODUS_LIB.ex_put_coord(
            self.fileId,
            ctypes.byref(self.coordsX),
            ctypes.byref(self.coordsY),
            ctypes.byref(self.coordsZ))

    # --------------------------------------------------------------------

    def __ex_get_partial_coord(self, startNodeId, numNodes):
        start_node_num = ctypes.c_longlong(startNodeId)
        num_nodes = ctypes.c_longlong(numNodes)
        coordsX = (ctypes.c_double * numNodes)()
        coordsY = (ctypes.c_double * numNodes)()
        coordsZ = (ctypes.c_double * numNodes)()
        EXODUS_LIB.ex_get_partial_coord(
            self.fileId,
            start_node_num,
            num_nodes,
            ctypes.byref(coordsX),
            ctypes.byref(coordsY),
            ctypes.byref(coordsZ))
        return list(coordsX), list(coordsY), list(coordsZ)

    # --------------------------------------------------------------------

    def __ex_get_id_map(self, objType):
        inqType = ex_obj_to_inq(objType)
        obj_type = ctypes.c_int(get_entity_type(objType))
        inq_type = ctypes.c_int(ex_inquiry_map(inqType))
        num_objs = ctypes.c_int(self.__ex_inquire_int(inq_type))
        numObjs = num_objs.value
        if EXODUS_LIB.ex_int64_status(self.fileId) &amp; EX_IDS_INT64_API:
            id_map = (ctypes.c_longlong * numObjs)()
        else:
            id_map = (ctypes.c_int * numObjs)()
        EXODUS_LIB.ex_get_id_map(self.fileId, obj_type, ctypes.byref(id_map))
        idMap = []
        for i in range(numObjs):
            idMap.append(id_map[i])
        if self.use_numpy:
            idMap = self.np.array(idMap)
        return idMap

    # --------------------------------------------------------------------

    def __ex_get_block_id_map(self, obj_type, id):
        obj_type = ctypes.c_int(get_entity_type(obj_type))
        entity_id = ctypes.c_longlong(id)
        _, numObjs,_,_ = self.__ex_get_block(&#39;EX_ELEM_BLOCK&#39;, id)
        if EXODUS_LIB.ex_int64_status(self.fileId) &amp; EX_IDS_INT64_API:
            id_map = (ctypes.c_longlong * numObjs.value)()
        else:
            id_map = (ctypes.c_int * numObjs.value)()
        EXODUS_LIB.ex_get_block_id_map(self.fileId, obj_type, entity_id, id_map)
        if self.use_numpy:
            id_map = ctype_to_numpy(self, id_map)
        return id_map

    # --------------------------------------------------------------------

    def __ex_put_id_map(self, objType, idMap):
        inqType = ex_obj_to_inq(objType)
        obj_type = ctypes.c_int(get_entity_type(objType))
        inq_type = ctypes.c_int(ex_inquiry_map(inqType))
        num_objs = ctypes.c_int(self.__ex_inquire_int(inq_type))
        numObjs = num_objs.value
        assert numObjs == len(idMap)
        if EXODUS_LIB.ex_int64_status(self.fileId) &amp; EX_IDS_INT64_API:
            id_map = (ctypes.c_longlong * numObjs)()
            for i in range(numObjs):
                id_map[i] = ctypes.c_longlong(idMap[i])
        else:
            id_map = (ctypes.c_int * numObjs)()
            for i in range(numObjs):
                id_map[i] = ctypes.c_int(idMap[i])
        EXODUS_LIB.ex_put_id_map(self.fileId, obj_type, ctypes.byref(id_map))
        return True

    # --------------------------------------------------------------------

    def __ex_get_elem_num_map(self):
        if EXODUS_LIB.ex_int64_status(self.fileId) &amp; EX_MAPS_INT64_API:
            elemNumMap = (ctypes.c_longlong * self.numElem.value)()
        else:
            elemNumMap = (ctypes.c_int * self.numElem.value)()
        EXODUS_LIB.ex_get_elem_num_map(self.fileId, ctypes.byref(elemNumMap))
        return elemNumMap

    # --------------------------------------------------------------------

    def __ex_get_node_num_map(self):
        if EXODUS_LIB.ex_int64_status(self.fileId) &amp; EX_MAPS_INT64_API:
            nodeNumMap = (ctypes.c_longlong * self.numNodes.value)()
        else:
            nodeNumMap = (ctypes.c_int * self.numNodes.value)()
        EXODUS_LIB.ex_get_node_num_map(self.fileId, ctypes.byref(nodeNumMap))
        return nodeNumMap

    # --------------------------------------------------------------------

    def __ex_get_elem_order_map(self):
        if EXODUS_LIB.ex_int64_status(self.fileId) &amp; EX_MAPS_INT64_API:
            elemOrderMap = (ctypes.c_longlong * self.numElem.value)()
        else:
            elemOrderMap = (ctypes.c_int * self.numElem.value)()
        EXODUS_LIB.ex_get_map(self.fileId, ctypes.byref(elemOrderMap))
        return elemOrderMap

    # --------------------------------------------------------------------

    def __ex_get_block(self, object_type, object_id):
        obj_type = ctypes.c_int(get_entity_type(object_type))
        block_id = ctypes.c_longlong(object_id)
        blk_type = ctypes.create_string_buffer(MAX_STR_LENGTH + 1)
        if EXODUS_LIB.ex_int64_status(self.fileId) &amp; EX_BULK_INT64_API:
            num_elem_this_blk = ctypes.c_longlong(0)
            num_nodes_per_elem = ctypes.c_longlong(0)
            num_edges_per_elem = ctypes.c_longlong(0)
            num_faces_per_elem = ctypes.c_longlong(0)
            num_attr = ctypes.c_longlong(0)
        else:
            num_elem_this_blk = ctypes.c_int(0)
            num_nodes_per_elem = ctypes.c_int(0)
            num_edges_per_elem = ctypes.c_int(0)
            num_faces_per_elem = ctypes.c_int(0)
            num_attr = ctypes.c_int(0)
        EXODUS_LIB.ex_get_block(
            self.fileId,
            obj_type,
            block_id,
            blk_type,
            ctypes.byref(num_elem_this_blk),
            ctypes.byref(num_nodes_per_elem),
            ctypes.byref(num_edges_per_elem),
            ctypes.byref(num_faces_per_elem),
            ctypes.byref(num_attr))
        return blk_type, num_elem_this_blk, num_nodes_per_elem, num_attr

    # --------------------------------------------------------------------

    def __ex_put_block(
            self,
            object_type,
            object_id,
            eType,
            numElems,
            numNodesPerElem,
            numAttrsPerElem):
        obj_type = ctypes.c_int(get_entity_type(object_type))
        block_id = ctypes.c_longlong(object_id)
        if type(eType) == str:
            eType = eType.encode(&#39;ascii&#39;)
        elem_type = ctypes.create_string_buffer(eType.upper(), MAX_NAME_LENGTH + 1)
        num_elem_this_blk = ctypes.c_longlong(numElems)
        num_nodes_per_elem = ctypes.c_longlong(numNodesPerElem)
        num_edges_per_elem = ctypes.c_longlong(0)
        num_faces_per_elem = ctypes.c_longlong(0)
        num_attr = ctypes.c_longlong(numAttrsPerElem)
        EXODUS_LIB.ex_put_block(self.fileId, obj_type, block_id, elem_type,
                                num_elem_this_blk, num_nodes_per_elem,
                                num_edges_per_elem, num_faces_per_elem, num_attr)

    # --------------------------------------------------------------------

    def __ex_get_elem_conn(self, object_id):
        (_elem_type, num_elem_this_blk, num_nodes_per_elem,
         _num_attr) = self.__ex_get_block(&#39;EX_ELEM_BLOCK&#39;, object_id)
        elem_block_id = ctypes.c_longlong(object_id)
        if EXODUS_LIB.ex_int64_status(self.fileId) &amp; EX_BULK_INT64_API:
            elem_block_connectivity = (
                ctypes.c_longlong * (num_elem_this_blk.value * num_nodes_per_elem.value))()
        else:
            elem_block_connectivity = (
                ctypes.c_int * (num_elem_this_blk.value * num_nodes_per_elem.value))()
        EXODUS_LIB.ex_get_elem_conn(
            self.fileId,
            elem_block_id,
            ctypes.byref(elem_block_connectivity))
        return elem_block_connectivity, num_elem_this_blk, num_nodes_per_elem

    # --------------------------------------------------------------------

    def __ex_put_elem_conn(self, object_id, connectivity):
        (_elem_type, num_elem_this_blk, num_nodes_per_elem,
         _num_attr) = self.__ex_get_block(&#39;EX_ELEM_BLOCK&#39;, object_id)
        elem_block_id = ctypes.c_longlong(object_id)
        if EXODUS_LIB.ex_int64_status(self.fileId) &amp; EX_BULK_INT64_API:
            elem_block_connectivity = (
                ctypes.c_longlong * (num_elem_this_blk.value * num_nodes_per_elem.value))()
            for i in range(num_elem_this_blk.value * num_nodes_per_elem.value):
                elem_block_connectivity[i] = ctypes.c_longlong(connectivity[i])
        else:
            elem_block_connectivity = (
                ctypes.c_int * (num_elem_this_blk.value * num_nodes_per_elem.value))()
            for i in range(num_elem_this_blk.value * num_nodes_per_elem.value):
                elem_block_connectivity[i] = ctypes.c_int(connectivity[i])
        EXODUS_LIB.ex_put_elem_conn(
            self.fileId,
            elem_block_id,
            elem_block_connectivity)

    # --------------------------------------------------------------------

    def __ex_put_one_attr(self, objType, elemBlkID, attrIndx, Attr):
        elem_blk_id = ctypes.c_longlong(elemBlkID)
        obj_type = ctypes.c_int(objType)
        attr_index = ctypes.c_longlong(attrIndx)
        attrib = (ctypes.c_double * len(Attr))()
        for i, attr in enumerate(Attr):
            attrib[i] = float(attr)
        EXODUS_LIB.ex_put_one_attr(
            self.fileId,
            obj_type,
            elem_blk_id,
            attr_index,
            attrib)

    # --------------------------------------------------------------------

    def __ex_get_one_attr(self, objType, elemBlkID, attrIndx):
        elem_blk_id = ctypes.c_longlong(elemBlkID)
        obj_type = ctypes.c_int(objType)
        attr_index = ctypes.c_longlong(attrIndx)
        inqType = ex_inquiry_map(ex_obj_to_inq(objType))
        num_objs = ctypes.c_int(self.__ex_inquire_int(inqType)).value
        attrib = (ctypes.c_double * num_objs)()
        EXODUS_LIB.ex_get_one_attr(
            self.fileId,
            obj_type,
            elem_blk_id,
            attr_index,
            ctypes.byref(attrib))
        return attrib

    # --------------------------------------------------------------------

    def __ex_put_elem_attr(self, elemBlkID, Attr):
        elem_blk_id = ctypes.c_longlong(elemBlkID)
        attrib = (ctypes.c_double * len(Attr))()
        for i, attr in enumerate(Attr):
            attrib[i] = ctypes.c_double(attr)
        EXODUS_LIB.ex_put_attr(
            self.fileId,
            ctypes.c_int(get_entity_type(&#39;EX_ELEM_BLOCK&#39;)),
            elem_blk_id,
            attrib)

    # --------------------------------------------------------------------

    def __ex_get_elem_attr(self, elemBlkID):
        elem_blk_id = ctypes.c_longlong(elemBlkID)
        numAttrThisBlk = self.num_attr(elemBlkID)
        numElemsThisBlk = self.num_elems_in_blk(elemBlkID)
        totalAttr = numAttrThisBlk * numElemsThisBlk
        attrib = (ctypes.c_double * totalAttr)()
        EXODUS_LIB.ex_get_attr(
            self.fileId,
            ctypes.c_int(get_entity_type(&#39;EX_ELEM_BLOCK&#39;)),
            elem_blk_id,
            ctypes.byref(attrib))
        return attrib

    # --------------------------------------------------------------------

    def __ex_get_variable_param(self, varType):
        var_type = ctypes.c_int(get_entity_type(varType))
        num_vars = ctypes.c_int()
        EXODUS_LIB.ex_get_variable_param(
            self.fileId, var_type, ctypes.byref(num_vars))
        return num_vars

    # --------------------------------------------------------------------

    def __ex_get_variable_names(self, varType):
        num_vars = self.__ex_get_variable_param(varType)
        var_name_ptrs = (
            ctypes.POINTER(ctypes.c_char * (MAX_NAME_LENGTH + 1)) * num_vars.value)()

        for i in range(num_vars.value):
            var_name_ptrs[i] = ctypes.pointer(
                ctypes.create_string_buffer(
                    MAX_NAME_LENGTH + 1))

        var_type = ctypes.c_int(get_entity_type(varType))
        EXODUS_LIB.ex_get_variable_names(
            self.fileId,
            var_type,
            num_vars,
            ctypes.byref(var_name_ptrs))
        var_names = []
        for vnp in var_name_ptrs:
            var_names.append(vnp.contents.value.decode(&#39;utf8&#39;))
        return var_names

    # --------------------------------------------------------------------

    def __ex_get_var(self, timeStep, varType, varId, blkId, numValues):
        step = ctypes.c_int(timeStep)
        var_type = ctypes.c_int(get_entity_type(varType))
        var_id = ctypes.c_int(varId)
        block_id = ctypes.c_longlong(blkId)
        num_values = ctypes.c_longlong(numValues)
        var_vals = (ctypes.c_double * num_values.value)()
        EXODUS_LIB.ex_get_var(
            self.fileId,
            step,
            var_type,
            var_id,
            block_id,
            num_values,
            var_vals)
        return var_vals

    # --------------------------------------------------------------------

    def __ex_get_partial_var(self, timeStep, varType, varId, blkId, startIndex, numValues):
        step = ctypes.c_int(timeStep)
        var_type = ctypes.c_int(get_entity_type(varType))
        var_id = ctypes.c_int(varId)
        block_id = ctypes.c_longlong(blkId)
        start_index = ctypes.c_longlong(startIndex)
        num_values = ctypes.c_longlong(numValues)
        var_vals = (ctypes.c_double * num_values.value)()
        EXODUS_LIB.ex_get_var(
            self.fileId,
            step,
            var_type,
            var_id,
            block_id,
            start_index,
            num_values,
            var_vals)
        return var_vals

    # --------------------------------------------------------------------

    def __ex_put_var(self, timeStep, varType, varId, blkId, numValues, values):
        step = ctypes.c_int(timeStep)
        var_type = ctypes.c_int(get_entity_type(varType))
        var_id = ctypes.c_int(varId)
        block_id = ctypes.c_longlong(blkId)
        num_values = ctypes.c_longlong(numValues)
        var_vals = (ctypes.c_double * num_values.value)()
        for i in range(num_values.value):
            var_vals[i] = float(values[i])
        EXODUS_LIB.ex_put_var(
            self.fileId,
            step,
            var_type,
            var_id,
            block_id,
            num_values,
            var_vals)
        return True

    # --------------------------------------------------------------------

    def __ex_put_reduction_variable_param(self, varType, numVars):
        num_vars = ctypes.c_int(numVars)
        current_num = self.__ex_get_reduction_variable_param(varType)
        if current_num.value == num_vars.value:
            # print &#34;value already set&#34;
            return True

        var_type = ctypes.c_int(get_entity_type(varType))
        errorInt = EXODUS_LIB.ex_put_reduction_variable_param(
            self.fileId, var_type, num_vars)
        if errorInt != 0:
            print((&#34;ERROR code =&#34;, errorInt))
            raise Exception(
                &#34;ERROR: ex_put_reduction_variable_param had problems.&#34;
                &#34; This can only be called once per varType.&#34;)
        return True

    # --------------------------------------------------------------------

    def __ex_get_reduction_variable_param(self, varType):
        var_type = ctypes.c_int(get_entity_type(varType))
        num_vars = ctypes.c_int()
        EXODUS_LIB.ex_get_reduction_variable_param(
            self.fileId, var_type, ctypes.byref(num_vars))
        return num_vars

    # --------------------------------------------------------------------

    def __ex_get_reduction_variable_name(self, varType, varId):
        var_type = ctypes.c_int(get_entity_type(varType))
        var_id = ctypes.c_int(varId)
        name = ctypes.create_string_buffer(MAX_NAME_LENGTH + 1)
        EXODUS_LIB.ex_get_reduction_variable_name(self.fileId, var_type, var_id, name)
        return name.value.decode(&#34;utf8&#34;)

    # --------------------------------------------------------------------

    def __ex_put_reduction_variable_name(self, varType, varId, varName):
        var_type = ctypes.c_int(get_entity_type(varType))
        var_id = ctypes.c_int(varId)
        name = ctypes.create_string_buffer(varName.encode(&#39;ascii&#39;), MAX_NAME_LENGTH + 1)
        EXODUS_LIB.ex_put_reduction_variable_name(self.fileId, var_type, var_id, name)
        return True

    # --------------------------------------------------------------------

    def __ex_get_reduction_variable_names(self, varType):
        num_vars = self.__ex_get_reduction_variable_param(varType)
        var_name_ptrs = (
            ctypes.POINTER(ctypes.c_char * (MAX_NAME_LENGTH + 1)) * num_vars.value)()

        for i in range(num_vars.value):
            var_name_ptrs[i] = ctypes.pointer(
                ctypes.create_string_buffer(
                    MAX_NAME_LENGTH + 1))

        var_type = ctypes.c_int(get_entity_type(varType))
        EXODUS_LIB.ex_get_reduction_variable_names(
            self.fileId,
            var_type,
            num_vars,
            ctypes.byref(var_name_ptrs))
        var_names = []
        for vnp in var_name_ptrs:
            var_names.append(vnp.contents.value.decode(&#39;utf8&#39;))
        return var_names

    # --------------------------------------------------------------------

    def __ex_get_reduction_vars(self, timeStep, varType, blkId, numValues):
        step = ctypes.c_int(timeStep)
        var_type = ctypes.c_int(get_entity_type(varType))
        block_id = ctypes.c_longlong(blkId)
        num_values = ctypes.c_longlong(numValues)
        var_vals = (ctypes.c_double * num_values.value)()
        EXODUS_LIB.ex_get_reduction_vars(
            self.fileId,
            step,
            var_type,
            block_id,
            num_values,
            var_vals)
        return var_vals

    # --------------------------------------------------------------------

    def __ex_put_reduction_vars(self, timeStep, varType, blkId, numValues, values):
        step = ctypes.c_int(timeStep)
        var_type = ctypes.c_int(get_entity_type(varType))
        block_id = ctypes.c_longlong(blkId)
        num_values = ctypes.c_longlong(numValues)
        var_vals = (ctypes.c_double * num_values.value)()
        for i in range(num_values.value):
            var_vals[i] = float(values[i])
        EXODUS_LIB.ex_put_reduction_vars(
            self.fileId,
            step,
            var_type,
            block_id,
            num_values,
            var_vals)
        return True

    # --------------------------------------------------------------------

    def __ex_get_side_set_node_list_len(self, object_id):
        side_set_id = ctypes.c_longlong(object_id)
        if EXODUS_LIB.ex_int64_status(self.fileId) &amp; EX_BULK_INT64_API:
            side_set_node_list_len = ctypes.c_longlong(0)
        else:
            side_set_node_list_len = ctypes.c_int(0)
        EXODUS_LIB.ex_get_side_set_node_list_len(
            self.fileId, side_set_id, ctypes.byref(side_set_node_list_len))
        return side_set_node_list_len

    # --------------------------------------------------------------------

    def __ex_get_set_param(self, objType, object_id):
        object_type = ctypes.c_int(get_entity_type(objType))
        side_set_id = ctypes.c_longlong(object_id)
        if EXODUS_LIB.ex_int64_status(self.fileId) &amp; EX_BULK_INT64_API:
            num_side_in_set = ctypes.c_longlong(0)
            num_dist_fact_in_set = ctypes.c_longlong(0)
        else:
            num_side_in_set = ctypes.c_int(0)
            num_dist_fact_in_set = ctypes.c_int(0)
        EXODUS_LIB.ex_get_set_param(
            self.fileId,
            object_type,
            side_set_id,
            ctypes.byref(num_side_in_set),
            ctypes.byref(num_dist_fact_in_set))
        return int(num_side_in_set.value), int(num_dist_fact_in_set.value)

    # --------------------------------------------------------------------

    def __ex_put_set_param(self, objType, object_id, numSides, numDistFacts):
        object_type = ctypes.c_int(get_entity_type(objType))
        side_set_id = ctypes.c_longlong(object_id)
        num_side_in_set = ctypes.c_longlong(numSides)
        num_dist_fact_in_set = ctypes.c_longlong(numDistFacts)
        EXODUS_LIB.ex_put_set_param(
            self.fileId,
            object_type,
            side_set_id,
            num_side_in_set,
            num_dist_fact_in_set)
        return True

    # --------------------------------------------------------------------

    def __ex_get_side_set(self, sideSetId):
        side_set_id = ctypes.c_longlong(sideSetId)
        (num_side_in_set, _num_dist_fact_in_set) = self.__ex_get_set_param(&#39;EX_SIDE_SET&#39;, sideSetId)
        if num_side_in_set == 0:
            return [], []
        if EXODUS_LIB.ex_int64_status(self.fileId) &amp; EX_BULK_INT64_API:
            side_set_elem_list = (ctypes.c_longlong * num_side_in_set)()
            side_set_side_list = (ctypes.c_longlong * num_side_in_set)()
        else:
            side_set_elem_list = (ctypes.c_int * num_side_in_set)()
            side_set_side_list = (ctypes.c_int * num_side_in_set)()
        EXODUS_LIB.ex_get_side_set(self.fileId, side_set_id,
                                   ctypes.byref(side_set_elem_list),
                                   ctypes.byref(side_set_side_list))
        return side_set_elem_list, side_set_side_list

    # --------------------------------------------------------------------

    def __ex_put_side_set(self, object_id, sideSetElements, sideSetSides):
        side_set_id = ctypes.c_longlong(object_id)
        if EXODUS_LIB.ex_int64_status(self.fileId) &amp; EX_BULK_INT64_API:
            side_set_elem_list = (ctypes.c_longlong * len(sideSetElements))()
            side_set_side_list = (ctypes.c_longlong * len(sideSetSides))()
            for i, sse in enumerate(sideSetElements):
                side_set_elem_list[i] = ctypes.c_longlong(sse)
                side_set_side_list[i] = ctypes.c_longlong(sideSetSides[i])
        else:
            side_set_elem_list = (ctypes.c_int * len(sideSetElements))()
            side_set_side_list = (ctypes.c_int * len(sideSetSides))()
            for i, sse in enumerate(sideSetElements):
                side_set_elem_list[i] = ctypes.c_int(sse)
                side_set_side_list[i] = ctypes.c_int(sideSetSides[i])
        EXODUS_LIB.ex_put_side_set(
            self.fileId,
            side_set_id,
            side_set_elem_list,
            side_set_side_list)
        return True

    # --------------------------------------------------------------------

    def __ex_get_side_set_dist_fact(self, sideSetId):
        side_set_id = ctypes.c_longlong(sideSetId)
        side_set_node_list_len = self.__ex_get_side_set_node_list_len(
            sideSetId)
        set_dfs = (ctypes.c_double * side_set_node_list_len.value)()
        EXODUS_LIB.ex_get_side_set_dist_fact(
            self.fileId, side_set_id, ctypes.byref(set_dfs))
        return set_dfs

    # --------------------------------------------------------------------

    def __ex_put_side_set_dist_fact(self, sideSetId, sideSetDistFact):
        side_set_id = ctypes.c_longlong(sideSetId)
        side_set_dist_fact = (ctypes.c_double * len(sideSetDistFact))()
        for i, df in enumerate(sideSetDistFact):
            side_set_dist_fact[i] = ctypes.c_double(df)
        EXODUS_LIB.ex_put_side_set_dist_fact(
            self.fileId, side_set_id, side_set_dist_fact)

    # --------------------------------------------------------------------

    def __ex_get_side_set_node_list(self, object_id):
        side_set_id = ctypes.c_longlong(object_id)
        side_set_node_list_len = self.__ex_get_side_set_node_list_len(object_id)
        (num_side_in_set, _num_dist_fact_in_set) = self.__ex_get_set_param(&#39;EX_SIDE_SET&#39;, object_id)
        if EXODUS_LIB.ex_int64_status(self.fileId) &amp; EX_BULK_INT64_API:
            side_set_node_cnt_list = (ctypes.c_longlong * num_side_in_set)()
            side_set_node_list = (ctypes.c_longlong * side_set_node_list_len.value)()
        else:
            side_set_node_cnt_list = (ctypes.c_int * num_side_in_set)()
            side_set_node_list = (ctypes.c_int * side_set_node_list_len.value)()
        EXODUS_LIB.ex_get_side_set_node_list(self.fileId, side_set_id,
                                             ctypes.byref(side_set_node_cnt_list),
                                             ctypes.byref(side_set_node_list))
        return side_set_node_cnt_list, side_set_node_list

    # --------------------------------------------------------------------

    def __ex_put_variable_param(self, varType, numVars):
        num_vars = ctypes.c_int(numVars)
        current_num = self.__ex_get_variable_param(varType)
        if current_num.value == num_vars.value:
            # print &#34;value already set&#34;
            return True

        var_type = ctypes.c_int(get_entity_type(varType))
        errorInt = EXODUS_LIB.ex_put_variable_param(
            self.fileId, var_type, num_vars)
        if errorInt != 0:
            print((&#34;ERROR code =&#34;, errorInt))
            raise Exception(
                &#34;ERROR: ex_put_variable_param had problems.&#34;
                &#34; This can only be called once per varType.&#34;)
        return True

    # --------------------------------------------------------------------

    def __ex_get_variable_name(self, varType, varId):
        var_type = ctypes.c_int(varType)
        var_id = ctypes.c_int(varId)
        name = ctypes.create_string_buffer(MAX_NAME_LENGTH + 1)
        EXODUS_LIB.ex_get_variable_name(self.fileId, var_type, var_id, name)
        return name.decode(&#39;utf8&#39;)

    # --------------------------------------------------------------------

    def __ex_put_variable_name(self, varType, varId, varName):
        var_type = ctypes.c_int(get_entity_type(varType))
        var_id = ctypes.c_int(varId)
        name = ctypes.create_string_buffer(varName.encode(&#39;ascii&#39;), MAX_NAME_LENGTH + 1)
        EXODUS_LIB.ex_put_variable_name(self.fileId, var_type, var_id, name)
        return True

    # --------------------------------------------------------------------

    def __ex_get_elem_attr_names(self, blkId):
        object_id = ctypes.c_longlong(blkId)
        num_attr = ctypes.c_int(self.num_attr(blkId))
        len_name = self.__ex_inquire_int(ex_inquiry_map(&#39;EX_INQ_MAX_READ_NAME_LENGTH&#39;))
        attr_name_ptrs = (ctypes.POINTER(ctypes.c_char * (len_name + 1)) * num_attr.value)()
        for i in range(num_attr.value):
            attr_name_ptrs[i] = ctypes.pointer(ctypes.create_string_buffer(len_name + 1))
        EXODUS_LIB.ex_get_elem_attr_names(
            self.fileId, object_id, ctypes.byref(attr_name_ptrs))
        attr_names = []
        for cnp in attr_name_ptrs:
            attr_names.append(cnp.contents.value.decode(&#39;utf8&#39;))
        return attr_names

    # --------------------------------------------------------------------

    def __ex_put_elem_attr_names(self, blkId, varNames):
        object_id = ctypes.c_int(blkId)
        num_attr = ctypes.c_int(self.num_attr(blkId))
        len_name = self.__ex_inquire_int(ex_inquiry_map(&#39;EX_INQ_MAX_READ_NAME_LENGTH&#39;))
        attr_name_ptrs = (ctypes.POINTER(ctypes.c_char * (len_name + 1)) * num_attr.value)()
        assert len(varNames) == num_attr.value
        for i in range(num_attr.value):
            attr_name_ptrs[i] = ctypes.pointer(
                ctypes.create_string_buffer(
                    varNames[i].encode(&#39;ascii&#39;), len_name + 1))
        EXODUS_LIB.ex_put_elem_attr_names(
            self.fileId, object_id, ctypes.byref(attr_name_ptrs))
        return True

    # --------------------------------------------------------------------

    def __ex_get_prop_names(self, varType, inqType):
        var_type = ctypes.c_int(get_entity_type(varType))
        num_props = ctypes.c_int(self.__ex_inquire_int(ex_inquiry_map(inqType)))
        prop_name_ptrs = (
            ctypes.POINTER(ctypes.c_char * (MAX_STR_LENGTH + 1)) * num_props.value)()
        for i in range(num_props.value):
            prop_name_ptrs[i] = ctypes.pointer(
                ctypes.create_string_buffer(
                    MAX_STR_LENGTH + 1))
        EXODUS_LIB.ex_get_prop_names(
            self.fileId, var_type, ctypes.byref(prop_name_ptrs))
        prop_names = []
        for cnp in prop_name_ptrs:
            prop_names.append(cnp.contents.value.decode(&#39;utf8&#39;))
        return prop_names

    # --------------------------------------------------------------------

    def __ex_get_prop(self, objType, objId, propName):
        obj_type = ctypes.c_int(get_entity_type(objType))
        obj_id = ctypes.c_longlong(objId)
        prop_name = ctypes.create_string_buffer(propName.encode(&#39;ascii&#39;), MAX_STR_LENGTH + 1)
        if EXODUS_LIB.ex_int64_status(self.fileId) &amp; EX_IDS_INT64_API:
            prop_val = ctypes.c_longlong(0)
        else:
            prop_val = ctypes.c_int(0)
        EXODUS_LIB.ex_get_prop(
            self.fileId,
            obj_type,
            obj_id,
            ctypes.byref(prop_name),
            ctypes.byref(prop_val))
        return prop_val.value

    # --------------------------------------------------------------------

    def __ex_put_prop(self, objType, objId, propName, propVal):
        obj_type = ctypes.c_int(get_entity_type(objType))
        obj_id = ctypes.c_longlong(objId)
        prop_name = ctypes.create_string_buffer(propName.encode(&#39;ascii&#39;), MAX_STR_LENGTH + 1)
        prop_val = ctypes.c_longlong(propVal)
        EXODUS_LIB.ex_put_prop(
            self.fileId,
            obj_type,
            obj_id,
            ctypes.byref(prop_name),
            prop_val)
        return True

    # --------------------------------------------------------------------

    def __ex_update(self):
        EXODUS_LIB.ex_update(self.fileId)
        return True</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="exodus3.exodus.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>close the exodus file</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; exo.close()
</code></pre>
<h2 id="note">Note:</h2>
<p>Can only be called once for an exodus object, and once called
all methods for that object become inoperable</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self):
    &#34;&#34;&#34;
    close the exodus file

    &gt;&gt;&gt; exo.close()

    Note:
    -----
    Can only be called once for an exodus object, and once called
    all methods for that object become inoperable
    &#34;&#34;&#34;
    print((&#34;Closing exodus file: &#34; + self.fileName))
    errorInt = EXODUS_LIB.ex_close(self.fileId)
    if errorInt != 0:
        raise Exception(
            &#34;ERROR: Closing file &#34; +
            self.fileName +
            &#34; had problems.&#34;)</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self, fileName, include_transient=False, mode='a')</span>
</code></dt>
<dd>
<div class="desc"><p>Copies exodus database to file_name and returns an opened copy as a
new exodus object. This object will need to be closed when it is done
being used.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; exo_copy = exo.copy(file_name)
&gt;&gt;&gt; exo_copy.close()
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>file_name</code></strong> :&ensp;<code>str</code></dt>
<dd>name of exodus file to open</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>exo_copy</code></strong> :&ensp;<code><a title="exodus3.exodus" href="#exodus3.exodus">exodus</a> object opened in append mode by default</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self, fileName, include_transient=False, mode=&#39;a&#39;):
    &#34;&#34;&#34;
    Copies exodus database to file_name and returns an opened copy as a
    new exodus object. This object will need to be closed when it is done
    being used.

    &gt;&gt;&gt; exo_copy = exo.copy(file_name)
    &gt;&gt;&gt; exo_copy.close()

    Parameters
    ----------
    file_name : str
        name of exodus file to open

    Returns
    -------
    exo_copy : exodus object opened in append mode by default
    &#34;&#34;&#34;
    i64Status = EXODUS_LIB.ex_int64_status(self.fileId)
    fileId = EXODUS_LIB.ex_create_int(fileName.encode(&#39;ascii&#39;), EX_NOCLOBBER|i64Status,
                                      ctypes.byref(self.comp_ws),
                                      ctypes.byref(self.io_ws),
                                      EX_API_VERSION_NODOT)

    self.__copy_file(fileId, include_transient)
    EXODUS_LIB.ex_close(fileId)

    return exodus(fileName, mode)</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.elem_blk_info"><code class="name flex">
<span>def <span class="ident">elem_blk_info</span></span>(<span>self, object_id)</span>
</code></dt>
<dd>
<div class="desc"><p>get the element block info</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; elem_type, num_blk_elems, num_elem_nodes, num_elem_attrs
...       = exo.elem_blk_info(elem_blk_id)
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>elem_blk_id</code></strong> :&ensp;<code>int</code></dt>
<dd>element block <em>ID</em> (not <em>INDEX</em>)</dd>
</dl>
<h2 id="returns">Returns</h2>
<pre><code>&lt;string&gt;  elem_type       element type, e.g. 'HEX8'
&lt;int&gt;     num_blk_elems   number of elements in the block
&lt;int&gt;     num_elem_nodes  number of nodes per element
&lt;int&gt;     num_elem_attrs  number of attributes per element
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def elem_blk_info(self, object_id):
    &#34;&#34;&#34;
    get the element block info

    &gt;&gt;&gt; elem_type, num_blk_elems, num_elem_nodes, num_elem_attrs
    ...       = exo.elem_blk_info(elem_blk_id)

    Parameters
    ----------
    elem_blk_id : int
        element block *ID* (not *INDEX*)

    Returns
    -------
        &lt;string&gt;  elem_type       element type, e.g. &#39;HEX8&#39;
        &lt;int&gt;     num_blk_elems   number of elements in the block
        &lt;int&gt;     num_elem_nodes  number of nodes per element
        &lt;int&gt;     num_elem_attrs  number of attributes per element
    &#34;&#34;&#34;
    (elemType, numElem, nodesPerElem, numAttr) = self.__ex_get_block(&#39;EX_ELEM_BLOCK&#39;, object_id)
    return elemType.value, numElem.value, nodesPerElem.value, numAttr.value</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.elem_type"><code class="name flex">
<span>def <span class="ident">elem_type</span></span>(<span>self, object_id)</span>
</code></dt>
<dd>
<div class="desc"><p>get the element type, e.g. "HEX8", for an element block</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; elem_type = exo.elem_type(elem_blk_id)
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>elem_blk_id</code></strong> :&ensp;<code>int</code></dt>
<dd>element block <em>ID</em> (not <em>INDEX</em>)</dd>
</dl>
<h2 id="returns">Returns</h2>
<pre><code>&lt;string&gt;  elem_type
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def elem_type(self, object_id):
    &#34;&#34;&#34;
    get the element type, e.g. &#34;HEX8&#34;, for an element block

    &gt;&gt;&gt; elem_type = exo.elem_type(elem_blk_id)

    Parameters
    ----------
    elem_blk_id : int
        element block *ID* (not *INDEX*)

    Returns
    -------
        &lt;string&gt;  elem_type
    &#34;&#34;&#34;
    (elemType, _numElem, _nodesPerElem, _numAttr) = self.__ex_get_block(&#39;EX_ELEM_BLOCK&#39;, object_id)
    return elemType.value</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.get_all_global_variable_values"><code class="name flex">
<span>def <span class="ident">get_all_global_variable_values</span></span>(<span>self, step)</span>
</code></dt>
<dd>
<div class="desc"><p>get all global variable values (one for each global variable
name, and in the order given by exo.get_global_variable_names())
at a specified time step</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; gvar_vals = exo.get_all_global_variable_values(time_step)
</code></pre>
<h2 id="parameters">Parameters</h2>
<pre><code>&lt;int&gt;     time_step  1-based index of time step
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>if array_type == 'ctype':
  &lt;list&lt;float&gt;&gt;  gvar_vals

if array_type == 'numpy':
  &lt;np_array&lt;double&gt;&gt;  gvar_vals
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_all_global_variable_values(self, step):
    &#34;&#34;&#34;
    get all global variable values (one for each global variable
    name, and in the order given by exo.get_global_variable_names())
    at a specified time step

    &gt;&gt;&gt; gvar_vals = exo.get_all_global_variable_values(time_step)

    Parameters
    ----------
        &lt;int&gt;     time_step  1-based index of time step

    Returns
    -------

        if array_type == &#39;ctype&#39;:
          &lt;list&lt;float&gt;&gt;  gvar_vals

        if array_type == &#39;numpy&#39;:
          &lt;np_array&lt;double&gt;&gt;  gvar_vals
    &#34;&#34;&#34;
    num = self.__ex_get_variable_param(&#39;EX_GLOBAL&#39;)
    gvalues = self.__ex_get_var(step, &#39;EX_GLOBAL&#39;, 0, 1, num.value)
    values = []
    for i in range(num.value):
        values.append(gvalues[i])
    if self.use_numpy:
        values = self.np.array(values)
    return values</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.get_all_node_set_params"><code class="name flex">
<span>def <span class="ident">get_all_node_set_params</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>get total number of nodes and distribution factors (e.g. nodal
'weights') combined among all node sets</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; tot_num_ns_nodes,
... tot_num_ns_dist_facts = exo.get_all_node_set_params()
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>&lt;int&gt;  tot_num_ns_nodes
&lt;int&gt;  tot_num_ns_dist_facts
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_all_node_set_params(self):
    &#34;&#34;&#34;
    get total number of nodes and distribution factors (e.g. nodal
    &#39;weights&#39;) combined among all node sets

    &gt;&gt;&gt; tot_num_ns_nodes,
    ... tot_num_ns_dist_facts = exo.get_all_node_set_params()

    Returns
    -------
        &lt;int&gt;  tot_num_ns_nodes
        &lt;int&gt;  tot_num_ns_dist_facts
    &#34;&#34;&#34;
    nodeSetIds = self.__ex_get_ids(&#39;EX_NODE_SET&#39;)
    totNumSetNodes, totNumSetDistFacts = 0, 0
    for nodeSetId in nodeSetIds:
        (numSetNodes, numSetDistFacts) = self.__ex_get_set_param(&#39;EX_NODE_SET&#39;, nodeSetId)
        totNumSetNodes += numSetNodes
        totNumSetDistFacts += numSetDistFacts
    return totNumSetNodes, totNumSetDistFacts</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.get_all_side_set_params"><code class="name flex">
<span>def <span class="ident">get_all_side_set_params</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>get total number of sides, nodes, and distribution factors
(e.g. nodal 'weights') combined among all side sets</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; tot_num_ss_sides, tot_num_ss_nodes, tot_num_ss_dist_facts =
...          exo.get_all_side_set_params()
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>&lt;int&gt;  tot_num_ss_sides
&lt;int&gt;  tot_num_ss_nodes
&lt;int&gt;  tot_num_ss_dist_facts
</code></pre>
<h2 id="note">Note:</h2>
<p>The number of nodes (and distribution factors) in a side set is
the sum of all face nodes.
A single node can be counted more
than once, i.e. once for each face it belongs to in the side set.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_all_side_set_params(self):
    &#34;&#34;&#34;
    get total number of sides, nodes, and distribution factors
    (e.g. nodal &#39;weights&#39;) combined among all side sets

    &gt;&gt;&gt; tot_num_ss_sides, tot_num_ss_nodes, tot_num_ss_dist_facts =
    ...          exo.get_all_side_set_params()

    Returns
    -------
        &lt;int&gt;  tot_num_ss_sides
        &lt;int&gt;  tot_num_ss_nodes
        &lt;int&gt;  tot_num_ss_dist_facts

    Note:
    -----
    The number of nodes (and distribution factors) in a side set is
    the sum of all face nodes.  A single node can be counted more
    than once, i.e. once for each face it belongs to in the side set.
    &#34;&#34;&#34;
    ids = self.__ex_get_ids(&#39;EX_SIDE_SET&#39;)
    totNumSetSides, totNumSetDistFacts = 0, 0  # totNumSetDistFacts = totNumSetNodes
    for sideSetId in ids:
        (numSetSides, numSetDistFacts) = self.__ex_get_set_param(&#39;EX_SIDE_SET&#39;, sideSetId)
        totNumSetSides += numSetSides
        totNumSetDistFacts += numSetDistFacts
    totNumSetNodes = totNumSetDistFacts
    return totNumSetSides, totNumSetNodes, totNumSetDistFacts</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.get_assemblies"><code class="name flex">
<span>def <span class="ident">get_assemblies</span></span>(<span>self, object_ids)</span>
</code></dt>
<dd>
<div class="desc"><p>reads the assembly parameters and assembly data for all assemblies
with ids in object_ids</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_assemblies(self, object_ids):
    &#34;&#34;&#34;
    reads the assembly parameters and assembly data for all assemblies
    with ids in object_ids
    &#34;&#34;&#34;
    assemblies = [ex_assembly(id=object_id) for object_id in object_ids]
    assems = (ex_assembly * len(assemblies))(*assemblies)
    self.__ex_get_assemblies(assems)
    assembs = [assembly(assem.name.decode(&#39;utf8&#39;), assem.id, assem.type) for assem in
               assems]
    for i, a in enumerate(assems):
        for j in range(a.entity_count):
            assembs[i].entity_list.append(a.entity_list[j])
    return assembs</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.get_assembly"><code class="name flex">
<span>def <span class="ident">get_assembly</span></span>(<span>self, object_id)</span>
</code></dt>
<dd>
<div class="desc"><p>reads the assembly parameters and assembly data for one assembly</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_assembly(self, object_id):
    &#34;&#34;&#34;
    reads the assembly parameters and assembly data for one assembly
    &#34;&#34;&#34;
    assem = ex_assembly(id=object_id)
    self.__ex_get_assembly(assem)
    assmbly = assembly(assem.name.decode(&#39;utf8&#39;), assem.id, assem.type)
    for j in range(assem.entity_count):
        assmbly.entity_list.append(assem.entity_list[j])
    return assmbly</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.get_attribute_count"><code class="name flex">
<span>def <span class="ident">get_attribute_count</span></span>(<span>self, objType, objId)</span>
</code></dt>
<dd>
<div class="desc"><p>IS THIS NEEDED, PYTHONIC WAY MAY BE TO JUST GET THEM&hellip;</p>
<p>get the number of attributes on the specified entity</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; num_attribute = exo.get_attribute_count('EX_ASSEMBLY', 100)
</code></pre>
<h2 id="parameters">Parameters</h2>
<p>objType
: ex_entity_type
type of object being queried
id
: int
entity <em>ID</em> (not <em>INDEX</em>)</p>
<h2 id="returns">Returns</h2>
<pre><code>&lt;int&gt;  num_attribute
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attribute_count(self, objType, objId):
    &#34;&#34;&#34;
    IS THIS NEEDED, PYTHONIC WAY MAY BE TO JUST GET THEM...

    get the number of attributes on the specified entity

    &gt;&gt;&gt; num_attribute = exo.get_attribute_count(&#39;EX_ASSEMBLY&#39;, 100)

    Parameters
    ----------
    objType   : ex_entity_type
        type of object being queried
    id        : int
        entity *ID* (not *INDEX*)

    Returns
    -------
        &lt;int&gt;  num_attribute
    &#34;&#34;&#34;
    return self.__ex_get_attribute_count(objType, objId)</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self, objType, objId)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; attributes = exo.get_attributes('EX_ASSEMBLY', 100)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>&lt;ex_attribute list&gt; attributes
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self, objType, objId):
    &#34;&#34;&#34;
    &gt;&gt;&gt; attributes = exo.get_attributes(&#39;EX_ASSEMBLY&#39;, 100)

    Returns
    -------
        &lt;ex_attribute list&gt; attributes
    &#34;&#34;&#34;

    return self.__ex_get_attributes(objType, objId)</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.get_blob"><code class="name flex">
<span>def <span class="ident">get_blob</span></span>(<span>self, object_id)</span>
</code></dt>
<dd>
<div class="desc"><p>reads the blob parameters and blob data for one blob</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_blob(self, object_id):
    &#34;&#34;&#34;
    reads the blob parameters and blob data for one blob
    &#34;&#34;&#34;
    assem = ex_blob(id=object_id)
    self.__ex_get_blob(assem)
    return assem</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.get_block_id_map"><code class="name flex">
<span>def <span class="ident">get_block_id_map</span></span>(<span>self, obj_type, entity_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the map of elements found in the given entity_id of an object
of obj_type.</p>
<p><em>INDEX</em> ordering, a 1-based system going from 1 to
number of elements in the elem_block, used by exodus for
storage and input/output of array data stored on the elements;
a user or application can optionally use a separate element <em>ID</em> numbering system,
so the elem_id_map points to the element <em>ID</em> for each
element <em>INDEX</em></p>
<pre><code class="language-python-repl">&gt;&gt;&gt; elem_block_id_map = exo.get_block_id_map(&quot;EX_ELEM_BLOCK&quot;, 100)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>if array_type == 'ctype':
  &lt;list&lt;int&gt;&gt;  elem_id_map

if array_type == 'numpy':
  &lt;np_array&lt;int&gt;&gt;  elem_id_map
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_block_id_map(self, obj_type, entity_id):
    &#34;&#34;&#34;
    Gets the map of elements found in the given entity_id of an object
    of obj_type.

    *INDEX* ordering, a 1-based system going from 1 to
    number of elements in the elem_block, used by exodus for
    storage and input/output of array data stored on the elements;
    a user or application can optionally use a separate element *ID* numbering system,
    so the elem_id_map points to the element *ID* for each
    element *INDEX*

    &gt;&gt;&gt; elem_block_id_map = exo.get_block_id_map(&#34;EX_ELEM_BLOCK&#34;, 100)

    Returns
    -------

        if array_type == &#39;ctype&#39;:
          &lt;list&lt;int&gt;&gt;  elem_id_map

        if array_type == &#39;numpy&#39;:
          &lt;np_array&lt;int&gt;&gt;  elem_id_map
    &#34;&#34;&#34;
    return self.__ex_get_block_id_map(obj_type, entity_id)</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.get_coord"><code class="name flex">
<span>def <span class="ident">get_coord</span></span>(<span>self, i)</span>
</code></dt>
<dd>
<div class="desc"><p>get model coordinates of a single node</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; x_coord, y_coord, z_coord = exo.get_coord(node_index)
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>node_index</code></strong> :&ensp;<code>int</code></dt>
<dd>the 1-based node index (indexing is from 1 to exo.num_nodes())</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>x_coord</code></strong> :&ensp;<code>double</code></dt>
<dd>global x-direction coordinate</dd>
<dt><strong><code>y_coord</code></strong> :&ensp;<code>double</code></dt>
<dd>global y-direction coordinate</dd>
<dt><strong><code>z_coord</code></strong> :&ensp;<code>double</code></dt>
<dd>global z-direction coordinate</dd>
</dl>
<h2 id="note">Note:</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; x_coords, y_coords, z_coords = exo.get_coords()
&gt;&gt;&gt; x_coord = x_coords[node_index-1]
&gt;&gt;&gt; y_coord = y_coords[node_index-1]
&gt;&gt;&gt; z_coord = z_coords[node_index-1]
    ... is equivalent to ...
&gt;&gt;&gt; x_coord, y_coord, z_coord = exo.get_coords(node_index)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_coord(self, i):
    &#34;&#34;&#34;
    get model coordinates of a single node

    &gt;&gt;&gt; x_coord, y_coord, z_coord = exo.get_coord(node_index)

    Parameters
    ----------
    node_index : int
        the 1-based node index (indexing is from 1 to exo.num_nodes())

    Returns
    -------
    x_coord : double
        global x-direction coordinate
    y_coord : double
        global y-direction coordinate
    z_coord : double
        global z-direction coordinate

    Note:
    -----
    &gt;&gt;&gt; x_coords, y_coords, z_coords = exo.get_coords()
    &gt;&gt;&gt; x_coord = x_coords[node_index-1]
    &gt;&gt;&gt; y_coord = y_coords[node_index-1]
    &gt;&gt;&gt; z_coord = z_coords[node_index-1]
        ... is equivalent to ...
    &gt;&gt;&gt; x_coord, y_coord, z_coord = exo.get_coords(node_index)

    &#34;&#34;&#34;
    listX, listY, listZ = self.__ex_get_partial_coord(i, 1)
    return listX[0], listY[0], listZ[0]</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.get_coord_names"><code class="name flex">
<span>def <span class="ident">get_coord_names</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>get a list of length exo.num_dimensions() that has the name
of each model coordinate direction, e.g. ['x', 'y', 'z']</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; coord_names = exo.get_coord_names()
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>&lt;list&lt;string&gt;&gt;  coord_names
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_coord_names(self):
    &#34;&#34;&#34;
    get a list of length exo.num_dimensions() that has the name
    of each model coordinate direction, e.g. [&#39;x&#39;, &#39;y&#39;, &#39;z&#39;]

    &gt;&gt;&gt; coord_names = exo.get_coord_names()

    Returns
    -------
        &lt;list&lt;string&gt;&gt;  coord_names
    &#34;&#34;&#34;
    names = self.__ex_get_coord_names()
    return names</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.get_coords"><code class="name flex">
<span>def <span class="ident">get_coords</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>get model coordinates of all nodes; for each coordinate
direction, a length exo.num_nodes() list is returned</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; x_coords, y_coords, z_coords = exo.get_coords()
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>if array_type == 'ctype':
  &lt;list&lt;ctypes.c_double&gt;&gt;  x_coords  global x-direction coordinates
  &lt;list&lt;ctypes.c_double&gt;&gt;  y_coords  global y-direction coordinates
  &lt;list&lt;ctypes.c_double&gt;&gt;  z_coords  global z-direction coordinates

if array_type == 'numpy':
  &lt;np_array&lt;double&gt;&gt;  x_coords  global x-direction coordinates
  &lt;np_array&lt;double&gt;&gt;  y_coords  global y-direction coordinates
  &lt;np_array&lt;double&gt;&gt;  z_coords  global z-direction coordinates
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_coords(self):
    &#34;&#34;&#34;
    get model coordinates of all nodes; for each coordinate
    direction, a length exo.num_nodes() list is returned

    &gt;&gt;&gt; x_coords, y_coords, z_coords = exo.get_coords()

    Returns
    -------

        if array_type == &#39;ctype&#39;:
          &lt;list&lt;ctypes.c_double&gt;&gt;  x_coords  global x-direction coordinates
          &lt;list&lt;ctypes.c_double&gt;&gt;  y_coords  global y-direction coordinates
          &lt;list&lt;ctypes.c_double&gt;&gt;  z_coords  global z-direction coordinates

        if array_type == &#39;numpy&#39;:
          &lt;np_array&lt;double&gt;&gt;  x_coords  global x-direction coordinates
          &lt;np_array&lt;double&gt;&gt;  y_coords  global y-direction coordinates
          &lt;np_array&lt;double&gt;&gt;  z_coords  global z-direction coordinates
    &#34;&#34;&#34;
    self.__ex_get_coord()
    if self.use_numpy:
        self.coordsX = ctype_to_numpy(self, self.coordsX)
        self.coordsY = ctype_to_numpy(self, self.coordsY)
        self.coordsZ = ctype_to_numpy(self, self.coordsZ)
    return self.coordsX, self.coordsY, self.coordsZ</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.get_elem_attr"><code class="name flex">
<span>def <span class="ident">get_elem_attr</span></span>(<span>self, elem_blk_id)</span>
</code></dt>
<dd>
<div class="desc"><p>get all attributes for each element in a block</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; elem_attrs = exo.get_elem_attr(elem_blk_id)
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>elem_blk_id</code></strong> :&ensp;<code>int</code></dt>
<dd>element block <em>ID</em> (not <em>INDEX</em>)</dd>
</dl>
<h2 id="returns">Returns</h2>
<pre><code>if array_type == 'ctype' : &lt;list&lt;float&gt;&gt; elem_attrs
if array_type == 'numpy' : &lt;np_array&lt;float&gt;&gt; elem_attrs
    list of attribute values for all
    elements in the block; the list cycles
    through all attributes of the first
    element, then all attributes of the
    second element, etc. Attributes are
    ordered by the ordering of the names
    returned by exo.get_element_attribute_names()
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_elem_attr(self, elem_blk_id):
    &#34;&#34;&#34;
    get all attributes for each element in a block

    &gt;&gt;&gt; elem_attrs = exo.get_elem_attr(elem_blk_id)

    Parameters
    ----------
    elem_blk_id : int
        element block *ID* (not *INDEX*)

    Returns
    -------
        if array_type == &#39;ctype&#39; : &lt;list&lt;float&gt;&gt; elem_attrs
        if array_type == &#39;numpy&#39; : &lt;np_array&lt;float&gt;&gt; elem_attrs
            list of attribute values for all
            elements in the block; the list cycles
            through all attributes of the first
            element, then all attributes of the
            second element, etc. Attributes are
            ordered by the ordering of the names
            returned by exo.get_element_attribute_names()
    &#34;&#34;&#34;
    elem_attrs = self.__ex_get_elem_attr(elem_blk_id)
    if self.use_numpy:
        elem_attrs = ctype_to_numpy(self, elem_attrs)
    return elem_attrs</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.get_elem_attr_values"><code class="name flex">
<span>def <span class="ident">get_elem_attr_values</span></span>(<span>self, elem_blk_id, elem_attr_name)</span>
</code></dt>
<dd>
<div class="desc"><p>get an attribute for each element in a block</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; elem_attrs = exo.get_elem_attr(elem_blk_id)
</code></pre>
<h2 id="parameters">Parameters</h2>
<pre><code>&lt;int&gt;    elem_blk_id     element block *ID* (not *INDEX*)
&lt;string&gt; elem_attr_name  element attribute name
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>if array_type == 'ctype': &lt;list&lt;float&gt;&gt;  values
if array_type == 'numpy': &lt;np_array&lt;float&gt;&gt;  values
    array of values for the requested
    attribute.  Array has dimensions of
    1 x num_elem, where num_elem is the
    number of elements on the element block.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_elem_attr_values(self, elem_blk_id, elem_attr_name):
    &#34;&#34;&#34;
    get an attribute for each element in a block

    &gt;&gt;&gt; elem_attrs = exo.get_elem_attr(elem_blk_id)

    Parameters
    ----------
        &lt;int&gt;    elem_blk_id     element block *ID* (not *INDEX*)
        &lt;string&gt; elem_attr_name  element attribute name

    Returns
    -------
        if array_type == &#39;ctype&#39;: &lt;list&lt;float&gt;&gt;  values
        if array_type == &#39;numpy&#39;: &lt;np_array&lt;float&gt;&gt;  values
            array of values for the requested
            attribute.  Array has dimensions of
            1 x num_elem, where num_elem is the
            number of elements on the element block.
    &#34;&#34;&#34;
    # Determine index of requested attribute in attribute list
    elem_attr_names = self.get_element_attribute_names(elem_blk_id)
    a_ndx = elem_attr_names.index(elem_attr_name)

    values = self.__ex_get_one_attr(&#39;EX_ELEM_BLOCK&#39;, elem_blk_id, a_ndx)
    if self.use_numpy:
        values = ctype_to_numpy(self, values)
    return values</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.get_elem_blk_ids"><code class="name flex">
<span>def <span class="ident">get_elem_blk_ids</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>get mapping of exodus element block index to user- or
application-defined element block id; elem_blk_ids is ordered
by the element block <em>INDEX</em> ordering, a 1-based system going
from 1 to exo.num_blks(), used by exodus for storage
and input/output of array data stored on the element blocks; a
user or application can optionally use a separate element block
<em>ID</em> numbering system, so the elem_blk_ids array points to the
element block <em>ID</em> for each element block <em>INDEX</em></p>
<pre><code class="language-python-repl">&gt;&gt;&gt; elem_blk_ids = exo.get_elem_blk_ids()
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>if array_type == 'ctype':
  &lt;list&lt;int&gt;&gt;  elem_blk_ids

if array_type == 'numpy':
  &lt;np_array&lt;int&gt;&gt;  elem_blk_ids
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_elem_blk_ids(self):
    &#34;&#34;&#34;
    get mapping of exodus element block index to user- or
    application-defined element block id; elem_blk_ids is ordered
    by the element block *INDEX* ordering, a 1-based system going
    from 1 to exo.num_blks(), used by exodus for storage
    and input/output of array data stored on the element blocks; a
    user or application can optionally use a separate element block
    *ID* numbering system, so the elem_blk_ids array points to the
    element block *ID* for each element block *INDEX*

    &gt;&gt;&gt; elem_blk_ids = exo.get_elem_blk_ids()

    Returns
    -------

        if array_type == &#39;ctype&#39;:
          &lt;list&lt;int&gt;&gt;  elem_blk_ids

        if array_type == &#39;numpy&#39;:
          &lt;np_array&lt;int&gt;&gt;  elem_blk_ids
    &#34;&#34;&#34;
    return self.get_ids(&#39;EX_ELEM_BLOCK&#39;)</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.get_elem_blk_name"><code class="name flex">
<span>def <span class="ident">get_elem_blk_name</span></span>(<span>self, object_id)</span>
</code></dt>
<dd>
<div class="desc"><p>get the element block name</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; elem_blk_name = exo.get_elem_blk_name(elem_blk_id)
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>elem_blk_id</code></strong> :&ensp;<code>int</code></dt>
<dd>element block <em>ID</em> (not <em>INDEX</em>)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>elem_blk_name</code></strong> :&ensp;<code>string</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_elem_blk_name(self, object_id):
    &#34;&#34;&#34;
    get the element block name

    &gt;&gt;&gt; elem_blk_name = exo.get_elem_blk_name(elem_blk_id)

    Parameters
    ----------
    elem_blk_id : int
        element block *ID* (not *INDEX*)

    Returns
    -------
    elem_blk_name : string
    &#34;&#34;&#34;
    return self.__ex_get_name(&#39;EX_ELEM_BLOCK&#39;, object_id)</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.get_elem_blk_names"><code class="name flex">
<span>def <span class="ident">get_elem_blk_names</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>get a list of all element block names ordered by block <em>INDEX</em>;
(see <code><a title="exodus3.exodus.get_ids" href="#exodus3.exodus.get_ids">exodus.get_ids()</a></code> for explanation of the
difference between block <em>ID</em> and block <em>INDEX</em>)</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; elem_blk_names = exo.get_elem_blk_names()
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>elem_blk_names</code></strong> :&ensp;<code>&lt;list&lt;string&gt;&gt;</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_elem_blk_names(self):
    &#34;&#34;&#34;
    get a list of all element block names ordered by block *INDEX*;
    (see `exodus.get_ids` for explanation of the
    difference between block *ID* and block *INDEX*)

    &gt;&gt;&gt; elem_blk_names = exo.get_elem_blk_names()

    Returns
    -------
    elem_blk_names : &lt;list&lt;string&gt;&gt;
    &#34;&#34;&#34;
    elemBlkNames = self.__ex_get_names(&#39;EX_ELEM_BLOCK&#39;)
    return elemBlkNames</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.get_elem_connectivity"><code class="name flex">
<span>def <span class="ident">get_elem_connectivity</span></span>(<span>self, object_id)</span>
</code></dt>
<dd>
<div class="desc"><p>get the nodal connectivity, number of elements, and
number of nodes per element for a single block</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; elem_conn, num_blk_elems, num_elem_nodes
...        = exo.get_elem_connectivity(elem_blk_id)
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>elem_blk_id</code></strong> :&ensp;<code>int</code></dt>
<dd>element block <em>ID</em> (not <em>INDEX</em>)</dd>
</dl>
<h2 id="returns">Returns</h2>
<pre><code>if array_type == 'ctype':
  &lt;list&lt;int&gt;&gt;  elem_conn  ordered list of node *INDICES* that
    define the connectivity of each element
    in the block; the list cycles through
    all nodes of the first element, then
    all nodes of the second element, etc.
    (see &lt;code&gt;&lt;a title="exodus3.exodus.get_id_map" href="#exodus3.exodus.get_id_map"&gt;exodus.get\_id\_map()&lt;/a&gt;&lt;/code&gt; for explanation
    of node *INDEX* versus node *ID*)

if array_type == 'numpy':
  &lt;np_array&lt;int&gt;&gt;  elem_conn  (same description)

&lt;int&gt;  num_blk_elems    number of elements in the block
&lt;int&gt;  num_elem_nodes   number of nodes per element
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_elem_connectivity(self, object_id):
    &#34;&#34;&#34;
    get the nodal connectivity, number of elements, and
    number of nodes per element for a single block

    &gt;&gt;&gt; elem_conn, num_blk_elems, num_elem_nodes
    ...        = exo.get_elem_connectivity(elem_blk_id)

    Parameters
    ----------
    elem_blk_id : int
        element block *ID* (not *INDEX*)

    Returns
    -------

        if array_type == &#39;ctype&#39;:
          &lt;list&lt;int&gt;&gt;  elem_conn  ordered list of node *INDICES* that
            define the connectivity of each element
            in the block; the list cycles through
            all nodes of the first element, then
            all nodes of the second element, etc.
            (see `exodus.get_id_map` for explanation
            of node *INDEX* versus node *ID*)

        if array_type == &#39;numpy&#39;:
          &lt;np_array&lt;int&gt;&gt;  elem_conn  (same description)

        &lt;int&gt;  num_blk_elems    number of elements in the block
        &lt;int&gt;  num_elem_nodes   number of nodes per element
    &#34;&#34;&#34;
    (elem_block_connectivity, num_elem_this_blk,
     num_nodes_per_elem) = self.__ex_get_elem_conn(object_id)
    if self.use_numpy:
        elem_block_connectivity = ctype_to_numpy(
            self, elem_block_connectivity)
    return elem_block_connectivity, num_elem_this_blk.value, num_nodes_per_elem.value</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.get_elem_id_map"><code class="name flex">
<span>def <span class="ident">get_elem_id_map</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>get mapping of exodus element index to user- or application-
defined element id; elem_id_map is ordered by the element
<em>INDEX</em> ordering, a 1-based system going from 1 to
exo.num_elems(), used by exodus for storage and input/output
of array data stored on the elements; a user or application
can optionally use a separate element <em>ID</em> numbering system,
so the elem_id_map points to the element <em>ID</em> for each
element <em>INDEX</em></p>
<pre><code class="language-python-repl">&gt;&gt;&gt; elem_id_map = exo.get_elem_id_map()
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>if array_type == 'ctype':
  &lt;list&lt;int&gt;&gt;  elem_id_map

if array_type == 'numpy':
  &lt;np_array&lt;int&gt;&gt;  elem_id_map
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_elem_id_map(self):
    &#34;&#34;&#34;
    get mapping of exodus element index to user- or application-
    defined element id; elem_id_map is ordered by the element
    *INDEX* ordering, a 1-based system going from 1 to
    exo.num_elems(), used by exodus for storage and input/output
    of array data stored on the elements; a user or application
    can optionally use a separate element *ID* numbering system,
    so the elem_id_map points to the element *ID* for each
    element *INDEX*

    &gt;&gt;&gt; elem_id_map = exo.get_elem_id_map()

    Returns
    -------

        if array_type == &#39;ctype&#39;:
          &lt;list&lt;int&gt;&gt;  elem_id_map

        if array_type == &#39;numpy&#39;:
          &lt;np_array&lt;int&gt;&gt;  elem_id_map
    &#34;&#34;&#34;
    return self.__ex_get_id_map(&#39;EX_ELEM_MAP&#39;)</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.get_elem_num_map"><code class="name flex">
<span>def <span class="ident">get_elem_num_map</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p><strong>DEPRECATED</strong> use: <code>get_elem_id_map()</code></p>
<p>get mapping of exodus element index to user- or application-
defined element id; elem_id_map is ordered by the element
<em>INDEX</em> ordering, a 1-based system going from 1 to
exo.num_elems(), used by exodus for storage and input/output
of array data stored on the elements; a user or application
can optionally use a separate element <em>ID</em> numbering system,
so the elem_id_map points to the element <em>ID</em> for each
element <em>INDEX</em></p>
<pre><code class="language-python-repl">&gt;&gt;&gt; elem_id_map = exo.get_elem_num_map()
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>&lt;list&lt;ctypes.c_int&gt;&gt;  elem_id_map
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_elem_num_map(self):
    &#34;&#34;&#34;
    **DEPRECATED** use: `get_elem_id_map()`

    get mapping of exodus element index to user- or application-
    defined element id; elem_id_map is ordered by the element
    *INDEX* ordering, a 1-based system going from 1 to
    exo.num_elems(), used by exodus for storage and input/output
    of array data stored on the elements; a user or application
    can optionally use a separate element *ID* numbering system,
    so the elem_id_map points to the element *ID* for each
    element *INDEX*

    &gt;&gt;&gt; elem_id_map = exo.get_elem_num_map()

    Returns
    -------
        &lt;list&lt;ctypes.c_int&gt;&gt;  elem_id_map
    &#34;&#34;&#34;
    elemNumMap = self.__ex_get_elem_num_map()
    return elemNumMap</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.get_elem_order_map"><code class="name flex">
<span>def <span class="ident">get_elem_order_map</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>get mapping of exodus element index to application-defined
optimal ordering; elem_order_map is ordered by the element
index ordering used by exodus for storage and input/output
of array data stored on the elements; a user or application
can optionally use a separate element ordering, e.g. for
optimal solver performance, so the elem_order_map points to
the index used by the application for each exodus element
index</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; elem_order_map = exo.get_elem_order_map()
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>if array_type == 'ctype':
  &lt;list&lt;int&gt;&gt;  elem_order_map

if array_type == 'numpy':
  &lt;np_array&lt;int&gt;&gt;  elem_order_map
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_elem_order_map(self):
    &#34;&#34;&#34;
    get mapping of exodus element index to application-defined
    optimal ordering; elem_order_map is ordered by the element
    index ordering used by exodus for storage and input/output
    of array data stored on the elements; a user or application
    can optionally use a separate element ordering, e.g. for
    optimal solver performance, so the elem_order_map points to
    the index used by the application for each exodus element
    index

    &gt;&gt;&gt; elem_order_map = exo.get_elem_order_map()

    Returns
    -------

        if array_type == &#39;ctype&#39;:
          &lt;list&lt;int&gt;&gt;  elem_order_map

        if array_type == &#39;numpy&#39;:
          &lt;np_array&lt;int&gt;&gt;  elem_order_map
    &#34;&#34;&#34;

    elemOrderMap = self.__ex_get_elem_order_map()
    if self.use_numpy:
        elemOrderMap = ctype_to_numpy(self, elemOrderMap)
    return elemOrderMap</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.get_element_attribute_names"><code class="name flex">
<span>def <span class="ident">get_element_attribute_names</span></span>(<span>self, blkId)</span>
</code></dt>
<dd>
<div class="desc"><p>get the list of element attribute names for a block</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; attr_names = exo.get_element_attribute_names(elem_blk_id)
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>elem_blk_id</code></strong> :&ensp;<code>int</code></dt>
<dd>element block <em>ID</em> (not <em>INDEX</em>)</dd>
</dl>
<h2 id="returns">Returns</h2>
<pre><code>&lt;list&lt;string&gt;&gt;  attr_names
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element_attribute_names(self, blkId):
    &#34;&#34;&#34;
    get the list of element attribute names for a block

    &gt;&gt;&gt; attr_names = exo.get_element_attribute_names(elem_blk_id)

    Parameters
    ----------
    elem_blk_id : int
        element block *ID* (not *INDEX*)

    Returns
    -------
        &lt;list&lt;string&gt;&gt;  attr_names
    &#34;&#34;&#34;
    names = self.__ex_get_elem_attr_names(blkId)
    return list(names)</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.get_element_property_names"><code class="name flex">
<span>def <span class="ident">get_element_property_names</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>get the list of element property names for all element blocks
in the model</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; eprop_names = exo.get_element_property_names()
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>&lt;list&lt;string&gt;&gt;  eprop_names
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element_property_names(self):
    &#34;&#34;&#34;
    get the list of element property names for all element blocks
    in the model

    &gt;&gt;&gt; eprop_names = exo.get_element_property_names()

    Returns
    -------
        &lt;list&lt;string&gt;&gt;  eprop_names
    &#34;&#34;&#34;
    names = self.__ex_get_prop_names(&#39;EX_ELEM_BLOCK&#39;, &#39;EX_INQ_EB_PROP&#39;)
    return list(names)</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.get_element_property_value"><code class="name flex">
<span>def <span class="ident">get_element_property_value</span></span>(<span>self, object_id, name)</span>
</code></dt>
<dd>
<div class="desc"><p>get element property value (an integer) for a specified element
block and element property name</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; eprop_val = exo.get_element_property_value(elem_blk_id, eprop_name)
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>elem_blk_id</code></strong> :&ensp;<code>int</code></dt>
<dd>element block <em>ID</em> (not <em>INDEX</em>)
<string>
eprop_name</dd>
</dl>
<h2 id="returns">Returns</h2>
<pre><code>&lt;int&gt;  eprop_val
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element_property_value(self, object_id, name):
    &#34;&#34;&#34;
    get element property value (an integer) for a specified element
    block and element property name

    &gt;&gt;&gt; eprop_val = exo.get_element_property_value(elem_blk_id, eprop_name)

    Parameters
    ----------
    elem_blk_id : int
        element block *ID* (not *INDEX*)
        &lt;string&gt;  eprop_name

    Returns
    -------
        &lt;int&gt;  eprop_val
    &#34;&#34;&#34;
    propVal = self.__ex_get_prop(&#39;EX_ELEM_BLOCK&#39;, object_id, name)
    return int(propVal)</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.get_element_variable_names"><code class="name flex">
<span>def <span class="ident">get_element_variable_names</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>get the list of element variable names in the model</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; evar_names = exo.get_element_variable_names()
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>  &lt;list&lt;string&gt;&gt;  evar_names
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element_variable_names(self):
    &#34;&#34;&#34;
    get the list of element variable names in the model

    &gt;&gt;&gt; evar_names = exo.get_element_variable_names()

    Returns
    -------
          &lt;list&lt;string&gt;&gt;  evar_names
    &#34;&#34;&#34;
    if self.__ex_get_variable_param(&#39;EX_ELEM_BLOCK&#39;).value == 0:
        return []
    return self.__ex_get_variable_names(&#39;EX_ELEM_BLOCK&#39;)</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.get_element_variable_number"><code class="name flex">
<span>def <span class="ident">get_element_variable_number</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>get the number of element variables in the model</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; num_evars = exo.get_element_variable_number()
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>  &lt;int&gt;  num_evars
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element_variable_number(self):
    &#34;&#34;&#34;
    get the number of element variables in the model

    &gt;&gt;&gt; num_evars = exo.get_element_variable_number()

    Returns
    -------
          &lt;int&gt;  num_evars
    &#34;&#34;&#34;
    return self.__ex_get_variable_param(&#39;EX_ELEM_BLOCK&#39;).value</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.get_element_variable_truth_table"><code class="name flex">
<span>def <span class="ident">get_element_variable_truth_table</span></span>(<span>self, entId=None)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="exodus3.exodus.get_variable_truth_table" href="#exodus3.exodus.get_variable_truth_table">exodus.get_variable_truth_table()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element_variable_truth_table(self, entId=None):
    &#34;&#34;&#34;
    See `exodus.get_variable_truth_table`
    &#34;&#34;&#34;
    return self.get_variable_truth_table(&#39;EX_ELEM_BLOCK&#39;, entId)</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.get_element_variable_values"><code class="name flex">
<span>def <span class="ident">get_element_variable_values</span></span>(<span>self, blockId, name, step)</span>
</code></dt>
<dd>
<div class="desc"><p>get list of element variable values for a specified element
block, element variable name, and time step</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; evar_vals = exo.get_element_variable_values(elem_blk_id,
...                                            evar_name, time_step)
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>elem_blk_id</code></strong> :&ensp;<code>int</code></dt>
<dd>element block <em>ID</em> (not <em>INDEX</em>)</dd>
<dt><strong><code>evar_name</code></strong> :&ensp;<code>string</code></dt>
<dd>name of element variable</dd>
<dt><strong><code>time_step</code></strong> :&ensp;<code>int</code></dt>
<dd>1-based index of time step</dd>
</dl>
<h2 id="returns">Returns</h2>
<pre><code>if array_type == 'ctype':
  &lt;list&lt;ctypes.c_double&gt;&gt;  evar_vals

if array_type == 'numpy':
  &lt;np_array&lt;double&gt;&gt;  evar_vals
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element_variable_values(self, blockId, name, step):
    &#34;&#34;&#34;
    get list of element variable values for a specified element
    block, element variable name, and time step

    &gt;&gt;&gt; evar_vals = exo.get_element_variable_values(elem_blk_id,
    ...                                            evar_name, time_step)

    Parameters
    ----------
    elem_blk_id : int
        element block *ID* (not *INDEX*)
    evar_name : string
        name of element variable
    time_step : int
        1-based index of time step

    Returns
    -------

        if array_type == &#39;ctype&#39;:
          &lt;list&lt;ctypes.c_double&gt;&gt;  evar_vals

        if array_type == &#39;numpy&#39;:
          &lt;np_array&lt;double&gt;&gt;  evar_vals
    &#34;&#34;&#34;
    values = self.get_variable_values(&#39;EX_ELEM_BLOCK&#39;, blockId, name, step)
    return values</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.get_global_variable_names"><code class="name flex">
<span>def <span class="ident">get_global_variable_names</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>get the list of global variable names in the model</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; gvar_names = exo.get_global_variable_names()
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>  &lt;list&lt;string&gt;&gt;  gvar_names
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_global_variable_names(self):
    &#34;&#34;&#34;
    get the list of global variable names in the model

    &gt;&gt;&gt; gvar_names = exo.get_global_variable_names()

    Returns
    -------
          &lt;list&lt;string&gt;&gt;  gvar_names
    &#34;&#34;&#34;
    if self.get_variable_number(&#39;EX_GLOBAL&#39;) == 0:
        return []
    return self.__ex_get_variable_names(&#39;EX_GLOBAL&#39;)</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.get_global_variable_number"><code class="name flex">
<span>def <span class="ident">get_global_variable_number</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>get the number of global variables in the model</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; num_gvars = exo.get_global_variable_number()
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>  &lt;int&gt;  num_gvars
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_global_variable_number(self):
    &#34;&#34;&#34;
    get the number of global variables in the model

    &gt;&gt;&gt; num_gvars = exo.get_global_variable_number()

    Returns
    -------
          &lt;int&gt;  num_gvars
    &#34;&#34;&#34;
    return self.__ex_get_variable_param(&#39;EX_GLOBAL&#39;).value</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.get_global_variable_value"><code class="name flex">
<span>def <span class="ident">get_global_variable_value</span></span>(<span>self, name, step)</span>
</code></dt>
<dd>
<div class="desc"><p>get a global variable value for a specified global variable
name and time step</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; gvar_val = exo.get_global_variable_value(gvar_name, time_step)
</code></pre>
<h2 id="parameters">Parameters</h2>
<pre><code>&lt;string&gt;  gvar_name  name of global variable
&lt;int&gt;     time_step  1-based index of time step
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>&lt;float&gt;  gvar_val
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_global_variable_value(self, name, step):
    &#34;&#34;&#34;
    get a global variable value for a specified global variable
    name and time step

    &gt;&gt;&gt; gvar_val = exo.get_global_variable_value(gvar_name, time_step)

    Parameters
    ----------
        &lt;string&gt;  gvar_name  name of global variable
        &lt;int&gt;     time_step  1-based index of time step

    Returns
    -------
        &lt;float&gt;  gvar_val
    &#34;&#34;&#34;
    names = self.get_variable_names(&#39;EX_GLOBAL&#39;)
    var_id = names.index(name)
    num = self.__ex_get_variable_param(&#39;EX_GLOBAL&#39;)
    gvalues = self.__ex_get_var(step, &#39;EX_GLOBAL&#39;, 0, 1, num.value)
    return gvalues[var_id]</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.get_global_variable_values"><code class="name flex">
<span>def <span class="ident">get_global_variable_values</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>get global variable values over all time steps for one global
variable name</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; gvar_vals = exo.get_global_variable_values(gvar_name)
</code></pre>
<h2 id="parameters">Parameters</h2>
<pre><code>&lt;string&gt;  gvar_name  name of global variable
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>if array_type == 'ctype':
  &lt;list&lt;float&gt;&gt;  gvar_vals

if array_type == 'numpy':
  &lt;np_array&lt;double&gt;&gt;  gvar_vals
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_global_variable_values(self, name):
    &#34;&#34;&#34;
    get global variable values over all time steps for one global
    variable name

    &gt;&gt;&gt; gvar_vals = exo.get_global_variable_values(gvar_name)

    Parameters
    ----------
        &lt;string&gt;  gvar_name  name of global variable

    Returns
    -------

        if array_type == &#39;ctype&#39;:
          &lt;list&lt;float&gt;&gt;  gvar_vals

        if array_type == &#39;numpy&#39;:
          &lt;np_array&lt;double&gt;&gt;  gvar_vals
    &#34;&#34;&#34;
    names = self.get_variable_names(&#39;EX_GLOBAL&#39;)
    var_id = names.index(name)
    num = self.__ex_get_variable_param(&#39;EX_GLOBAL&#39;)
    values = []
    for i in range(self.numTimes.value):
        gvalues = self.__ex_get_var(i + 1, &#39;EX_GLOBAL&#39;, 0, 1, num.value)
        values.append(gvalues[var_id])
    if self.use_numpy:
        values = self.np.array(values)
    return values</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.get_id_map"><code class="name flex">
<span>def <span class="ident">get_id_map</span></span>(<span>self, objType)</span>
</code></dt>
<dd>
<div class="desc"><p>get mapping of exodus node index to user- or application-
defined node id; node_id_map is ordered the same as the nodal
coordinate arrays returned by exo.get_coords() &ndash; this ordering
follows the exodus node <em>INDEX</em> order, a 1-based system going
from 1 to exo.num_nodes(); a user or application can optionally
use a separate node <em>ID</em> numbering system, so the node_id_map
points to the node <em>ID</em> for each node <em>INDEX</em></p>
<pre><code class="language-python-repl">&gt;&gt;&gt; node_id_map = exo.get_node_id_map()
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>if array_type == 'ctype':
  &lt;list&lt;int&gt;&gt;  node_id_map

if array_type == 'numpy':
  &lt;np_array&lt;int&gt;&gt;  node_id_map
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_id_map(self, objType):
    &#34;&#34;&#34;
    get mapping of exodus node index to user- or application-
    defined node id; node_id_map is ordered the same as the nodal
    coordinate arrays returned by exo.get_coords() -- this ordering
    follows the exodus node *INDEX* order, a 1-based system going
    from 1 to exo.num_nodes(); a user or application can optionally
    use a separate node *ID* numbering system, so the node_id_map
    points to the node *ID* for each node *INDEX*

    &gt;&gt;&gt; node_id_map = exo.get_node_id_map()

    Returns
    -------

        if array_type == &#39;ctype&#39;:
          &lt;list&lt;int&gt;&gt;  node_id_map

        if array_type == &#39;numpy&#39;:
          &lt;np_array&lt;int&gt;&gt;  node_id_map
    &#34;&#34;&#34;
    return self.__ex_get_id_map(objType)</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.get_ids"><code class="name flex">
<span>def <span class="ident">get_ids</span></span>(<span>self, objType)</span>
</code></dt>
<dd>
<div class="desc"><p>get mapping of exodus block/set index to user- or application-
defined block/set id; ids is ordered
by the <em>INDEX</em> ordering, a 1-based system going from
1 to number_set_or_block, used by exodus for storage
and input/output of array data stored on the blocks/sets; a
user or application can optionally use a separate block/set
<em>ID</em> numbering system, so the ids array points to the
block/set <em>ID</em> for each set <em>INDEX</em></p>
<pre><code class="language-python-repl">&gt;&gt;&gt; node_set_ids = exo.get_ids('EX_NODE_SET')
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>if array_type == 'ctype':
  &lt;list&lt;int&gt;&gt;  ids

if array_type == 'numpy':
  &lt;np_array&lt;int&gt;&gt;  ids
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_ids(self, objType):
    &#34;&#34;&#34;
    get mapping of exodus block/set index to user- or application-
    defined block/set id; ids is ordered
    by the *INDEX* ordering, a 1-based system going from
    1 to number_set_or_block, used by exodus for storage
    and input/output of array data stored on the blocks/sets; a
    user or application can optionally use a separate block/set
    *ID* numbering system, so the ids array points to the
    block/set *ID* for each set *INDEX*

    &gt;&gt;&gt; node_set_ids = exo.get_ids(&#39;EX_NODE_SET&#39;)

    Returns
    -------

        if array_type == &#39;ctype&#39;:
          &lt;list&lt;int&gt;&gt;  ids

        if array_type == &#39;numpy&#39;:
          &lt;np_array&lt;int&gt;&gt;  ids
    &#34;&#34;&#34;
    ids = self.__ex_get_ids(objType)
    if self.use_numpy:
        ids = self.np.array(ids)
    return ids</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.get_info_records"><code class="name flex">
<span>def <span class="ident">get_info_records</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>get a list info records where each entry in the list is one info
record, e.g. a line of an input deck</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; info_recs = exo.get_info_records()
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>info_recs</code></strong> :&ensp;<code>&lt;list&lt;string&gt;&gt;</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_info_records(self):
    &#34;&#34;&#34;
    get a list info records where each entry in the list is one info
    record, e.g. a line of an input deck

    &gt;&gt;&gt; info_recs = exo.get_info_records()

    Returns
    -------
    info_recs : &lt;list&lt;string&gt;&gt;

    &#34;&#34;&#34;
    info_recs = self.__ex_get_info_recs()
    return info_recs</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.get_name"><code class="name flex">
<span>def <span class="ident">get_name</span></span>(<span>self, object_type, object_id)</span>
</code></dt>
<dd>
<div class="desc"><p>get the name of the specified entity_type and entity</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; elem_blk_name = exo.get_name('EX_ELEM_BLOCK', elem_blk_id)
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>object_type</code></strong> :&ensp;<code>int</code></dt>
<dd>block/set type</dd>
<dt><strong><code>object_id</code></strong> :&ensp;<code>int</code></dt>
<dd>block/set <em>ID</em> (not <em>INDEX</em>)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>string</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_name(self, object_type, object_id):
    &#34;&#34;&#34;
    get the name of the specified entity_type and entity

    &gt;&gt;&gt; elem_blk_name = exo.get_name(&#39;EX_ELEM_BLOCK&#39;, elem_blk_id)

    Parameters
    ----------
    object_type : int
        block/set type
    object_id : int
        block/set *ID* (not *INDEX*)

    Returns
    -------
    name : string
    &#34;&#34;&#34;
    name = self.__ex_get_name(object_type, object_id)
    return name</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.get_names"><code class="name flex">
<span>def <span class="ident">get_names</span></span>(<span>self, object_type)</span>
</code></dt>
<dd>
<div class="desc"><p>get a list of all block/set names ordered by block/set <em>INDEX</em>;
(see <code><a title="exodus3.exodus.get_ids" href="#exodus3.exodus.get_ids">exodus.get_ids()</a></code> for explanation of the
difference between <em>ID</em> and <em>INDEX</em>)</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; blk_names = exo.get_names('EX_ELEM_BLOCK')
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>object_type</code></strong> :&ensp;<code>int</code></dt>
<dd>block/set type</dd>
</dl>
<h2 id="returns">Returns</h2>
<pre><code>&lt;list&lt;string&gt;&gt;  names
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_names(self, object_type):
    &#34;&#34;&#34;
    get a list of all block/set names ordered by block/set *INDEX*;
    (see `exodus.get_ids` for explanation of the
    difference between *ID* and *INDEX*)

    &gt;&gt;&gt; blk_names = exo.get_names(&#39;EX_ELEM_BLOCK&#39;)

    Parameters
    ----------
    object_type : int
        block/set type

    Returns
    -------
        &lt;list&lt;string&gt;&gt;  names
    &#34;&#34;&#34;
    names = self.__ex_get_names(object_type)
    return names</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.get_node_id_map"><code class="name flex">
<span>def <span class="ident">get_node_id_map</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>get mapping of exodus node index to user- or application-
defined node id; node_id_map is ordered the same as the nodal
coordinate arrays returned by exo.get_coords() &ndash; this ordering
follows the exodus node <em>INDEX</em> order, a 1-based system going
from 1 to exo.num_nodes(); a user or application can optionally
use a separate node <em>ID</em> numbering system, so the node_id_map
points to the node <em>ID</em> for each node <em>INDEX</em></p>
<pre><code class="language-python-repl">&gt;&gt;&gt; node_id_map = exo.get_node_id_map()
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>if array_type == 'ctype':
  &lt;list&lt;int&gt;&gt;  node_id_map

if array_type == 'numpy':
  &lt;np_array&lt;int&gt;&gt;  node_id_map
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_node_id_map(self):
    &#34;&#34;&#34;
    get mapping of exodus node index to user- or application-
    defined node id; node_id_map is ordered the same as the nodal
    coordinate arrays returned by exo.get_coords() -- this ordering
    follows the exodus node *INDEX* order, a 1-based system going
    from 1 to exo.num_nodes(); a user or application can optionally
    use a separate node *ID* numbering system, so the node_id_map
    points to the node *ID* for each node *INDEX*

    &gt;&gt;&gt; node_id_map = exo.get_node_id_map()

    Returns
    -------

        if array_type == &#39;ctype&#39;:
          &lt;list&lt;int&gt;&gt;  node_id_map

        if array_type == &#39;numpy&#39;:
          &lt;np_array&lt;int&gt;&gt;  node_id_map
    &#34;&#34;&#34;
    return self.__ex_get_id_map(&#39;EX_NODE_MAP&#39;)</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.get_node_num_map"><code class="name flex">
<span>def <span class="ident">get_node_num_map</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p><strong>DEPRECATED</strong> use: <code>get_node_id_map()</code></p>
<p>get mapping of exodus node index to user- or application-
defined node id; node_id_map is ordered the same as the nodal
coordinate arrays returned by exo.get_coords() &ndash; this ordering
follows the exodus node <em>INDEX</em> order, a 1-based system going
from 1 to exo.num_nodes(); a user or application can optionally
use a separate node <em>ID</em> numbering system, so the node_id_map
points to the node <em>ID</em> for each node <em>INDEX</em></p>
<pre><code class="language-python-repl">&gt;&gt;&gt; node_id_map = exo.get_node_num_map()
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>&lt;list&lt;ctypes.c_int&gt;&gt;  node_id_map
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_node_num_map(self):
    &#34;&#34;&#34;
    **DEPRECATED** use: `get_node_id_map()`

    get mapping of exodus node index to user- or application-
    defined node id; node_id_map is ordered the same as the nodal
    coordinate arrays returned by exo.get_coords() -- this ordering
    follows the exodus node *INDEX* order, a 1-based system going
    from 1 to exo.num_nodes(); a user or application can optionally
    use a separate node *ID* numbering system, so the node_id_map
    points to the node *ID* for each node *INDEX*

    &gt;&gt;&gt; node_id_map = exo.get_node_num_map()

    Returns
    -------
        &lt;list&lt;ctypes.c_int&gt;&gt;  node_id_map
    &#34;&#34;&#34;
    nodeNumMap = self.__ex_get_node_num_map()
    return nodeNumMap</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.get_node_set_dist_facts"><code class="name flex">
<span>def <span class="ident">get_node_set_dist_facts</span></span>(<span>self, object_id)</span>
</code></dt>
<dd>
<div class="desc"><p>get the list of distribution factors for nodes in a node set</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; ns_dist_facts = exo.get_node_set_dist_facts(node_set_id)
</code></pre>
<h2 id="parameters">Parameters</h2>
<pre><code>&lt;int&gt;        node_set_id  node set *ID* (not *INDEX*)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>if array_type == 'ctype':
  &lt;list&lt;float&gt;&gt;  ns_dist_facts  a list of distribution factors,
    e.g. nodal 'weights'

if array_type == 'numpy':
  &lt;np_array&lt;double&gt;&gt;  ns_dist_facts  a list of distribution
    factors, e.g. nodal
    'weights'
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_node_set_dist_facts(self, object_id):
    &#34;&#34;&#34;
    get the list of distribution factors for nodes in a node set

    &gt;&gt;&gt; ns_dist_facts = exo.get_node_set_dist_facts(node_set_id)

    Parameters
    ----------
        &lt;int&gt;        node_set_id  node set *ID* (not *INDEX*)

    Returns
    -------

        if array_type == &#39;ctype&#39;:
          &lt;list&lt;float&gt;&gt;  ns_dist_facts  a list of distribution factors,
            e.g. nodal &#39;weights&#39;

        if array_type == &#39;numpy&#39;:
          &lt;np_array&lt;double&gt;&gt;  ns_dist_facts  a list of distribution
            factors, e.g. nodal
            &#39;weights&#39;
    &#34;&#34;&#34;
    node_set_dfs = self.__ex_get_node_set_dist_fact(object_id)
    node_set_dfs = list(node_set_dfs)
    if self.use_numpy:
        node_set_dfs = self.np.array(node_set_dfs)
    return node_set_dfs</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.get_node_set_ids"><code class="name flex">
<span>def <span class="ident">get_node_set_ids</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>get mapping of exodus node set index to user- or application-
defined node set id; node_set_ids is ordered
by the <em>INDEX</em> ordering, a 1-based system going from
1 to exo.num_node_sets(), used by exodus for storage
and input/output of array data stored on the node sets; a
user or application can optionally use a separate node set
<em>ID</em> numbering system, so the node_set_ids array points to the
node set <em>ID</em> for each node set <em>INDEX</em></p>
<pre><code class="language-python-repl">&gt;&gt;&gt; node_set_ids = exo.get_ids('EX_NODE_SET')
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>if array_type == 'ctype':
  &lt;list&lt;int&gt;&gt;  node_set_ids

if array_type == 'numpy':
  &lt;np_array&lt;int&gt;&gt;  node_set_ids
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_node_set_ids(self):
    &#34;&#34;&#34;
    get mapping of exodus node set index to user- or application-
    defined node set id; node_set_ids is ordered
    by the *INDEX* ordering, a 1-based system going from
    1 to exo.num_node_sets(), used by exodus for storage
    and input/output of array data stored on the node sets; a
    user or application can optionally use a separate node set
    *ID* numbering system, so the node_set_ids array points to the
    node set *ID* for each node set *INDEX*

    &gt;&gt;&gt; node_set_ids = exo.get_ids(&#39;EX_NODE_SET&#39;)

    Returns
    -------

        if array_type == &#39;ctype&#39;:
          &lt;list&lt;int&gt;&gt;  node_set_ids

        if array_type == &#39;numpy&#39;:
          &lt;np_array&lt;int&gt;&gt;  node_set_ids
    &#34;&#34;&#34;
    return self.get_ids(&#39;EX_NODE_SET&#39;)</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.get_node_set_name"><code class="name flex">
<span>def <span class="ident">get_node_set_name</span></span>(<span>self, object_id)</span>
</code></dt>
<dd>
<div class="desc"><p>get the name of a node set</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; node_set_name = exo.get_node_set_name(node_set_id)
</code></pre>
<h2 id="parameters">Parameters</h2>
<pre><code>&lt;int&gt;  node_set_id  node set *ID* (not *INDEX*)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>&lt;string&gt;  node_set_name
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_node_set_name(self, object_id):
    &#34;&#34;&#34;
    get the name of a node set

    &gt;&gt;&gt; node_set_name = exo.get_node_set_name(node_set_id)

    Parameters
    ----------
        &lt;int&gt;  node_set_id  node set *ID* (not *INDEX*)

    Returns
    -------
        &lt;string&gt;  node_set_name
    &#34;&#34;&#34;
    return self.__ex_get_name(&#39;EX_NODE_SET&#39;, object_id)</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.get_node_set_names"><code class="name flex">
<span>def <span class="ident">get_node_set_names</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>get a list of all node set names ordered by node set <em>INDEX</em>;
(see <code><a title="exodus3.exodus.get_ids" href="#exodus3.exodus.get_ids">exodus.get_ids()</a></code> for explanation of the
difference between node set <em>ID</em> and node set <em>INDEX</em>)</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; node_set_names = exo.get_node_set_names()
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>&lt;list&lt;string&gt;&gt;  node_set_names
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_node_set_names(self):
    &#34;&#34;&#34;
    get a list of all node set names ordered by node set *INDEX*;
    (see `exodus.get_ids` for explanation of the
    difference between node set *ID* and node set *INDEX*)

    &gt;&gt;&gt; node_set_names = exo.get_node_set_names()

    Returns
    -------
        &lt;list&lt;string&gt;&gt;  node_set_names
    &#34;&#34;&#34;
    nodeSetNames = self.__ex_get_names(&#39;EX_NODE_SET&#39;)
    return nodeSetNames</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.get_node_set_nodes"><code class="name flex">
<span>def <span class="ident">get_node_set_nodes</span></span>(<span>self, object_id)</span>
</code></dt>
<dd>
<div class="desc"><p>get the list of node <em>INDICES</em> in a node set
(see <code><a title="exodus3.exodus.get_id_map" href="#exodus3.exodus.get_id_map">exodus.get_id_map()</a></code> for explanation of node <em>INDEX</em>
versus node <em>ID</em>)</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; ns_nodes = exo.get_node_set_nodes(node_set_id)
</code></pre>
<h2 id="parameters">Parameters</h2>
<pre><code>&lt;int&gt;  node_set_id  node set *ID* (not *INDEX*)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>if array_type == 'ctype':
  &lt;list&lt;int&gt;&gt;  ns_nodes

if array_type == 'numpy':
  &lt;np_array&lt;int&gt;&gt;  ns_nodes
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_node_set_nodes(self, object_id):
    &#34;&#34;&#34;
    get the list of node *INDICES* in a node set
    (see `exodus.get_id_map` for explanation of node *INDEX*
    versus node *ID*)

    &gt;&gt;&gt; ns_nodes = exo.get_node_set_nodes(node_set_id)

    Parameters
    ----------
        &lt;int&gt;  node_set_id  node set *ID* (not *INDEX*)

    Returns
    -------

        if array_type == &#39;ctype&#39;:
          &lt;list&lt;int&gt;&gt;  ns_nodes

        if array_type == &#39;numpy&#39;:
          &lt;np_array&lt;int&gt;&gt;  ns_nodes
    &#34;&#34;&#34;
    node_set_ids = self.get_ids(&#39;EX_NODE_SET&#39;)
    assert object_id in node_set_ids
    node_set_nodes = self.__ex_get_node_set(object_id)
    node_set_nodes = list(node_set_nodes)
    if self.use_numpy:
        node_set_nodes = self.np.array(node_set_nodes)
    return node_set_nodes</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.get_node_set_params"><code class="name flex">
<span>def <span class="ident">get_node_set_params</span></span>(<span>self, object_id)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="exodus3.exodus.put_set_params" href="#exodus3.exodus.put_set_params">exodus.put_set_params()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_node_set_params(self, object_id):
    &#34;&#34;&#34; See `exodus.put_set_params` &#34;&#34;&#34;

    (numSetNodes, numSetDistFacts) = self.__ex_get_set_param(&#39;EX_NODE_SET&#39;, object_id)
    return numSetNodes, numSetDistFacts</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.get_node_set_property_names"><code class="name flex">
<span>def <span class="ident">get_node_set_property_names</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>get the list of node set property names for all node sets in
the model</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; nsprop_names = exo.get_node_set_property_names()
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>&lt;list&lt;string&gt;&gt;  nsprop_names
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_node_set_property_names(self):
    &#34;&#34;&#34;
    get the list of node set property names for all node sets in
    the model

    &gt;&gt;&gt; nsprop_names = exo.get_node_set_property_names()

    Returns
    -------
        &lt;list&lt;string&gt;&gt;  nsprop_names
    &#34;&#34;&#34;
    names = self.__ex_get_prop_names(&#39;EX_NODE_SET&#39;, &#39;EX_INQ_NS_PROP&#39;)
    return list(names)</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.get_node_set_property_value"><code class="name flex">
<span>def <span class="ident">get_node_set_property_value</span></span>(<span>self, object_id, name)</span>
</code></dt>
<dd>
<div class="desc"><p>get node set property value (an integer) for a specified node
set and node set property name</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; nsprop_val = exo.get_node_set_property_value(node_set_id, nsprop_name)
</code></pre>
<h2 id="parameters">Parameters</h2>
<pre><code>&lt;int&gt;     node_set_id  node set *ID* (not *INDEX*)
&lt;string&gt;  nsprop_name
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>&lt;int&gt;  nsprop_val
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_node_set_property_value(self, object_id, name):
    &#34;&#34;&#34;
    get node set property value (an integer) for a specified node
    set and node set property name

    &gt;&gt;&gt; nsprop_val = exo.get_node_set_property_value(node_set_id, nsprop_name)

    Parameters
    ----------
        &lt;int&gt;     node_set_id  node set *ID* (not *INDEX*)
        &lt;string&gt;  nsprop_name

    Returns
    -------
        &lt;int&gt;  nsprop_val
    &#34;&#34;&#34;
    propVal = self.__ex_get_prop(&#39;EX_NODE_SET&#39;, object_id, name)
    return int(propVal)</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.get_node_set_variable_names"><code class="name flex">
<span>def <span class="ident">get_node_set_variable_names</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>get the list of node set variable names in the model</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; nsvar_names = exo.get_node_set_variable_names()
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>  &lt;list&lt;string&gt;&gt;  nsvar_names
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_node_set_variable_names(self):
    &#34;&#34;&#34;
    get the list of node set variable names in the model

    &gt;&gt;&gt; nsvar_names = exo.get_node_set_variable_names()

    Returns
    -------
          &lt;list&lt;string&gt;&gt;  nsvar_names
    &#34;&#34;&#34;
    if self.__ex_get_variable_param(&#39;EX_NODE_SET&#39;).value == 0:
        return []
    return self.__ex_get_variable_names(&#39;EX_NODE_SET&#39;)</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.get_node_set_variable_number"><code class="name flex">
<span>def <span class="ident">get_node_set_variable_number</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>get the number of node set variables in the model</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; num_nsvars = exo.get_node_set_variable_number()
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>  &lt;int&gt;  num_nsvars
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_node_set_variable_number(self):
    &#34;&#34;&#34;
    get the number of node set variables in the model

    &gt;&gt;&gt; num_nsvars = exo.get_node_set_variable_number()

    Returns
    -------
          &lt;int&gt;  num_nsvars
    &#34;&#34;&#34;
    return self.__ex_get_variable_param(&#39;EX_NODE_SET&#39;).value</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.get_node_set_variable_truth_table"><code class="name flex">
<span>def <span class="ident">get_node_set_variable_truth_table</span></span>(<span>self, entId=None)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="exodus3.exodus.get_variable_truth_table" href="#exodus3.exodus.get_variable_truth_table">exodus.get_variable_truth_table()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_node_set_variable_truth_table(self, entId=None):
    &#34;&#34;&#34;
    See `exodus.get_variable_truth_table`
    &#34;&#34;&#34;
    return self.get_variable_truth_table(&#39;EX_NODE_SET&#39;, entId)</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.get_node_set_variable_values"><code class="name flex">
<span>def <span class="ident">get_node_set_variable_values</span></span>(<span>self, object_id, name, step)</span>
</code></dt>
<dd>
<div class="desc"><p>get list of node set variable values for a specified node
set, node set variable name, and time step; the list has
one variable value per node in the set</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; nsvar_vals =
...   exo.get_node_set_variable_values(node_set_id,
...    nsvar_name, time_step)
</code></pre>
<h2 id="parameters">Parameters</h2>
<pre><code>&lt;int&gt;     node_set_id  node set *ID* (not *INDEX*)
&lt;string&gt;  nsvar_name   name of node set variable
&lt;int&gt;     time_step    1-based index of time step
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>if array_type == 'ctype':
  &lt;list&lt;ctypes.c_double&gt;&gt;  nsvar_vals

if array_type == 'numpy':
  &lt;np_array&lt;double&gt;&gt;  nsvar_vals
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_node_set_variable_values(self, object_id, name, step):
    &#34;&#34;&#34;
    get list of node set variable values for a specified node
    set, node set variable name, and time step; the list has
    one variable value per node in the set

    &gt;&gt;&gt; nsvar_vals =
    ...   exo.get_node_set_variable_values(node_set_id,
    ...    nsvar_name, time_step)

    Parameters
    ----------
        &lt;int&gt;     node_set_id  node set *ID* (not *INDEX*)
        &lt;string&gt;  nsvar_name   name of node set variable
        &lt;int&gt;     time_step    1-based index of time step

    Returns
    -------

        if array_type == &#39;ctype&#39;:
          &lt;list&lt;ctypes.c_double&gt;&gt;  nsvar_vals

        if array_type == &#39;numpy&#39;:
          &lt;np_array&lt;double&gt;&gt;  nsvar_vals
    &#34;&#34;&#34;
    values = self.get_variable_values(&#39;EX_NODE_SET&#39;, object_id, name, step)
    return values</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.get_node_variable_names"><code class="name flex">
<span>def <span class="ident">get_node_variable_names</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>get the list of nodal variable names in the model</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; nvar_names = exo.get_node_variable_names()
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>  &lt;list&lt;string&gt;&gt;  nvar_names
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_node_variable_names(self):
    &#34;&#34;&#34;
    get the list of nodal variable names in the model

    &gt;&gt;&gt; nvar_names = exo.get_node_variable_names()

    Returns
    -------
          &lt;list&lt;string&gt;&gt;  nvar_names
    &#34;&#34;&#34;
    if self.__ex_get_variable_param(&#39;EX_NODAL&#39;).value == 0:
        return []
    return self.__ex_get_variable_names(&#39;EX_NODAL&#39;)</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.get_node_variable_number"><code class="name flex">
<span>def <span class="ident">get_node_variable_number</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>get the number of nodal variables in the model</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; num_nvars = exo.get_node_variable_number()
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>num_nvars</code></strong> :&ensp;<code>int</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_node_variable_number(self):
    &#34;&#34;&#34;
    get the number of nodal variables in the model

    &gt;&gt;&gt; num_nvars = exo.get_node_variable_number()

    Returns
    -------
    num_nvars : int
    &#34;&#34;&#34;
    return self.__ex_get_variable_param(&#39;EX_NODAL&#39;).value</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.get_node_variable_values"><code class="name flex">
<span>def <span class="ident">get_node_variable_values</span></span>(<span>self, name, step)</span>
</code></dt>
<dd>
<div class="desc"><p>get list of nodal variable values for a nodal variable name
and time step</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; nvar_vals = exo.get_node_variable_values(nvar_name, time_step)
</code></pre>
<h2 id="parameters">Parameters</h2>
<pre><code>&lt;string&gt;  nvar_name  name of nodal variable
&lt;int&gt;     time_step  1-based index of time step
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>if array_type == 'ctype':
  &lt;list&lt;ctypes.c_double&gt;&gt;  nvar_vals

if array_type == 'numpy':
  &lt;np_array&lt;double&gt;&gt;  nvar_vals
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_node_variable_values(self, name, step):
    &#34;&#34;&#34;
    get list of nodal variable values for a nodal variable name
    and time step

    &gt;&gt;&gt; nvar_vals = exo.get_node_variable_values(nvar_name, time_step)

    Parameters
    ----------
        &lt;string&gt;  nvar_name  name of nodal variable
        &lt;int&gt;     time_step  1-based index of time step

    Returns
    -------

        if array_type == &#39;ctype&#39;:
          &lt;list&lt;ctypes.c_double&gt;&gt;  nvar_vals

        if array_type == &#39;numpy&#39;:
          &lt;np_array&lt;double&gt;&gt;  nvar_vals
    &#34;&#34;&#34;
    names = self.get_variable_names(&#39;EX_NODAL&#39;)
    var_id = names.index(name) + 1
    numVals = self.num_nodes()
    values = self.__ex_get_var(step, &#39;EX_NODAL&#39;, var_id, 0, numVals)
    if self.use_numpy:
        values = ctype_to_numpy(self, values)
    return values</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.get_partial_element_variable_values"><code class="name flex">
<span>def <span class="ident">get_partial_element_variable_values</span></span>(<span>self, blockId, name, step, start_index, num_elements)</span>
</code></dt>
<dd>
<div class="desc"><p>get list of element variable values for a specified element
block, element variable name, and time step</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; evar_vals = exo.get_element_variable_values(elem_blk_id,
...                                            evar_name, time_step)
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>elem_blk_id</code></strong> :&ensp;<code>int</code></dt>
<dd>element block <em>ID</em> (not <em>INDEX</em>)</dd>
<dt><strong><code>evar_name</code></strong> :&ensp;<code>string</code></dt>
<dd>name of element variable</dd>
<dt><strong><code>time_step</code></strong> :&ensp;<code>int</code></dt>
<dd>1-based index of time step</dd>
<dt><strong><code>start_index</code></strong> :&ensp;<code>int</code></dt>
<dd>1-based index of element in block to start returning data</dd>
<dt><strong><code>num_elements</code></strong> :&ensp;<code>int</code></dt>
<dd>number of elements to return data for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<pre><code>if array_type == 'ctype':
  &lt;list&lt;ctypes.c_double&gt;&gt;  evar_vals

if array_type == 'numpy':
  &lt;np_array&lt;double&gt;&gt;  evar_vals
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_partial_element_variable_values(self, blockId, name, step, start_index, num_elements):
    &#34;&#34;&#34;
    get list of element variable values for a specified element
    block, element variable name, and time step

    &gt;&gt;&gt; evar_vals = exo.get_element_variable_values(elem_blk_id,
    ...                                            evar_name, time_step)

    Parameters
    ----------
    elem_blk_id : int
        element block *ID* (not *INDEX*)
    evar_name : string
        name of element variable
    time_step : int
        1-based index of time step
    start_index: int
        1-based index of element in block to start returning data
    num_elements: int
        number of elements to return data for.

    Returns
    -------

        if array_type == &#39;ctype&#39;:
          &lt;list&lt;ctypes.c_double&gt;&gt;  evar_vals

        if array_type == &#39;numpy&#39;:
          &lt;np_array&lt;double&gt;&gt;  evar_vals
    &#34;&#34;&#34;
    names = self.get_variable_names(&#39;EX_ELEM_BLOCK&#39;)
    var_id = names.index(name) + 1
    values = self.__ex_get_partial_var(step, &#39;EX_ELEM_BLOCK&#39;, var_id, blockId, start_index, num_elements)
    if self.use_numpy:
        values = ctype_to_numpy(self, values)
    return values</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.get_partial_node_set_variable_values"><code class="name flex">
<span>def <span class="ident">get_partial_node_set_variable_values</span></span>(<span>self, object_id, name, step, start_index, num_nodes)</span>
</code></dt>
<dd>
<div class="desc"><p>get list of node set variable values for a specified node
set, node set variable name, and time step; the list has
one variable value per node in the set</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; nsvar_vals =
...   exo.get_node_set_variable_values(node_set_id,
...    nsvar_name, time_step)
</code></pre>
<h2 id="parameters">Parameters</h2>
<pre><code>&lt;int&gt;     node_set_id  node set *ID* (not *INDEX*)
&lt;string&gt;  nsvar_name   name of node set variable
&lt;int&gt;     time_step    1-based index of time step
&lt;int&gt;     start_index 1-based index of node to start returning data
&lt;int&gt;     num_nodes   number of nodes to return data for.
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>if array_type == 'ctype':
  &lt;list&lt;ctypes.c_double&gt;&gt;  nsvar_vals

if array_type == 'numpy':
  &lt;np_array&lt;double&gt;&gt;  nsvar_vals
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_partial_node_set_variable_values(self, object_id, name, step, start_index, num_nodes):
    &#34;&#34;&#34;
    get list of node set variable values for a specified node
    set, node set variable name, and time step; the list has
    one variable value per node in the set

    &gt;&gt;&gt; nsvar_vals =
    ...   exo.get_node_set_variable_values(node_set_id,
    ...    nsvar_name, time_step)

    Parameters
    ----------
        &lt;int&gt;     node_set_id  node set *ID* (not *INDEX*)
        &lt;string&gt;  nsvar_name   name of node set variable
        &lt;int&gt;     time_step    1-based index of time step
        &lt;int&gt;     start_index 1-based index of node to start returning data
        &lt;int&gt;     num_nodes   number of nodes to return data for.

    Returns
    -------

        if array_type == &#39;ctype&#39;:
          &lt;list&lt;ctypes.c_double&gt;&gt;  nsvar_vals

        if array_type == &#39;numpy&#39;:
          &lt;np_array&lt;double&gt;&gt;  nsvar_vals
    &#34;&#34;&#34;
    names = self.get_variable_names(&#39;EX_NODE_SET&#39;)
    var_id = names.index(name) + 1
    values = self.__ex_get_partial_var(step, &#39;EX_NODE_SET&#39;, var_id, object_id, start_index, num_nodes)
    if self.use_numpy:
        values = ctype_to_numpy(self, values)
    return values</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.get_partial_node_variable_values"><code class="name flex">
<span>def <span class="ident">get_partial_node_variable_values</span></span>(<span>self, name, step, start_index, num_nodes)</span>
</code></dt>
<dd>
<div class="desc"><p>get partial list of nodal variable values for a nodal variable name
and time step.
Start at node <code>node_index</code> (1-based) and return <code>num_nodes</code>
from that point.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; nvar_vals = exo.get_partial_node_variable_values(nvar_name, time_step, 10, 100)
</code></pre>
<h2 id="parameters">Parameters</h2>
<pre><code>&lt;string&gt;  nvar_name   name of nodal variable
&lt;int&gt;     time_step   1-based index of time step
&lt;int&gt;     start_index 1-based index of node to start returning data
&lt;int&gt;     num_nodes   number of nodes to return data for.
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>if array_type == 'ctype':
  &lt;list&lt;ctypes.c_double&gt;&gt;  nvar_vals

if array_type == 'numpy':
  &lt;np_array&lt;double&gt;&gt;  nvar_vals
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_partial_node_variable_values(self, name, step, start_index, num_nodes):
    &#34;&#34;&#34;
    get partial list of nodal variable values for a nodal variable name
    and time step.  Start at node `node_index` (1-based) and return `num_nodes`
    from that point.

    &gt;&gt;&gt; nvar_vals = exo.get_partial_node_variable_values(nvar_name, time_step, 10, 100)

    Parameters
    ----------
        &lt;string&gt;  nvar_name   name of nodal variable
        &lt;int&gt;     time_step   1-based index of time step
        &lt;int&gt;     start_index 1-based index of node to start returning data
        &lt;int&gt;     num_nodes   number of nodes to return data for.

    Returns
    -------

        if array_type == &#39;ctype&#39;:
          &lt;list&lt;ctypes.c_double&gt;&gt;  nvar_vals

        if array_type == &#39;numpy&#39;:
          &lt;np_array&lt;double&gt;&gt;  nvar_vals
    &#34;&#34;&#34;
    names = self.get_variable_names(&#39;EX_NODAL&#39;)
    var_id = names.index(name) + 1
    values = self.__ex_get_partial_var(step, &#39;EX_NODAL&#39;, var_id, 0, start_index, num_nodes)
    if self.use_numpy:
        values = ctype_to_numpy(self, values)
    return values</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.get_partial_side_set_variable_values"><code class="name flex">
<span>def <span class="ident">get_partial_side_set_variable_values</span></span>(<span>self, object_id, name, step, start_index, num_sides)</span>
</code></dt>
<dd>
<div class="desc"><p>get list of side set variable values for a specified side
set, side set variable name, and time step; the list has
one variable value per side in the set</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; ssvar_vals = exo.get_side_set_variable_values(side_set_id,
...    ssvar_name, time_step)
</code></pre>
<h2 id="parameters">Parameters</h2>
<pre><code>&lt;int&gt;     side_set_id  side set *ID* (not *INDEX*)
&lt;string&gt;  ssvar_name   name of side set variable
&lt;int&gt;     time_step    1-based index of time step
&lt;int&gt;     start_index 1-based index of side to start returning data
&lt;int&gt;     num_nodes   number of sides to return data for.
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>if array_type == 'ctype':
  &lt;list&lt;ctypes.c_double&gt;&gt;  ssvar_vals

if array_type == 'numpy':
  &lt;np_array&lt;double&gt;&gt;  ssvar_vals
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_partial_side_set_variable_values(self, object_id, name, step, start_index, num_sides):
    &#34;&#34;&#34;
    get list of side set variable values for a specified side
    set, side set variable name, and time step; the list has
    one variable value per side in the set

    &gt;&gt;&gt; ssvar_vals = exo.get_side_set_variable_values(side_set_id,
    ...    ssvar_name, time_step)

    Parameters
    ----------
        &lt;int&gt;     side_set_id  side set *ID* (not *INDEX*)
        &lt;string&gt;  ssvar_name   name of side set variable
        &lt;int&gt;     time_step    1-based index of time step
        &lt;int&gt;     start_index 1-based index of side to start returning data
        &lt;int&gt;     num_nodes   number of sides to return data for.

    Returns
    -------

        if array_type == &#39;ctype&#39;:
          &lt;list&lt;ctypes.c_double&gt;&gt;  ssvar_vals

        if array_type == &#39;numpy&#39;:
          &lt;np_array&lt;double&gt;&gt;  ssvar_vals
    &#34;&#34;&#34;
    names = self.get_variable_names(&#39;EX_SIDE_SET&#39;)
    var_id = names.index(name) + 1
    values = self.__ex_get_partial_var(step, &#39;EX_SIDE_SET&#39;, var_id, object_id, start_index, num_sides)
    if self.use_numpy:
        values = ctype_to_numpy(self, values)
    return values</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.get_qa_records"><code class="name flex">
<span>def <span class="ident">get_qa_records</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>get a list of QA records where each QA record is a length-4 tuple of strings:
1. the software name that accessed/modified the database
2. the software descriptor, e.g. version
3. additional software data
4. time stamp</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; qa_recs = exo.get_qa_records()
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>qa_recs</code></strong> :&ensp;<code>&lt;list&lt;tuple[4]&lt;string&gt;&gt;&gt;</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_qa_records(self):
    &#34;&#34;&#34;
    get a list of QA records where each QA record is a length-4 tuple of strings:
      1. the software name that accessed/modified the database
      2. the software descriptor, e.g. version
      3. additional software data
      4. time stamp

    &gt;&gt;&gt; qa_recs = exo.get_qa_records()


    Returns
    -------
    qa_recs : &lt;list&lt;tuple[4]&lt;string&gt;&gt;&gt;
    &#34;&#34;&#34;
    return self.__ex_get_qa()</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.get_reduction_variable_name"><code class="name flex">
<span>def <span class="ident">get_reduction_variable_name</span></span>(<span>self, objType, varId)</span>
</code></dt>
<dd>
<div class="desc"><p>get a single reduction variable name in the model for the specified object type and index.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; nar_name = exo.get_reduction_variable_name('EX_ASSEMBL&quot;Y', 100)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>  string  nvar_name
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_reduction_variable_name(self, objType, varId):
    &#34;&#34;&#34;
    get a single reduction variable name in the model for the specified object type and index.

    &gt;&gt;&gt; nar_name = exo.get_reduction_variable_name(&#39;EX_ASSEMBL&#34;Y&#39;, 100)

    Returns
    -------
          string  nvar_name
    &#34;&#34;&#34;
    if self.__ex_get_reduction_variable_param(objType).value == 0:
        return &#34;&#34;
    return self.__ex_get_reduction_variable_name(objType, varId)</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.get_reduction_variable_names"><code class="name flex">
<span>def <span class="ident">get_reduction_variable_names</span></span>(<span>self, objType)</span>
</code></dt>
<dd>
<div class="desc"><p>get the list of reduction variable names in the model for the specified object type.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; nar_names = exo.get_reduction_variable_names('EX_ASSEMBL&quot;Y')
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>  &lt;list&lt;string&gt;&gt;  nvar_names
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_reduction_variable_names(self, objType):
    &#34;&#34;&#34;
    get the list of reduction variable names in the model for the specified object type.

    &gt;&gt;&gt; nar_names = exo.get_reduction_variable_names(&#39;EX_ASSEMBL&#34;Y&#39;)

    Returns
    -------
          &lt;list&lt;string&gt;&gt;  nvar_names
    &#34;&#34;&#34;
    if self.__ex_get_reduction_variable_param(objType).value == 0:
        return []
    return self.__ex_get_reduction_variable_names(objType)</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.get_reduction_variable_number"><code class="name flex">
<span>def <span class="ident">get_reduction_variable_number</span></span>(<span>self, objType)</span>
</code></dt>
<dd>
<div class="desc"><p>get the number of reduction variables of the specified type in the model</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; num_nvars = exo.get_reduction_variable_number('EX_ASSEMBLY')
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>num_nvars</code></strong> :&ensp;<code>&lt;int&gt;</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_reduction_variable_number(self, objType):
    &#34;&#34;&#34;
    get the number of reduction variables of the specified type in the model

    &gt;&gt;&gt; num_nvars = exo.get_reduction_variable_number(&#39;EX_ASSEMBLY&#39;)

    Returns
    -------
    num_nvars :               &lt;int&gt;
    &#34;&#34;&#34;
    return self.__ex_get_reduction_variable_param(objType).value</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.get_reduction_variable_values"><code class="name flex">
<span>def <span class="ident">get_reduction_variable_values</span></span>(<span>self, objType, id, step)</span>
</code></dt>
<dd>
<div class="desc"><p>get list of reduction variable values for a specified entity type and
id, and time step</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; evar_vals = exo.get_reduction_variable_values('EX_ELEM_BLOCK', elem_blk_id, time_step)
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt>objType
: ex_entity_type</dt>
<dt>type of object being queried</dt>
<dt>id
: int</dt>
<dt>entity <em>ID</em> (not <em>INDEX</em>)</dt>
<dt><strong><code>time_step</code></strong> :&ensp;<code>int</code></dt>
<dd>1-based index of time step</dd>
</dl>
<h2 id="returns">Returns</h2>
<pre><code>if array_type == 'ctype':
  &lt;list&lt;ctypes.c_double&gt;&gt;  evar_vals

if array_type == 'numpy':
  &lt;np_array&lt;double&gt;&gt;  evar_vals
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_reduction_variable_values(self, objType, id, step):
    &#34;&#34;&#34;
    get list of reduction variable values for a specified entity type and
    id, and time step

    &gt;&gt;&gt; evar_vals = exo.get_reduction_variable_values(&#39;EX_ELEM_BLOCK&#39;, elem_blk_id, time_step)

    Parameters
    ----------
    objType   : ex_entity_type
        type of object being queried
    id        : int
        entity *ID* (not *INDEX*)
    time_step : int
        1-based index of time step

    Returns
    -------

        if array_type == &#39;ctype&#39;:
          &lt;list&lt;ctypes.c_double&gt;&gt;  evar_vals

        if array_type == &#39;numpy&#39;:
          &lt;np_array&lt;double&gt;&gt;  evar_vals

    &#34;&#34;&#34;
    numVals = self.get_reduction_variable_number(objType)
    values = self.__ex_get_reduction_vars(step, objType, id, numVals)
    if self.use_numpy:
        values = ctype_to_numpy(self, values)
    return values</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.get_set_params"><code class="name flex">
<span>def <span class="ident">get_set_params</span></span>(<span>self, object_type, object_id)</span>
</code></dt>
<dd>
<div class="desc"><p>get number of entities and distribution factors (e.g. nodal
'weights') in the specified set</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; num_ns_nodes, num_ns_dist_facts =
...     exo.get_set_params('EX_NODE_SET', node_set_id)
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>set_id</code></strong> :&ensp;<code>int</code></dt>
<dd>set <em>ID</em> (not <em>INDEX</em>)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>num_set_entities</code></strong> :&ensp;<code>int</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>num_set_dist_facts</code></strong> :&ensp;<code>int</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_set_params(self, object_type, object_id):
    &#34;&#34;&#34;
    get number of entities and distribution factors (e.g. nodal
    &#39;weights&#39;) in the specified set

    &gt;&gt;&gt; num_ns_nodes, num_ns_dist_facts =
    ...     exo.get_set_params(&#39;EX_NODE_SET&#39;, node_set_id)

    Parameters
    ----------
    set_id : int
        set *ID* (not *INDEX*)

    Returns
    -------
    num_set_entities : int
    num_set_dist_facts : int
    &#34;&#34;&#34;
    (numSetEntities, numSetDistFacts) = self.__ex_get_set_param(object_type, object_id)
    return numSetEntities, numSetDistFacts</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.get_side_set"><code class="name flex">
<span>def <span class="ident">get_side_set</span></span>(<span>self, object_id)</span>
</code></dt>
<dd>
<div class="desc"><p>get the lists of element and side indices in a side set; the
two lists correspond: together, ss_elems[i] and ss_sides[i]
define the face of an element</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; ss_elems, ss_sides = exo.get_side_set(side_set_id)
</code></pre>
<h2 id="parameters">Parameters</h2>
<pre><code>&lt;int&gt;  side_set_id  side set *ID* (not *INDEX*)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>if array_type == 'ctype':
  &lt;list&lt;int&gt;&gt;  ss_elems
  &lt;list&lt;int&gt;&gt;  ss_sides

if array_type == 'numpy':
  &lt;np_array&lt;int&gt;&gt;  ss_elems
  &lt;np_array&lt;int&gt;&gt;  ss_sides
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_side_set(self, object_id):
    &#34;&#34;&#34;
    get the lists of element and side indices in a side set; the
    two lists correspond: together, ss_elems[i] and ss_sides[i]
    define the face of an element

    &gt;&gt;&gt; ss_elems, ss_sides = exo.get_side_set(side_set_id)

    Parameters
    ----------
        &lt;int&gt;  side_set_id  side set *ID* (not *INDEX*)

    Returns
    -------

        if array_type == &#39;ctype&#39;:
          &lt;list&lt;int&gt;&gt;  ss_elems
          &lt;list&lt;int&gt;&gt;  ss_sides

        if array_type == &#39;numpy&#39;:
          &lt;np_array&lt;int&gt;&gt;  ss_elems
          &lt;np_array&lt;int&gt;&gt;  ss_sides
    &#34;&#34;&#34;
    (side_set_elem_list, side_set_side_list) = self.__ex_get_side_set(object_id)
    if self.use_numpy:
        side_set_elem_list = ctype_to_numpy(self, side_set_elem_list)
        side_set_side_list = ctype_to_numpy(self, side_set_side_list)
    return side_set_elem_list, side_set_side_list</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.get_side_set_dist_fact"><code class="name flex">
<span>def <span class="ident">get_side_set_dist_fact</span></span>(<span>self, object_id)</span>
</code></dt>
<dd>
<div class="desc"><p>get the list of distribution factors for nodes in a side set</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; ss_dist_facts = exo.get_side_set_dist_fact(side_set_id)
</code></pre>
<h2 id="parameters">Parameters</h2>
<pre><code>&lt;int&gt;        side_set_id  side set *ID* (not *INDEX*)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>if array_type == 'ctype':
  &lt;list&lt;float&gt;&gt;  ss_dist_facts  a list of distribution factors,
    e.g. nodal 'weights'

if array_type == 'numpy':
  &lt;np_array&lt;double&gt;&gt;  ss_dist_facts  a list of distribution
    factors, e.g. nodal
    'weights'
</code></pre>
<h2 id="note">Note:</h2>
<p>The number of nodes (and distribution factors) in a side set is
the sum of all face nodes.
A single node can be counted more
than once, i.e. once for each face it belongs to in the side set.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_side_set_dist_fact(self, object_id):
    &#34;&#34;&#34;
    get the list of distribution factors for nodes in a side set

    &gt;&gt;&gt; ss_dist_facts = exo.get_side_set_dist_fact(side_set_id)

    Parameters
    ----------
        &lt;int&gt;        side_set_id  side set *ID* (not *INDEX*)

    Returns
    -------

        if array_type == &#39;ctype&#39;:
          &lt;list&lt;float&gt;&gt;  ss_dist_facts  a list of distribution factors,
            e.g. nodal &#39;weights&#39;

        if array_type == &#39;numpy&#39;:
          &lt;np_array&lt;double&gt;&gt;  ss_dist_facts  a list of distribution
            factors, e.g. nodal
            &#39;weights&#39;

    Note:
    -----
    The number of nodes (and distribution factors) in a side set is
    the sum of all face nodes.  A single node can be counted more
    than once, i.e. once for each face it belongs to in the side set.
    &#34;&#34;&#34;
    side_set_dfs = list(self.__ex_get_side_set_dist_fact(object_id))
    if self.use_numpy:
        side_set_dfs = self.np.array(side_set_dfs)
    return side_set_dfs</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.get_side_set_ids"><code class="name flex">
<span>def <span class="ident">get_side_set_ids</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>get mapping of exodus side set index to user- or application-
defined side set id; side_set_ids is ordered
by the <em>INDEX</em> ordering, a 1-based system going from
1 to exo.num_side_sets(), used by exodus for storage
and input/output of array data stored on the side sets; a
user or application can optionally use a separate side set
<em>ID</em> numbering system, so the side_set_ids array points to the
side set <em>ID</em> for each side set <em>INDEX</em></p>
<pre><code class="language-python-repl">&gt;&gt;&gt; side_set_ids = exo.get_ids('EX_SIDE_SET')
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>if array_type == 'ctype':
  &lt;list&lt;int&gt;&gt;  side_set_ids

if array_type == 'numpy':
  &lt;np_array&lt;int&gt;&gt;  side_set_ids
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_side_set_ids(self):
    &#34;&#34;&#34;
    get mapping of exodus side set index to user- or application-
    defined side set id; side_set_ids is ordered
    by the *INDEX* ordering, a 1-based system going from
    1 to exo.num_side_sets(), used by exodus for storage
    and input/output of array data stored on the side sets; a
    user or application can optionally use a separate side set
    *ID* numbering system, so the side_set_ids array points to the
    side set *ID* for each side set *INDEX*

    &gt;&gt;&gt; side_set_ids = exo.get_ids(&#39;EX_SIDE_SET&#39;)

    Returns
    -------

        if array_type == &#39;ctype&#39;:
          &lt;list&lt;int&gt;&gt;  side_set_ids

        if array_type == &#39;numpy&#39;:
          &lt;np_array&lt;int&gt;&gt;  side_set_ids
    &#34;&#34;&#34;
    return self.get_ids(&#39;EX_SIDE_SET&#39;)</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.get_side_set_name"><code class="name flex">
<span>def <span class="ident">get_side_set_name</span></span>(<span>self, object_id)</span>
</code></dt>
<dd>
<div class="desc"><p>get the name of a side set</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; side_set_name = exo.get_side_set_name(side_set_id)
</code></pre>
<h2 id="parameters">Parameters</h2>
<pre><code>&lt;int&gt;  side_set_id  side set *ID* (not *INDEX*)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>&lt;string&gt;  side_set_name
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_side_set_name(self, object_id):
    &#34;&#34;&#34;
    get the name of a side set

    &gt;&gt;&gt; side_set_name = exo.get_side_set_name(side_set_id)

    Parameters
    ----------
        &lt;int&gt;  side_set_id  side set *ID* (not *INDEX*)

    Returns
    -------
        &lt;string&gt;  side_set_name
    &#34;&#34;&#34;
    return self.__ex_get_name(&#39;EX_SIDE_SET&#39;, object_id)</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.get_side_set_names"><code class="name flex">
<span>def <span class="ident">get_side_set_names</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>get a list of all side set names ordered by side set <em>INDEX</em>;
(see <code><a title="exodus3.exodus.get_ids" href="#exodus3.exodus.get_ids">exodus.get_ids()</a></code> for explanation of the
difference between side set <em>ID</em> and side set <em>INDEX</em>)</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; side_set_names = exo.get_side_set_names()
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>&lt;list&lt;string&gt;&gt;  side_set_names
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_side_set_names(self):
    &#34;&#34;&#34;
    get a list of all side set names ordered by side set *INDEX*;
    (see `exodus.get_ids` for explanation of the
    difference between side set *ID* and side set *INDEX*)

    &gt;&gt;&gt; side_set_names = exo.get_side_set_names()

    Returns
    -------
        &lt;list&lt;string&gt;&gt;  side_set_names
    &#34;&#34;&#34;
    return self.__ex_get_names(&#39;EX_SIDE_SET&#39;)</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.get_side_set_node_list"><code class="name flex">
<span>def <span class="ident">get_side_set_node_list</span></span>(<span>self, object_id)</span>
</code></dt>
<dd>
<div class="desc"><p>get two lists:
1. number of nodes for each side in the set
2. concatenation of the nodes for each side in the set</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; ss_num_nodes_per_side, ss_nodes = exo.get_side_set_node_list(side_set_id)
</code></pre>
<h2 id="parameters">Parameters</h2>
<pre><code>&lt;int&gt;        side_set_id  side set *ID* (not *INDEX*)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>if array_type == 'ctype':
  &lt;list&lt;int&gt;&gt;  ss_num_side_nodes
  &lt;list&lt;int&gt;&gt;  ss_nodes

if array_type == 'numpy':
  &lt;np_array&lt;int&gt;&gt;  ss_num_side_nodes
  &lt;np_array&lt;int&gt;&gt;  ss_nodes
</code></pre>
<h2 id="note">Note:</h2>
<p>The number of nodes (and distribution factors) in a side set is
the sum of all face nodes.
A single node can be counted more
than once, i.e. once for each face it belongs to in the side set.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_side_set_node_list(self, object_id):
    &#34;&#34;&#34;
    get two lists:
     1. number of nodes for each side in the set
     2. concatenation of the nodes for each side in the set

    &gt;&gt;&gt; ss_num_nodes_per_side, ss_nodes = exo.get_side_set_node_list(side_set_id)

    Parameters
    ----------
        &lt;int&gt;        side_set_id  side set *ID* (not *INDEX*)

    Returns
    -------

        if array_type == &#39;ctype&#39;:
          &lt;list&lt;int&gt;&gt;  ss_num_side_nodes
          &lt;list&lt;int&gt;&gt;  ss_nodes

        if array_type == &#39;numpy&#39;:
          &lt;np_array&lt;int&gt;&gt;  ss_num_side_nodes
          &lt;np_array&lt;int&gt;&gt;  ss_nodes

    Note:
    -----
    The number of nodes (and distribution factors) in a side set is
    the sum of all face nodes.  A single node can be counted more
    than once, i.e. once for each face it belongs to in the side set.
    &#34;&#34;&#34;
    (side_set_node_cnt_list,
     side_set_node_list) = self.__ex_get_side_set_node_list(object_id)
    if self.use_numpy:
        side_set_node_cnt_list = ctype_to_numpy(
            self, side_set_node_cnt_list)
        side_set_node_list = ctype_to_numpy(self, side_set_node_list)
    return side_set_node_cnt_list, side_set_node_list</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.get_side_set_params"><code class="name flex">
<span>def <span class="ident">get_side_set_params</span></span>(<span>self, object_id)</span>
</code></dt>
<dd>
<div class="desc"><p>get number of sides and nodal distribution factors (e.g. nodal
'weights') in a side set</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; num_ss_sides, num_ss_dist_facts = exo.get_side_set_params(side_set_id)
</code></pre>
<h2 id="parameters">Parameters</h2>
<pre><code>&lt;int&gt;  side_set_id  side set *ID* (not *INDEX*)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>&lt;int&gt;  num_ss_sides
&lt;int&gt;  num_ss_dist_facts
</code></pre>
<h2 id="note">Note:</h2>
<p>The number of nodes (and distribution factors) in a side set is
the sum of all face nodes.
A single node can be counted more
than once, i.e. once for each face it belongs to in the side set.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_side_set_params(self, object_id):
    &#34;&#34;&#34;
    get number of sides and nodal distribution factors (e.g. nodal
    &#39;weights&#39;) in a side set

    &gt;&gt;&gt; num_ss_sides, num_ss_dist_facts = exo.get_side_set_params(side_set_id)

    Parameters
    ----------
        &lt;int&gt;  side_set_id  side set *ID* (not *INDEX*)

    Returns
    -------
        &lt;int&gt;  num_ss_sides
        &lt;int&gt;  num_ss_dist_facts

    Note:
    -----
    The number of nodes (and distribution factors) in a side set is
    the sum of all face nodes.  A single node can be counted more
    than once, i.e. once for each face it belongs to in the side set.
    &#34;&#34;&#34;
    (numSetSides, numSetDistFacts) = self.__ex_get_set_param(&#39;EX_SIDE_SET&#39;, object_id)
    return numSetSides, numSetDistFacts</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.get_side_set_property_names"><code class="name flex">
<span>def <span class="ident">get_side_set_property_names</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>get the list of side set property names for all side sets in
the model</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; ssprop_names = exo.get_side_set_property_names()
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>&lt;list&lt;string&gt;&gt;  ssprop_names
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_side_set_property_names(self):
    &#34;&#34;&#34;
    get the list of side set property names for all side sets in
    the model

    &gt;&gt;&gt; ssprop_names = exo.get_side_set_property_names()

    Returns
    -------
        &lt;list&lt;string&gt;&gt;  ssprop_names
    &#34;&#34;&#34;
    names = self.__ex_get_prop_names(&#39;EX_SIDE_SET&#39;, &#39;EX_INQ_SS_PROP&#39;)
    return list(names)</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.get_side_set_property_value"><code class="name flex">
<span>def <span class="ident">get_side_set_property_value</span></span>(<span>self, object_id, name)</span>
</code></dt>
<dd>
<div class="desc"><p>get side set property value (an integer) for a specified side
set and side set property name</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; ssprop_val = exo.get_side_set_property_value(side_set_id, ssprop_name)
</code></pre>
<h2 id="parameters">Parameters</h2>
<pre><code>&lt;int&gt;     side_set_id  side set *ID* (not *INDEX*)
&lt;string&gt;  ssprop_name
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>&lt;int&gt;  ssprop_val
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_side_set_property_value(self, object_id, name):
    &#34;&#34;&#34;
    get side set property value (an integer) for a specified side
    set and side set property name

    &gt;&gt;&gt; ssprop_val = exo.get_side_set_property_value(side_set_id, ssprop_name)

    Parameters
    ----------
        &lt;int&gt;     side_set_id  side set *ID* (not *INDEX*)
        &lt;string&gt;  ssprop_name

    Returns
    -------
        &lt;int&gt;  ssprop_val
    &#34;&#34;&#34;
    propVal = self.__ex_get_prop(&#39;EX_SIDE_SET&#39;, object_id, name)
    return int(propVal)</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.get_side_set_variable_names"><code class="name flex">
<span>def <span class="ident">get_side_set_variable_names</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>get the list of side set variable names in the model</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; ssvar_names = exo.get_side_set_variable_names()
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>  &lt;list&lt;string&gt;&gt;  ssvar_names
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_side_set_variable_names(self):
    &#34;&#34;&#34;
    get the list of side set variable names in the model

    &gt;&gt;&gt; ssvar_names = exo.get_side_set_variable_names()

    Returns
    -------
          &lt;list&lt;string&gt;&gt;  ssvar_names
    &#34;&#34;&#34;
    if self.__ex_get_variable_param(&#39;EX_SIDE_SET&#39;).value == 0:
        return []
    return self.__ex_get_variable_names(&#39;EX_SIDE_SET&#39;)</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.get_side_set_variable_number"><code class="name flex">
<span>def <span class="ident">get_side_set_variable_number</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>get the number of side set variables in the model</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; num_ssvars = exo.get_side_set_variable_number()
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>  &lt;int&gt;  num_ssvars
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_side_set_variable_number(self):
    &#34;&#34;&#34;
    get the number of side set variables in the model

    &gt;&gt;&gt; num_ssvars = exo.get_side_set_variable_number()

    Returns
    -------
          &lt;int&gt;  num_ssvars
    &#34;&#34;&#34;
    return self.__ex_get_variable_param(&#39;EX_SIDE_SET&#39;).value</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.get_side_set_variable_truth_table"><code class="name flex">
<span>def <span class="ident">get_side_set_variable_truth_table</span></span>(<span>self, entId=None)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="exodus3.exodus.get_variable_truth_table" href="#exodus3.exodus.get_variable_truth_table">exodus.get_variable_truth_table()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_side_set_variable_truth_table(self, entId=None):
    &#34;&#34;&#34;
    See `exodus.get_variable_truth_table`
    &#34;&#34;&#34;
    return self.get_variable_truth_table(&#39;EX_SIDE_SET&#39;, entId)</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.get_side_set_variable_values"><code class="name flex">
<span>def <span class="ident">get_side_set_variable_values</span></span>(<span>self, object_id, name, step)</span>
</code></dt>
<dd>
<div class="desc"><p>get list of side set variable values for a specified side
set, side set variable name, and time step; the list has
one variable value per side in the set</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; ssvar_vals = exo.get_side_set_variable_values(side_set_id,
...    ssvar_name, time_step)
</code></pre>
<h2 id="parameters">Parameters</h2>
<pre><code>&lt;int&gt;     side_set_id  side set *ID* (not *INDEX*)
&lt;string&gt;  ssvar_name   name of side set variable
&lt;int&gt;     time_step    1-based index of time step
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>if array_type == 'ctype':
  &lt;list&lt;ctypes.c_double&gt;&gt;  ssvar_vals

if array_type == 'numpy':
  &lt;np_array&lt;double&gt;&gt;  ssvar_vals
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_side_set_variable_values(self, object_id, name, step):
    &#34;&#34;&#34;
    get list of side set variable values for a specified side
    set, side set variable name, and time step; the list has
    one variable value per side in the set

    &gt;&gt;&gt; ssvar_vals = exo.get_side_set_variable_values(side_set_id,
    ...    ssvar_name, time_step)

    Parameters
    ----------
        &lt;int&gt;     side_set_id  side set *ID* (not *INDEX*)
        &lt;string&gt;  ssvar_name   name of side set variable
        &lt;int&gt;     time_step    1-based index of time step

    Returns
    -------

        if array_type == &#39;ctype&#39;:
          &lt;list&lt;ctypes.c_double&gt;&gt;  ssvar_vals

        if array_type == &#39;numpy&#39;:
          &lt;np_array&lt;double&gt;&gt;  ssvar_vals
    &#34;&#34;&#34;
    values = self.get_variable_values(&#39;EX_SIDE_SET&#39;, object_id, name, step)
    return values</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.get_sierra_input"><code class="name flex">
<span>def <span class="ident">get_sierra_input</span></span>(<span>self, inpFileName=None)</span>
</code></dt>
<dd>
<div class="desc"><p>parse sierra input deck from the info records if inp_file_name
is passed the deck is written to this file; otherwise a list
of input deck file lines is returned</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; inp = exo.get_sierra_input(inpFileName=inp_file_name)
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>inp_file_name</code></strong> :&ensp;<code>string</code>, optional</dt>
<dd>&nbsp;</dd>
</dl>
<p>Name of text file where info records corresponding to the Sierra input deck will be written</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>inp</code></strong> :&ensp;<code>list&lt;string&gt;</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>lines if inp_file_name not provided; otherwise, an empty list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_sierra_input(self, inpFileName=None):
    &#34;&#34;&#34;
    parse sierra input deck from the info records if inp_file_name
    is passed the deck is written to this file; otherwise a list
    of input deck file lines is returned

    &gt;&gt;&gt; inp = exo.get_sierra_input(inpFileName=inp_file_name)

    Parameters
    ----------
    inp_file_name : string, optional
       Name of text file where info records corresponding to the Sierra input deck will be written

    Returns
    -------
    inp : list&lt;string&gt;
       lines if inp_file_name not provided; otherwise, an empty list

    &#34;&#34;&#34;
    info_recs = self.__ex_get_info_recs()
    sierra_inp = []
    begin = False
    for rec in info_recs:
        vals = rec.split()
        if not begin:  # have not reached Sierra block
            if len(vals) &gt;= 2 and vals[0].lower() == &#34;begin&#34; and vals[1].lower() == &#34;sierra&#34;:
                begin = True
        if begin:  # inside Sierra block
            sierra_inp.append(rec)
            if len(rec) &gt; MAX_LINE_LENGTH:
                print(
                    &#34;WARNING: max line length reached for one or more input lines;&#34;)
                print(&#34;         input data might be incomplete for these lines&#34;)
                break
            if len(vals) &gt;= 2 and vals[0].lower() == &#34;end&#34; and vals[1].lower() == &#34;sierra&#34;:
                break  # end of Sierra block

    if inpFileName:
        fd = open(inpFileName.encode(&#39;ascii&#39;), &#34;w&#34;)
        for fileLine in sierra_inp:
            fd.write(fileLine+&#34;\n&#34;)
        fd.close()
        return []

    return sierra_inp</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.get_times"><code class="name flex">
<span>def <span class="ident">get_times</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>get the time values</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; time_vals = exo.get_times()
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>if array_type == 'ctype' :
  &lt;list&lt;ctypes.c_double&gt;&gt;  time_vals

if array_type == 'numpy' :
  &lt;np_array&lt;double&gt;&gt;  time_vals
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_times(self):
    &#34;&#34;&#34;
    get the time values

    &gt;&gt;&gt; time_vals = exo.get_times()

    Returns
    -------
        if array_type == &#39;ctype&#39; :
          &lt;list&lt;ctypes.c_double&gt;&gt;  time_vals

        if array_type == &#39;numpy&#39; :
          &lt;np_array&lt;double&gt;&gt;  time_vals
    &#34;&#34;&#34;
    if self.numTimes.value == 0:
        self.times = []
    else:
        self.__ex_get_all_times()
    if self.use_numpy:
        self.times = ctype_to_numpy(self, self.times)
    return self.times</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.get_variable_names"><code class="name flex">
<span>def <span class="ident">get_variable_names</span></span>(<span>self, objType)</span>
</code></dt>
<dd>
<div class="desc"><p>get the list of variable names in the model for the specified object type.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; nar_names = exo.get_variable_names('EX_NODAL')
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>  &lt;list&lt;string&gt;&gt;  nvar_names
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_variable_names(self, objType):
    &#34;&#34;&#34;
    get the list of variable names in the model for the specified object type.

    &gt;&gt;&gt; nar_names = exo.get_variable_names(&#39;EX_NODAL&#39;)

    Returns
    -------
          &lt;list&lt;string&gt;&gt;  nvar_names
    &#34;&#34;&#34;
    if self.__ex_get_variable_param(objType).value == 0:
        return []
    return self.__ex_get_variable_names(objType)</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.get_variable_number"><code class="name flex">
<span>def <span class="ident">get_variable_number</span></span>(<span>self, objType)</span>
</code></dt>
<dd>
<div class="desc"><p>get the number of variables of the specified type in the model</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; num_nvars = exo.get_variable_number('EX_NODAL')
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>num_nvars</code></strong> :&ensp;<code>&lt;int&gt;</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_variable_number(self, objType):
    &#34;&#34;&#34;
    get the number of variables of the specified type in the model

    &gt;&gt;&gt; num_nvars = exo.get_variable_number(&#39;EX_NODAL&#39;)

    Returns
    -------
    num_nvars :               &lt;int&gt;
    &#34;&#34;&#34;
    return self.__ex_get_variable_param(objType).value</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.get_variable_truth_table"><code class="name flex">
<span>def <span class="ident">get_variable_truth_table</span></span>(<span>self, objType, entId=None)</span>
</code></dt>
<dd>
<div class="desc"><p>gets a truth table indicating which variables are defined for
specified entity type; if entId is not passed, then a concatenated
truth table for all entities is returned with variable index
cycling faster than entity index</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; ssvar_truth_tab = exo.get_variable_truth_table('EX_SIDE_SET', sideSetID=side_set_id)
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>entId</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>entity <em>ID</em> (not <em>INDEX</em>)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>truth_tab</code></strong> :&ensp;<code>&lt;list&lt;bool&gt;&gt;</code></dt>
<dd>True for variable defined in an entity, False otherwise</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_variable_truth_table(self, objType, entId=None):
    &#34;&#34;&#34;
    gets a truth table indicating which variables are defined for
    specified entity type; if entId is not passed, then a concatenated
    truth table for all entities is returned with variable index
    cycling faster than entity index

    &gt;&gt;&gt; ssvar_truth_tab = exo.get_variable_truth_table(&#39;EX_SIDE_SET&#39;, sideSetID=side_set_id)

    Parameters
    ----------
    entId : int, optional
        entity *ID* (not *INDEX*)

    Returns
    -------
    truth_tab : &lt;list&lt;bool&gt;&gt;
        True for variable defined in an entity, False otherwise
    &#34;&#34;&#34;
    if entId is None:
        truthTable = self.__ex_get_truth_table(objType)
    else:
        truthTable = self.__ex_get_object_truth_vector(objType, entId)
    return truthTable</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.get_variable_values"><code class="name flex">
<span>def <span class="ident">get_variable_values</span></span>(<span>self, objType, entityId, name, step)</span>
</code></dt>
<dd>
<div class="desc"><p>get list of <code>objType</code> variable values for a specified object id
block, variable name, and time step</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; evar_vals = exo.get_variable_values('EX_ELEM_BLOCK', elem_blk_id,
...                                            evar_name, time_step)
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt>objType
: ex_entity_type</dt>
<dt>type of object being queried</dt>
<dt><strong><code>entityId</code></strong> :&ensp;<code>int</code></dt>
<dd>id of the entity (block, set) <em>ID</em> (not <em>INDEX</em>)</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>string</code></dt>
<dd>name of variable</dd>
<dt><strong><code>time_step</code></strong> :&ensp;<code>int</code></dt>
<dd>1-based index of time step</dd>
</dl>
<h2 id="returns">Returns</h2>
<pre><code>if array_type == 'ctype':
  &lt;list&lt;ctypes.c_double&gt;&gt;  evar_vals

if array_type == 'numpy':
  &lt;np_array&lt;double&gt;&gt;  evar_vals
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_variable_values(self, objType, entityId, name, step):
    &#34;&#34;&#34;
    get list of `objType` variable values for a specified object id
    block, variable name, and time step

    &gt;&gt;&gt; evar_vals = exo.get_variable_values(&#39;EX_ELEM_BLOCK&#39;, elem_blk_id,
    ...                                            evar_name, time_step)

    Parameters
    ----------
    objType   : ex_entity_type
        type of object being queried
    entityId : int
        id of the entity (block, set) *ID* (not *INDEX*)
    name : string
        name of variable
    time_step : int
        1-based index of time step

    Returns
    -------

        if array_type == &#39;ctype&#39;:
          &lt;list&lt;ctypes.c_double&gt;&gt;  evar_vals

        if array_type == &#39;numpy&#39;:
          &lt;np_array&lt;double&gt;&gt;  evar_vals
    &#34;&#34;&#34;
    names = self.get_variable_names(objType)
    var_id = names.index(name) + 1
    numVals = 0
    if objType == &#39;EX_NODAL&#39;:
        numVals = self.num_nodes()
    elif objType == &#39;EX_ELEM_BLOCK&#39;:
        numVals = self.num_elems_in_blk(entityId)
    elif objType == &#39;EX_NODE_SET&#39;:
        (numVals, _numDistFactInSet) = self.__ex_get_set_param(objType, entityId)
    elif objType == &#39;EX_EDGE_SET&#39;:
        (numVals, _numDistFactInSet) = self.__ex_get_set_param(objType, entityId)
    elif objType == &#39;EX_FACE_SET&#39;:
        (numVals, _numDistFactInSet) = self.__ex_get_set_param(objType, entityId)
    elif objType == &#39;EX_SIDE_SET&#39;:
        (numVals, _numDistFactInSet) = self.__ex_get_set_param(objType, entityId)

    values = self.__ex_get_var(step, objType, var_id, entityId, numVals)
    if self.use_numpy:
        values = ctype_to_numpy(self, values)
    return values</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.inquire"><code class="name flex">
<span>def <span class="ident">inquire</span></span>(<span>self, inquiry)</span>
</code></dt>
<dd>
<div class="desc"><p>Inquire about various properties of the database</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>inq_res</code></strong> :&ensp;<code>int</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inquire(self, inquiry):
    &#34;&#34;&#34;
    Inquire about various properties of the database

    Returns
    -------
    inq_res : int
    &#34;&#34;&#34;
    return self.__ex_inquire_int(ex_inquiry_map(inquiry))</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.num_assembly"><code class="name flex">
<span>def <span class="ident">num_assembly</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>get the number of assemblies in the model</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; num_assembly = exo.num_assembly()
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>&lt;int&gt;  num_assembly
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def num_assembly(self):
    &#34;&#34;&#34;
    get the number of assemblies in the model

    &gt;&gt;&gt; num_assembly = exo.num_assembly()

    Returns
    -------
        &lt;int&gt;  num_assembly
    &#34;&#34;&#34;
    return self.inquire(&#39;EX_INQ_ASSEMBLY&#39;)</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.num_attr"><code class="name flex">
<span>def <span class="ident">num_attr</span></span>(<span>self, object_id)</span>
</code></dt>
<dd>
<div class="desc"><p>get the number of attributes per element for an element block</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; num_elem_attrs = exo.num_attr(elem_blk_id)
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>elem_blk_id</code></strong> :&ensp;<code>int</code></dt>
<dd>element block <em>ID</em> (not <em>INDEX</em>)</dd>
</dl>
<h2 id="returns">Returns</h2>
<pre><code>&lt;int&gt;  num_elem_attrs
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def num_attr(self, object_id):
    &#34;&#34;&#34;
    get the number of attributes per element for an element block

    &gt;&gt;&gt; num_elem_attrs = exo.num_attr(elem_blk_id)

    Parameters
    ----------
    elem_blk_id : int
        element block *ID* (not *INDEX*)

    Returns
    -------
        &lt;int&gt;  num_elem_attrs
    &#34;&#34;&#34;
    (_elemType, _numElem, _nodesPerElem, numAttr) = self.__ex_get_block(&#39;EX_ELEM_BLOCK&#39;, object_id)
    return numAttr.value</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.num_blks"><code class="name flex">
<span>def <span class="ident">num_blks</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>get the number of element blocks in the model</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; num_elem_blks = exo.num_blks()
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>num_elem_blks</code></strong> :&ensp;<code>int</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def num_blks(self):
    &#34;&#34;&#34;
    get the number of element blocks in the model

    &gt;&gt;&gt; num_elem_blks = exo.num_blks()

    Returns
    -------
    num_elem_blks : int
    &#34;&#34;&#34;
    return self.numElemBlk.value</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.num_blob"><code class="name flex">
<span>def <span class="ident">num_blob</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>get the number of blobs in the model</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; num_assembly = exo.num_blob()
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>&lt;int&gt;  num_blob
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def num_blob(self):
    &#34;&#34;&#34;
    get the number of blobs in the model

    &gt;&gt;&gt; num_assembly = exo.num_blob()

    Returns
    -------
        &lt;int&gt;  num_blob
    &#34;&#34;&#34;
    return self.numBlob.value</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.num_dimensions"><code class="name flex">
<span>def <span class="ident">num_dimensions</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>get the number of model spatial dimensions</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; num_dims = exo.num_dimensions()
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>num_dims</code></strong> :&ensp;<code>&lt;int</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def num_dimensions(self):
    &#34;&#34;&#34;
    get the number of model spatial dimensions

    &gt;&gt;&gt; num_dims = exo.num_dimensions()

    Returns
    -------
    num_dims : &lt;int
    &#34;&#34;&#34;
    return self.numDim.value</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.num_elems"><code class="name flex">
<span>def <span class="ident">num_elems</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>get the number of elements in the model</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; num_elems = exo.num_elems()
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>num_elems</code></strong> :&ensp;<code>int</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def num_elems(self):
    &#34;&#34;&#34;
    get the number of elements in the model

    &gt;&gt;&gt; num_elems = exo.num_elems()

    Returns
    -------
    num_elems : int
    &#34;&#34;&#34;
    return self.numElem.value</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.num_elems_in_blk"><code class="name flex">
<span>def <span class="ident">num_elems_in_blk</span></span>(<span>self, object_id)</span>
</code></dt>
<dd>
<div class="desc"><p>get the number of elements in an element block</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; num_blk_elems = exo.num_elems_in_blk(elem_blk_id)
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>elem_blk_id</code></strong> :&ensp;<code>int</code></dt>
<dd>element block <em>ID</em> (not <em>INDEX</em>)</dd>
</dl>
<h2 id="returns">Returns</h2>
<pre><code>&lt;int&gt;  num_blk_elems
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def num_elems_in_blk(self, object_id):
    &#34;&#34;&#34;
    get the number of elements in an element block

    &gt;&gt;&gt; num_blk_elems = exo.num_elems_in_blk(elem_blk_id)

    Parameters
    ----------
    elem_blk_id : int
        element block *ID* (not *INDEX*)

    Returns
    -------
        &lt;int&gt;  num_blk_elems
    &#34;&#34;&#34;
    (_elemType, numElem, _nodesPerElem, _numAttr) = self.__ex_get_block(&#39;EX_ELEM_BLOCK&#39;, object_id)
    return numElem.value</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.num_faces_in_side_set"><code class="name flex">
<span>def <span class="ident">num_faces_in_side_set</span></span>(<span>self, object_id)</span>
</code></dt>
<dd>
<div class="desc"><p>get the number of faces in a side set</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; num_ss_faces = exo.num_faces_in_side_set(side_set_id)
</code></pre>
<h2 id="parameters">Parameters</h2>
<pre><code>&lt;int&gt;  side_set_id  side set *ID* (not *INDEX*)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>&lt;int&gt;  num_ss_faces
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def num_faces_in_side_set(self, object_id):
    &#34;&#34;&#34;
    get the number of faces in a side set

    &gt;&gt;&gt; num_ss_faces = exo.num_faces_in_side_set(side_set_id)

    Parameters
    ----------
        &lt;int&gt;  side_set_id  side set *ID* (not *INDEX*)

    Returns
    -------
        &lt;int&gt;  num_ss_faces
    &#34;&#34;&#34;
    ssids = self.get_ids(&#39;EX_SIDE_SET&#39;)
    if object_id not in ssids:
        print(&#34;WARNING: queried side set ID does not exist in database&#34;)
        return 0
    (num_side_in_set, _num_dist_fact_in_set) = self.__ex_get_set_param(&#39;EX_SIDE_SET&#39;, object_id)
    return num_side_in_set</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.num_info_records"><code class="name flex">
<span>def <span class="ident">num_info_records</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>get the number of info records</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; num_info_recs = exo.num_info_records()
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>num_info_recs</code></strong> :&ensp;<code>int</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def num_info_records(self):
    &#34;&#34;&#34;
    get the number of info records

    &gt;&gt;&gt; num_info_recs = exo.num_info_records()

    Returns
    -------
    num_info_recs : int
    &#34;&#34;&#34;
    return int(self.__ex_inquire_int(ex_inquiry_map(&#39;EX_INQ_INFO&#39;)))</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.num_node_sets"><code class="name flex">
<span>def <span class="ident">num_node_sets</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>get the number of node sets in the model</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; num_node_sets = exo.num_node_sets()
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>&lt;int&gt;  num_node_sets
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def num_node_sets(self):
    &#34;&#34;&#34;
    get the number of node sets in the model

    &gt;&gt;&gt; num_node_sets = exo.num_node_sets()

    Returns
    -------
        &lt;int&gt;  num_node_sets
    &#34;&#34;&#34;
    return self.numNodeSets.value</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.num_nodes"><code class="name flex">
<span>def <span class="ident">num_nodes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>get the number of nodes in the model</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; num_nodes = exo.num_nodes()
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>num_nodes</code></strong> :&ensp;<code>int</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def num_nodes(self):
    &#34;&#34;&#34;
    get the number of nodes in the model

    &gt;&gt;&gt; num_nodes = exo.num_nodes()

    Returns
    -------
    num_nodes : int
    &#34;&#34;&#34;
    return self.numNodes.value</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.num_nodes_in_node_set"><code class="name flex">
<span>def <span class="ident">num_nodes_in_node_set</span></span>(<span>self, object_id)</span>
</code></dt>
<dd>
<div class="desc"><p>get the number of nodes in a node set</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; num_ns_nodes = exo.num_nodes_in_node_set(node_set_id)
</code></pre>
<h2 id="parameters">Parameters</h2>
<pre><code>&lt;int&gt;  node_set_id  node set *ID* (not *INDEX*)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>&lt;int&gt;  num_ns_nodes
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def num_nodes_in_node_set(self, object_id):
    &#34;&#34;&#34;
    get the number of nodes in a node set

    &gt;&gt;&gt; num_ns_nodes = exo.num_nodes_in_node_set(node_set_id)

    Parameters
    ----------
        &lt;int&gt;  node_set_id  node set *ID* (not *INDEX*)

    Returns
    -------
        &lt;int&gt;  num_ns_nodes
    &#34;&#34;&#34;
    node_set_nodes = self.get_node_set_nodes(object_id)
    return len(node_set_nodes)</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.num_nodes_per_elem"><code class="name flex">
<span>def <span class="ident">num_nodes_per_elem</span></span>(<span>self, object_id)</span>
</code></dt>
<dd>
<div class="desc"><p>get the number of nodes per element for an element block</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; num_elem_nodes = exo.num_nodes_per_elem(elem_blk_id)
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>elem_blk_id</code></strong> :&ensp;<code>int</code></dt>
<dd>element block <em>ID</em> (not <em>INDEX</em>)</dd>
</dl>
<h2 id="returns">Returns</h2>
<pre><code>&lt;int&gt;  num_elem_nodes
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def num_nodes_per_elem(self, object_id):
    &#34;&#34;&#34;
    get the number of nodes per element for an element block

    &gt;&gt;&gt; num_elem_nodes = exo.num_nodes_per_elem(elem_blk_id)

    Parameters
    ----------
    elem_blk_id : int
        element block *ID* (not *INDEX*)

    Returns
    -------
        &lt;int&gt;  num_elem_nodes
    &#34;&#34;&#34;
    (_elemType, _numElem, nodesPerElem, _numAttr) = self.__ex_get_block(&#39;EX_ELEM_BLOCK&#39;, object_id)
    return nodesPerElem.value</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.num_qa_records"><code class="name flex">
<span>def <span class="ident">num_qa_records</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>get the number of qa records</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; num_qa_recs = exo.num_qa_records()
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>num_qa_recs</code></strong> :&ensp;<code>int</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def num_qa_records(self):
    &#34;&#34;&#34;
    get the number of qa records

    &gt;&gt;&gt; num_qa_recs = exo.num_qa_records()

    Returns
    -------
    num_qa_recs : int
    &#34;&#34;&#34;
    return int(self.__ex_inquire_int(ex_inquiry_map(&#39;EX_INQ_QA&#39;)))</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.num_side_sets"><code class="name flex">
<span>def <span class="ident">num_side_sets</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>get the number of side sets in the model</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; num_side_sets = exo.num_side_sets()
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>&lt;int&gt;  num_side_sets
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def num_side_sets(self):
    &#34;&#34;&#34;
    get the number of side sets in the model

    &gt;&gt;&gt; num_side_sets = exo.num_side_sets()

    Returns
    -------
        &lt;int&gt;  num_side_sets
    &#34;&#34;&#34;
    return self.numSideSets.value</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.num_times"><code class="name flex">
<span>def <span class="ident">num_times</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>get the number of time steps</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; num_times = exo.num_times()
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>num_times</code></strong> :&ensp;<code>int</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def num_times(self):
    &#34;&#34;&#34;
    get the number of time steps

    &gt;&gt;&gt; num_times = exo.num_times()

    Returns
    -------
    num_times : int
    &#34;&#34;&#34;
    return self.numTimes.value</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.put_all_global_variable_values"><code class="name flex">
<span>def <span class="ident">put_all_global_variable_values</span></span>(<span>self, step, values)</span>
</code></dt>
<dd>
<div class="desc"><p>store all global variable values (one for each global variable
name, and in the order given by exo.get_global_variable_names())
at a specified time step</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; status = exo.put_all_global_variable_values(time_step, gvar_vals)
</code></pre>
<h2 id="parameters">Parameters</h2>
<pre><code>&lt;int&gt;          time_step  1-based index of time step
&lt;list&lt;float&gt;&gt;  gvar_vals
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>status</code></strong> :&ensp;<code>bool</code></dt>
<dd>True = successful execution</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put_all_global_variable_values(self, step, values):
    &#34;&#34;&#34;
    store all global variable values (one for each global variable
    name, and in the order given by exo.get_global_variable_names())
    at a specified time step

    &gt;&gt;&gt; status = exo.put_all_global_variable_values(time_step, gvar_vals)

    Parameters
    ----------
        &lt;int&gt;          time_step  1-based index of time step
        &lt;list&lt;float&gt;&gt;  gvar_vals

    Returns
    -------
    status : bool
        True = successful execution
    &#34;&#34;&#34;
    numVals = self.get_variable_number(&#39;EX_GLOBAL&#39;)
    gvalues = (ctypes.c_double * numVals)()
    for i in range(numVals):
        gvalues[i] = ctypes.c_double(values[i])
    EXODUS_LIB.ex_put_glob_vars(self.fileId,
                                ctypes.c_int(step),
                                ctypes.c_int(numVals),
                                gvalues)
    return True</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.put_assemblies"><code class="name flex">
<span>def <span class="ident">put_assemblies</span></span>(<span>self, assemblies)</span>
</code></dt>
<dd>
<div class="desc"><p>writes the assembly parameters and assembly data for multiple assemblies</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put_assemblies(self, assemblies):
    &#34;&#34;&#34;
    writes the assembly parameters and assembly data for multiple assemblies
    &#34;&#34;&#34;
    self.__ex_put_assemblies(assemblies)</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.put_assembly"><code class="name flex">
<span>def <span class="ident">put_assembly</span></span>(<span>self, assembly)</span>
</code></dt>
<dd>
<div class="desc"><p>writes the assembly parameters and assembly data for one assembly</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put_assembly(self, assembly):
    &#34;&#34;&#34;
    writes the assembly parameters and assembly data for one assembly
    &#34;&#34;&#34;
    self.__ex_put_assembly(assembly)</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.put_attribute"><code class="name flex">
<span>def <span class="ident">put_attribute</span></span>(<span>self, attribute)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; attribute = exodus.attribute('Scale', 'EX_ASSEMBLY', 100)
&gt;&gt;&gt; attribute.values = [1.1, 1.0, 1.2]
&gt;&gt;&gt; attributes = exo.put_attribute(attribute)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>&lt;ex_attribute list&gt; attributes
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put_attribute(self, attribute):
    &#34;&#34;&#34;
    &gt;&gt;&gt; attribute = exodus.attribute(&#39;Scale&#39;, &#39;EX_ASSEMBLY&#39;, 100)
    &gt;&gt;&gt; attribute.values = [1.1, 1.0, 1.2]
    &gt;&gt;&gt; attributes = exo.put_attribute(attribute)

    Returns
    -------
        &lt;ex_attribute list&gt; attributes
    &#34;&#34;&#34;

    return self.__ex_put_attribute(attribute)</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.put_concat_elem_blk"><code class="name flex">
<span>def <span class="ident">put_concat_elem_blk</span></span>(<span>self, elem_blk_ids, elem_type, num_blk_elems, num_elem_nodes, num_elem_attrs, defineMaps)</span>
</code></dt>
<dd>
<div class="desc"><p>same as exo.put_elem_blk_info() but for all blocks at once</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; status = exo.put_concat_elem_blk(elem_blk_ids, elem_types,
...                                 num_blk_elems, num_elem_nodes, num_elem_attrs)
</code></pre>
<h2 id="parameters">Parameters</h2>
<pre><code>&lt;list&lt;int&gt;&gt;     elem_blk_ids     element block *ID* (not *INDEX*)
  for each block
&lt;list&lt;string&gt;&gt;  elem_types       element type for each block
&lt;list&lt;int&gt;&gt;     num_blk_elems    number of elements for each
  block
&lt;list&lt;int&gt;&gt;     num_elem_nodes   number of nodes per element
  for each block
&lt;list&lt;int&gt;&gt;     num_elem_attrs   number of attributes per
  element for each block
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>status</code></strong> :&ensp;<code>bool</code></dt>
<dd>True = successful execution</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put_concat_elem_blk(self, elem_blk_ids, elem_type, num_blk_elems,
                        num_elem_nodes, num_elem_attrs, defineMaps):
    &#34;&#34;&#34;
    same as exo.put_elem_blk_info() but for all blocks at once

    &gt;&gt;&gt; status = exo.put_concat_elem_blk(elem_blk_ids, elem_types,
    ...                                 num_blk_elems, num_elem_nodes, num_elem_attrs)

    Parameters
    ----------
        &lt;list&lt;int&gt;&gt;     elem_blk_ids     element block *ID* (not *INDEX*)
          for each block
        &lt;list&lt;string&gt;&gt;  elem_types       element type for each block
        &lt;list&lt;int&gt;&gt;     num_blk_elems    number of elements for each
          block
        &lt;list&lt;int&gt;&gt;     num_elem_nodes   number of nodes per element
          for each block
        &lt;list&lt;int&gt;&gt;     num_elem_attrs   number of attributes per
          element for each block

    Returns
    -------
    status : bool
        True = successful execution
    &#34;&#34;&#34;
    self.__ex_put_concat_elem_blk(
        elem_blk_ids,
        elem_type,
        num_blk_elems,
        num_elem_nodes,
        num_elem_attrs,
        defineMaps)
    return True</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.put_coord_names"><code class="name flex">
<span>def <span class="ident">put_coord_names</span></span>(<span>self, names)</span>
</code></dt>
<dd>
<div class="desc"><p>store a list of length exo.num_dimensions() that has the name
of each model coordinate direction, e.g. ['x', 'y', 'z']</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; exo.put_coord_names()
</code></pre>
<h2 id="parameters">Parameters</h2>
<pre><code>&lt;list&lt;string&gt;&gt;  coord_names
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put_coord_names(self, names):
    &#34;&#34;&#34;
    store a list of length exo.num_dimensions() that has the name
    of each model coordinate direction, e.g. [&#39;x&#39;, &#39;y&#39;, &#39;z&#39;]

    &gt;&gt;&gt; exo.put_coord_names()

    Parameters
    ----------
        &lt;list&lt;string&gt;&gt;  coord_names
    &#34;&#34;&#34;
    self.__ex_put_coord_names(names)</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.put_coords"><code class="name flex">
<span>def <span class="ident">put_coords</span></span>(<span>self, xCoords, yCoords, zCoords)</span>
</code></dt>
<dd>
<div class="desc"><p>store model coordinates of all nodes; for each coordinate
direction, a length exo.num_nodes() list is input</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; status = exo.put_coords(x_coords, y_coords, z_coords)
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x_coord</code></strong> :&ensp;<code>&lt;list&lt;float&gt;&gt;</code></dt>
<dd>global x-direction coordinates</dd>
<dt><strong><code>y_coord</code></strong> :&ensp;<code>&lt;list&lt;float&gt;&gt;</code></dt>
<dd>global y-direction coordinates</dd>
<dt><strong><code>z_coord</code></strong> :&ensp;<code>&lt;list&lt;float&gt;&gt;</code></dt>
<dd>global z-direction coordinates</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>status</code></strong> :&ensp;<code>bool</code></dt>
<dd>True = successful execution</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put_coords(self, xCoords, yCoords, zCoords):
    &#34;&#34;&#34;
    store model coordinates of all nodes; for each coordinate
    direction, a length exo.num_nodes() list is input

    &gt;&gt;&gt; status = exo.put_coords(x_coords, y_coords, z_coords)

    Parameters
    ----------
    x_coord : &lt;list&lt;float&gt;&gt;
        global x-direction coordinates
    y_coord : &lt;list&lt;float&gt;&gt;
        global y-direction coordinates
    z_coord : &lt;list&lt;float&gt;&gt;
        global z-direction coordinates

    Returns
    -------
    status : bool
        True = successful execution
    &#34;&#34;&#34;
    self.__ex_put_coord(xCoords, yCoords, zCoords)
    return True</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.put_elem_attr"><code class="name flex">
<span>def <span class="ident">put_elem_attr</span></span>(<span>self, elem_blk_id, elem_attrs)</span>
</code></dt>
<dd>
<div class="desc"><p>store all attributes for each element in a block</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; exo.put_elem_attr(elem_blk_id, elem_attrs)
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>elem_blk_id</code></strong> :&ensp;<code>int</code></dt>
<dd>element block <em>ID</em> (not <em>INDEX</em>)
<list\<float>>
elem_attrs
list of all attribute values for all
elements in the block; the list
cycles through all attributes of
the first element, then all attributes
of the second element, etc. Attributes
are ordered by the ordering of the
names returned by
exo.get_element_attribute_names()</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put_elem_attr(self, elem_blk_id, elem_attrs):
    &#34;&#34;&#34;
    store all attributes for each element in a block

    &gt;&gt;&gt; exo.put_elem_attr(elem_blk_id, elem_attrs)

    Parameters
    ----------
    elem_blk_id : int
        element block *ID* (not *INDEX*)
        &lt;list&lt;float&gt;&gt;  elem_attrs     list of all attribute values for all
          elements in the block; the list
          cycles through all attributes of
          the first element, then all attributes
          of the second element, etc. Attributes
          are ordered by the ordering of the
          names returned by
          exo.get_element_attribute_names()
    &#34;&#34;&#34;
    self.__ex_put_elem_attr(elem_blk_id, elem_attrs)</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.put_elem_attr_values"><code class="name flex">
<span>def <span class="ident">put_elem_attr_values</span></span>(<span>self, elem_blk_id, elem_attr_name, values)</span>
</code></dt>
<dd>
<div class="desc"><p>store an attribute for each element in a block</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; exo.put_elem_attr_values(elem_blk_id, elem_attr_name, values)
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>elem_blk_id</code></strong> :&ensp;<code>int</code></dt>
<dd>element block <em>ID</em> (not <em>INDEX</em>)
<string>
elem_attr_name element attribute name
<list\<float>>
values
list of values for a single attribute
on a element block.
List dimensions
should be 1 x N_elem, where N_elem is
the number of elements on the element
block.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put_elem_attr_values(self, elem_blk_id, elem_attr_name, values):
    &#34;&#34;&#34;
    store an attribute for each element in a block

    &gt;&gt;&gt; exo.put_elem_attr_values(elem_blk_id, elem_attr_name, values)

    Parameters
    ----------
    elem_blk_id : int
        element block *ID* (not *INDEX*)
        &lt;string&gt;       elem_attr_name element attribute name
        &lt;list&lt;float&gt;&gt;  values         list of values for a single attribute
                                      on a element block.  List dimensions
                                      should be 1 x N_elem, where N_elem is
                                      the number of elements on the element
                                      block.
    &#34;&#34;&#34;
    # Determine index of requested attribute in attribute list
    elem_attr_names = self.get_element_attribute_names(elem_blk_id)
    a_ndx = elem_attr_names.index(elem_attr_name)
    self.__ex_put_one_attr(&#39;EX_ELEM_BLOCK&#39;, elem_blk_id, a_ndx, values)</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.put_elem_blk_info"><code class="name flex">
<span>def <span class="ident">put_elem_blk_info</span></span>(<span>self, elem_blk_id, elem_type, num_blk_elems, num_elem_nodes, num_elem_attrs)</span>
</code></dt>
<dd>
<div class="desc"><p>store the element block <em>ID</em> and element block info</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; exo.put_elem_blk_info(elem_blk_id, elem_type, num_blk_elems,
...                      num_elem_nodes, num_elem_attrs)
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>elem_blk_id</code></strong> :&ensp;<code>int</code></dt>
<dd>element block <em>ID</em> (not <em>INDEX</em>)</dd>
<dt><strong><code>elem_type</code></strong> :&ensp;<code>string</code></dt>
<dd>element type (all caps), e.g. 'HEX8'</dd>
<dt><strong><code>num_blk_elems</code></strong> :&ensp;<code>int</code></dt>
<dd>number of elements in the block</dd>
<dt><strong><code>num_elem_nodes</code></strong> :&ensp;<code>int</code></dt>
<dd>number of nodes per element</dd>
<dt><strong><code>num_elem_attrs</code></strong> :&ensp;<code>int</code></dt>
<dd>number of attributes per element</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put_elem_blk_info(self, elem_blk_id, elem_type, num_blk_elems,
                      num_elem_nodes, num_elem_attrs):
    &#34;&#34;&#34;
    store the element block *ID* and element block info

    &gt;&gt;&gt; exo.put_elem_blk_info(elem_blk_id, elem_type, num_blk_elems,
    ...                      num_elem_nodes, num_elem_attrs)

    Parameters
    ----------
    elem_blk_id : int
        element block *ID* (not *INDEX*)
    elem_type : string
        element type (all caps), e.g. &#39;HEX8&#39;
    num_blk_elems : int
        number of elements in the block
    num_elem_nodes : int
        number of nodes per element
    num_elem_attrs : int
        number of attributes per element
    &#34;&#34;&#34;
    self.__ex_put_block(&#39;EX_ELEM_BLOCK&#39;, elem_blk_id, elem_type, num_blk_elems,
                        num_elem_nodes, num_elem_attrs)</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.put_elem_blk_name"><code class="name flex">
<span>def <span class="ident">put_elem_blk_name</span></span>(<span>self, object_id, name)</span>
</code></dt>
<dd>
<div class="desc"><p>store the element block name</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; exo.put_elem_blk_name(elem_blk_id, elem_blk_name)
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>elem_blk_id</code></strong> :&ensp;<code>int</code></dt>
<dd>element block <em>ID</em> (not <em>INDEX</em>)</dd>
<dt><strong><code>elem_blk_name</code></strong> :&ensp;<code>string</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put_elem_blk_name(self, object_id, name):
    &#34;&#34;&#34;
    store the element block name

    &gt;&gt;&gt; exo.put_elem_blk_name(elem_blk_id, elem_blk_name)

    Parameters
    ----------
    elem_blk_id : int
        element block *ID* (not *INDEX*)
    elem_blk_name : string
    &#34;&#34;&#34;
    self.__ex_put_name(&#39;EX_ELEM_BLOCK&#39;, object_id, name)</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.put_elem_blk_names"><code class="name flex">
<span>def <span class="ident">put_elem_blk_names</span></span>(<span>self, names)</span>
</code></dt>
<dd>
<div class="desc"><p>store a list of all element block names ordered by block <em>INDEX</em>;
(see <code><a title="exodus3.exodus.get_ids" href="#exodus3.exodus.get_ids">exodus.get_ids()</a></code> for explanation of the
difference between block <em>ID</em> and block <em>INDEX</em>)</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; exo.put_elem_blk_names(elem_blk_names)
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>elem_blk_names</code></strong> :&ensp;<code>&lt;list&lt;string&gt;&gt;</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put_elem_blk_names(self, names):
    &#34;&#34;&#34;
    store a list of all element block names ordered by block *INDEX*;
    (see `exodus.get_ids` for explanation of the
    difference between block *ID* and block *INDEX*)

    &gt;&gt;&gt; exo.put_elem_blk_names(elem_blk_names)

    Parameters
    ----------
    elem_blk_names : &lt;list&lt;string&gt;&gt;
    &#34;&#34;&#34;
    self.__ex_put_names(&#39;EX_ELEM_BLOCK&#39;, names)</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.put_elem_connectivity"><code class="name flex">
<span>def <span class="ident">put_elem_connectivity</span></span>(<span>self, object_id, connectivity)</span>
</code></dt>
<dd>
<div class="desc"><p>store the nodal connectivity, number of elements, and
number of nodes per element for a single block</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; exo.put_elem_connectivity(elem_blk_id, elem_conn)
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>elem_blk_id</code></strong> :&ensp;<code>int</code></dt>
<dd>element block <em>ID</em> (not <em>INDEX</em>)
<list\<int>>
elem_conn
ordered list of node <em>INDICES</em> that
define the connectivity of each
element in the block; the list cycles
through all nodes of the first element,
then all nodes of the second element,
etc.
(see <code><a title="exodus3.exodus.get_id_map" href="#exodus3.exodus.get_id_map">exodus.get_id_map()</a></code> for explanation
of node <em>INDEX</em> versus node <em>ID</em>)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put_elem_connectivity(self, object_id, connectivity):
    &#34;&#34;&#34;
    store the nodal connectivity, number of elements, and
    number of nodes per element for a single block

    &gt;&gt;&gt; exo.put_elem_connectivity(elem_blk_id, elem_conn)

    Parameters
    ----------
    elem_blk_id : int
        element block *ID* (not *INDEX*)
        &lt;list&lt;int&gt;&gt;  elem_conn    ordered list of node *INDICES* that
          define the connectivity of each
          element in the block; the list cycles
          through all nodes of the first element,
          then all nodes of the second element,
          etc.
          (see `exodus.get_id_map` for explanation
          of node *INDEX* versus node *ID*)
    &#34;&#34;&#34;
    _d1, numBlkElems, numNodesPerElem, _d2 = self.elem_blk_info(object_id)
    assert len(connectivity) == (numBlkElems * numNodesPerElem)
    self.__ex_put_elem_conn(object_id, connectivity)</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.put_elem_face_conn"><code class="name flex">
<span>def <span class="ident">put_elem_face_conn</span></span>(<span>self, blkId, elemFaceConn)</span>
</code></dt>
<dd>
<div class="desc"><p>put in connectivity information from elems to faces</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; status = exo.put_elem_face_conn(blkID, elemFaceConn)
</code></pre>
<h2 id="parameters">Parameters</h2>
<pre><code>&lt;int&gt;     blkID               id of the elem block to be added

if array_type == 'ctype':
  &lt;list&lt;float&gt;&gt;  elemFaceConn  (raveled/flat list)

if array_type == 'numpy':
  &lt;np_array&lt;double&gt;&gt;  elemFaceConn  (raveled/flat array)
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>status</code></strong> :&ensp;<code>bool</code></dt>
<dd>True = successful execution</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put_elem_face_conn(self, blkId, elemFaceConn):
    &#34;&#34;&#34;
    put in connectivity information from elems to faces

    &gt;&gt;&gt; status = exo.put_elem_face_conn(blkID, elemFaceConn)

    Parameters
    ----------
        &lt;int&gt;     blkID               id of the elem block to be added

        if array_type == &#39;ctype&#39;:
          &lt;list&lt;float&gt;&gt;  elemFaceConn  (raveled/flat list)

        if array_type == &#39;numpy&#39;:
          &lt;np_array&lt;double&gt;&gt;  elemFaceConn  (raveled/flat array)

    Returns
    -------
    status : bool
        True = successful execution
    &#34;&#34;&#34;
    ebType = ctypes.c_int(get_entity_type(&#39;EX_ELEM_BLOCK&#39;))
    elem_face_conn = (ctypes.c_int * len(elemFaceConn))()
    elem_face_conn[:] = elemFaceConn
    EXODUS_LIB.ex_put_conn(self.fileId, ebType, ctypes.c_longlong(blkId),
                           None, None, elem_face_conn)
    return True</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.put_elem_id_map"><code class="name flex">
<span>def <span class="ident">put_elem_id_map</span></span>(<span>self, id_map)</span>
</code></dt>
<dd>
<div class="desc"><p>store mapping of exodus element index to user- or application-
defined element id; elem_id_map is ordered by the element
<em>INDEX</em> ordering, a 1-based system going from 1 to
exo.num_elems(), used by exodus for storage and input/output
of array data stored on the elements; a user or application
can optionally use a separate element <em>ID</em> numbering system,
so the elem_id_map points to the element <em>ID</em> for each
element <em>INDEX</em></p>
<pre><code class="language-python-repl">&gt;&gt;&gt; status = exo.put_elem_id_map(elem_id_map)
</code></pre>
<h2 id="parameters">Parameters</h2>
<pre><code>&lt;list&lt;int&gt;&gt;  elem_id_map
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>status</code></strong> :&ensp;<code>bool</code></dt>
<dd>True = successful execution</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put_elem_id_map(self, id_map):
    &#34;&#34;&#34;
    store mapping of exodus element index to user- or application-
    defined element id; elem_id_map is ordered by the element
    *INDEX* ordering, a 1-based system going from 1 to
    exo.num_elems(), used by exodus for storage and input/output
    of array data stored on the elements; a user or application
    can optionally use a separate element *ID* numbering system,
    so the elem_id_map points to the element *ID* for each
    element *INDEX*

    &gt;&gt;&gt; status = exo.put_elem_id_map(elem_id_map)

    Parameters
    ----------
        &lt;list&lt;int&gt;&gt;  elem_id_map

    Returns
    -------
    status : bool
        True = successful execution
    &#34;&#34;&#34;
    return self.__ex_put_id_map(&#39;EX_ELEM_MAP&#39;, id_map)</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.put_element_attribute_names"><code class="name flex">
<span>def <span class="ident">put_element_attribute_names</span></span>(<span>self, blkId, names)</span>
</code></dt>
<dd>
<div class="desc"><p>store the list of element attribute names for a block</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; status = exo.put_element_attribute_names(elem_blk_id, attr_names)
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>elem_blk_id</code></strong> :&ensp;<code>int</code></dt>
<dd>element block <em>ID</em> (not <em>INDEX</em>)
<list\<string>>
attr_names</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>status</code></strong> :&ensp;<code>bool</code></dt>
<dd>True = successful execution</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put_element_attribute_names(self, blkId, names):
    &#34;&#34;&#34;
    store the list of element attribute names for a block

    &gt;&gt;&gt; status = exo.put_element_attribute_names(elem_blk_id, attr_names)

    Parameters
    ----------
    elem_blk_id : int
        element block *ID* (not *INDEX*)
        &lt;list&lt;string&gt;&gt;  attr_names

    Returns
    -------
    status : bool
        True = successful execution
    &#34;&#34;&#34;
    return self.__ex_put_elem_attr_names(blkId, names)</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.put_element_property_value"><code class="name flex">
<span>def <span class="ident">put_element_property_value</span></span>(<span>self, object_id, name, value)</span>
</code></dt>
<dd>
<div class="desc"><p>store an element property name and its integer value for an
element block</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; status = exo.put_element_property_value(elem_blk_id,
...                                         eprop_name, eprop_val)
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>elem_blk_id</code></strong> :&ensp;<code>int</code></dt>
<dd>element block <em>ID</em> (not <em>INDEX</em>)
<string>
eprop_name
<int>
eprop_val</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>status</code></strong> :&ensp;<code>bool</code></dt>
<dd>True = successful execution</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put_element_property_value(self, object_id, name, value):
    &#34;&#34;&#34;
    store an element property name and its integer value for an
    element block

    &gt;&gt;&gt; status = exo.put_element_property_value(elem_blk_id,
    ...                                         eprop_name, eprop_val)


    Parameters
    ----------
    elem_blk_id : int
        element block *ID* (not *INDEX*)
        &lt;string&gt;  eprop_name
        &lt;int&gt;     eprop_val

    Returns
    -------
    status : bool
        True = successful execution
    &#34;&#34;&#34;
    return self.__ex_put_prop(&#39;EX_ELEM_BLOCK&#39;, object_id, name, value)</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.put_element_variable_name"><code class="name flex">
<span>def <span class="ident">put_element_variable_name</span></span>(<span>self, name, index)</span>
</code></dt>
<dd>
<div class="desc"><p>add the name and index of a new element variable to the model;
element variable indexing goes from 1 to
exo.get_element_variable_number()</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; status = exo.put_element_variable_name(evar_name, evar_index)
</code></pre>
<h2 id="parameters">Parameters</h2>
<pre><code>&lt;string&gt;  evar_name   name of new element variable
&lt;int&gt;     evar_index  1-based index of new element variable
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>status</code></strong> :&ensp;<code>bool</code></dt>
<dd>True = successful execution</dd>
</dl>
<h2 id="note">Note:</h2>
<p>this method is often called within the following sequence:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; num_evars = exo.get_element_variable_number()
&gt;&gt;&gt; new_evar_index = num_evars + 1
&gt;&gt;&gt; num_evars += 1
&gt;&gt;&gt; exo.set_element_variable_number(num_evars)
&gt;&gt;&gt; exo.put_element_variable_name(&quot;new_evar&quot;, new_evar_index)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put_element_variable_name(self, name, index):
    &#34;&#34;&#34;
    add the name and index of a new element variable to the model;
    element variable indexing goes from 1 to
    exo.get_element_variable_number()

    &gt;&gt;&gt; status = exo.put_element_variable_name(evar_name, evar_index)

    Parameters
    ----------
        &lt;string&gt;  evar_name   name of new element variable
        &lt;int&gt;     evar_index  1-based index of new element variable

    Returns
    -------
    status : bool
        True = successful execution

    Note:
    ----
    this method is often called within the following sequence:

    &gt;&gt;&gt; num_evars = exo.get_element_variable_number()
    &gt;&gt;&gt; new_evar_index = num_evars + 1
    &gt;&gt;&gt; num_evars += 1
    &gt;&gt;&gt; exo.set_element_variable_number(num_evars)
    &gt;&gt;&gt; exo.put_element_variable_name(&#34;new_evar&#34;, new_evar_index)
    &#34;&#34;&#34;
    EBvarNames = self.get_variable_names(&#39;EX_ELEM_BLOCK&#39;)
    if name in EBvarNames:
        print(&#34;WARNING: element variable \&#34;{}\&#34; already exists.&#34;.format(name))
    if index &gt; len(EBvarNames):
        print((&#34;index&#34;, index, &#34;len&#34;, len(EBvarNames)))
        raise Exception(&#34;ERROR: variable index out of range.&#34;)
    self.__ex_put_variable_name(&#39;EX_ELEM_BLOCK&#39;, index, name)
    return True</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.put_element_variable_values"><code class="name flex">
<span>def <span class="ident">put_element_variable_values</span></span>(<span>self, blockId, name, step, values)</span>
</code></dt>
<dd>
<div class="desc"><p>store a list of element variable values for a specified element
block, element variable name, and time step</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; status = exo.put_element_variable_values(elem_blk_id,
...             evar_name, time_step, evar_vals)
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>elem_blk_id</code></strong> :&ensp;<code>int</code></dt>
<dd>element block <em>ID</em> (not <em>INDEX</em>)
<string>
evar_name
name of element variable
<int>
time_step
1-based index of time step
<list\<float>>
evar_vals</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>status</code></strong> :&ensp;<code>bool</code></dt>
<dd>True = successful execution</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put_element_variable_values(self, blockId, name, step, values):
    &#34;&#34;&#34;
    store a list of element variable values for a specified element
    block, element variable name, and time step

    &gt;&gt;&gt; status = exo.put_element_variable_values(elem_blk_id,
    ...             evar_name, time_step, evar_vals)

    Parameters
    ----------
    elem_blk_id : int
        element block *ID* (not *INDEX*)
        &lt;string&gt;       evar_name    name of element variable
        &lt;int&gt;          time_step    1-based index of time step
        &lt;list&lt;float&gt;&gt;  evar_vals

    Returns
    -------
    status : bool
        True = successful execution
    &#34;&#34;&#34;
    self.put_variable_values(&#39;EX_ELEM_BLOCK&#39;, blockId, name, step, values)
    return True</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.put_face_count_per_polyhedra"><code class="name flex">
<span>def <span class="ident">put_face_count_per_polyhedra</span></span>(<span>self, blkID, entityCounts)</span>
</code></dt>
<dd>
<div class="desc"><p>put in a count of faces in for each polyhedra in an elem block</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; status = exo.put_face_count_per_polyhedra(blkID, entityCounts)
</code></pre>
<h2 id="parameters">Parameters</h2>
<pre><code>&lt;int&gt;     blkID               id of the block to be added

if array_type == 'ctype':
  &lt;list&lt;float&gt;&gt;  entityCounts

if array_type == 'numpy':
  &lt;np_array&lt;double&gt;&gt;  entityCounts
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>status</code></strong> :&ensp;<code>bool</code></dt>
<dd>True = successful execution</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put_face_count_per_polyhedra(self, blkID, entityCounts):
    &#34;&#34;&#34;
    put in a count of faces in for each polyhedra in an elem block

    &gt;&gt;&gt; status = exo.put_face_count_per_polyhedra(blkID, entityCounts)

    Parameters
    ----------
        &lt;int&gt;     blkID               id of the block to be added

        if array_type == &#39;ctype&#39;:
          &lt;list&lt;float&gt;&gt;  entityCounts

        if array_type == &#39;numpy&#39;:
          &lt;np_array&lt;double&gt;&gt;  entityCounts

    Returns
    -------
    status : bool
        True = successful execution
    &#34;&#34;&#34;
    ebType = ctypes.c_int(get_entity_type(&#39;EX_ELEM_BLOCK&#39;))
    entity_counts = (ctypes.c_int * len(entityCounts))()
    entity_counts[:] = entityCounts
    EXODUS_LIB.ex_put_entity_count_per_polyhedra(
        self.fileId, ebType, ctypes.c_longlong(blkID), entity_counts)
    return True</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.put_face_node_conn"><code class="name flex">
<span>def <span class="ident">put_face_node_conn</span></span>(<span>self, blkId, faceNodeConn)</span>
</code></dt>
<dd>
<div class="desc"><p>put in connectivity information from faces to nodes</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; status = exo.put_face_node_conn(blkID, faceNodeConn)
</code></pre>
<h2 id="parameters">Parameters</h2>
<pre><code>&lt;int&gt;     blkID               id of the face block to be added

if array_type == 'ctype':
  &lt;list&lt;float&gt;&gt;  faceNodeConn  (raveled/flat list)

if array_type == 'numpy':
  &lt;np_array&lt;double&gt;&gt;  faceNodeConn  (raveled/flat array)
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>status</code></strong> :&ensp;<code>bool</code></dt>
<dd>True = successful execution</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put_face_node_conn(self, blkId, faceNodeConn):
    &#34;&#34;&#34;
    put in connectivity information from faces to nodes

    &gt;&gt;&gt; status = exo.put_face_node_conn(blkID, faceNodeConn)

    Parameters
    ----------
        &lt;int&gt;     blkID               id of the face block to be added

        if array_type == &#39;ctype&#39;:
          &lt;list&lt;float&gt;&gt;  faceNodeConn  (raveled/flat list)

        if array_type == &#39;numpy&#39;:
          &lt;np_array&lt;double&gt;&gt;  faceNodeConn  (raveled/flat array)

    Returns
    -------
    status : bool
        True = successful execution
    &#34;&#34;&#34;
    ebType = ctypes.c_int(get_entity_type(&#39;EX_FACE_BLOCK&#39;))
    node_conn = (ctypes.c_int * len(faceNodeConn))()
    node_conn[:] = faceNodeConn
    EXODUS_LIB.ex_put_conn(self.fileId, ebType, ctypes.c_longlong(blkId),
                           node_conn, None, None)
    return True</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.put_global_variable_name"><code class="name flex">
<span>def <span class="ident">put_global_variable_name</span></span>(<span>self, name, index)</span>
</code></dt>
<dd>
<div class="desc"><p>add the name and index of a new global variable to the model;
global variable indexing goes from 1 to
exo.get_global_variable_number()</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; status = exo.put_global_variable_name(gvar_name, gvar_index)
</code></pre>
<h2 id="parameters">Parameters</h2>
<pre><code>&lt;string&gt;  gvar_name   name of new global variable
&lt;int&gt;     gvar_index  1-based index of new global variable
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>status</code></strong> :&ensp;<code>bool</code></dt>
<dd>True = successful execution</dd>
</dl>
<h2 id="note">Note:</h2>
<p>this method is often called within the following sequence:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; num_gvars = exo.get_global_variable_number()
&gt;&gt;&gt; new_gvar_index = num_gvars + 1
&gt;&gt;&gt; num_gvars += 1
&gt;&gt;&gt; exo.set_global_variable_number(num_gvars)
&gt;&gt;&gt; exo.put_global_variable_name(&quot;new_gvar&quot;, new_gvar_index)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put_global_variable_name(self, name, index):
    &#34;&#34;&#34;
    add the name and index of a new global variable to the model;
    global variable indexing goes from 1 to
    exo.get_global_variable_number()

    &gt;&gt;&gt; status = exo.put_global_variable_name(gvar_name, gvar_index)

    Parameters
    ----------
        &lt;string&gt;  gvar_name   name of new global variable
        &lt;int&gt;     gvar_index  1-based index of new global variable

    Returns
    -------
    status : bool
        True = successful execution

    Note:
    -----
    this method is often called within the following sequence:

    &gt;&gt;&gt; num_gvars = exo.get_global_variable_number()
    &gt;&gt;&gt; new_gvar_index = num_gvars + 1
    &gt;&gt;&gt; num_gvars += 1
    &gt;&gt;&gt; exo.set_global_variable_number(num_gvars)
    &gt;&gt;&gt; exo.put_global_variable_name(&#34;new_gvar&#34;, new_gvar_index)
    &#34;&#34;&#34;
    GlobVarNames = self.get_variable_names(&#39;EX_GLOBAL&#39;)
    if name in GlobVarNames:
        print(&#34;WARNING: Global variable \&#34;{}\&#34; already exists.&#34;.format(name))
    if index &gt; len(GlobVarNames):
        print((&#34;index&#34;, index, &#34;len&#34;, len(GlobVarNames)))
        raise Exception(&#34;ERROR: variable index out of range.&#34;)
    self.__ex_put_variable_name(&#39;EX_GLOBAL&#39;, index, name)
    return True</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.put_global_variable_value"><code class="name flex">
<span>def <span class="ident">put_global_variable_value</span></span>(<span>self, name, step, value)</span>
</code></dt>
<dd>
<div class="desc"><p>store a global variable value for a specified global variable
name and time step</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; status = exo.put_global_variable_value(gvar_name, time_step, gvar_val)
</code></pre>
<h2 id="parameters">Parameters</h2>
<pre><code>&lt;string&gt;  gvar_name  name of global variable
&lt;int&gt;     time_step  1-based index of time step
&lt;float&gt;   gvar_val
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>status</code></strong> :&ensp;<code>bool</code></dt>
<dd>True = successful execution</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put_global_variable_value(self, name, step, value):
    &#34;&#34;&#34;
    store a global variable value for a specified global variable
    name and time step

    &gt;&gt;&gt; status = exo.put_global_variable_value(gvar_name, time_step, gvar_val)

    Parameters
    ----------
        &lt;string&gt;  gvar_name  name of global variable
        &lt;int&gt;     time_step  1-based index of time step
        &lt;float&gt;   gvar_val

    Returns
    -------
    status : bool
        True = successful execution
    &#34;&#34;&#34;
    # we must write all values at once, not individually
    names = self.get_variable_names(&#39;EX_GLOBAL&#39;)
    # get all values
    numVals = self.get_variable_number(&#39;EX_GLOBAL&#39;)
    values = (ctypes.c_double * numVals)()
    for i in range(numVals):
        values[i] = ctypes.c_double(
            self.get_global_variable_value(
                names[i], step))
    # adjust one of them
    values[names.index(name)] = ctypes.c_double(value)
    # write them all
    EXODUS_LIB.ex_put_glob_vars(self.fileId,
                                ctypes.c_int(step),
                                ctypes.c_int(numVals),
                                values)
    return True</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.put_id_map"><code class="name flex">
<span>def <span class="ident">put_id_map</span></span>(<span>self, objType, id_map)</span>
</code></dt>
<dd>
<div class="desc"><p>store mapping of exodus node index to user- or application-
defined node id; node_id_map is ordered the same as the nodal
coordinate arrays returned by exo.get_coords() &ndash; this ordering
follows the exodus node <em>INDEX</em> order, a 1-based system going
from 1 to exo.num_nodes(); a user or application can optionally
use a separate node <em>ID</em> numbering system, so the node_id_map
points to the node <em>ID</em> for each node <em>INDEX</em></p>
<pre><code class="language-python-repl">&gt;&gt;&gt; status = exo.put_node_id_map(node_id_map)
</code></pre>
<h2 id="parameters">Parameters</h2>
<pre><code>&lt;list&lt;int&gt;&gt;  node_id_map
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>status</code></strong> :&ensp;<code>bool</code></dt>
<dd>True = successful execution</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put_id_map(self, objType, id_map):
    &#34;&#34;&#34;
    store mapping of exodus node index to user- or application-
    defined node id; node_id_map is ordered the same as the nodal
    coordinate arrays returned by exo.get_coords() -- this ordering
    follows the exodus node *INDEX* order, a 1-based system going
    from 1 to exo.num_nodes(); a user or application can optionally
    use a separate node *ID* numbering system, so the node_id_map
    points to the node *ID* for each node *INDEX*

    &gt;&gt;&gt; status = exo.put_node_id_map(node_id_map)

    Parameters
    ----------
        &lt;list&lt;int&gt;&gt;  node_id_map

    Returns
    -------
    status : bool
        True = successful execution
    &#34;&#34;&#34;
    return self.__ex_put_id_map(objType, id_map)</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.put_info"><code class="name flex">
<span>def <span class="ident">put_info</span></span>(<span>self, Title, numDim, numNodes, numElem, numElemBlk, numNodeSets, numSideSets)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize static metadata for the database.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; status = exo.put_info(title, num_dims, num_nodes, num_elems,
...                      num_blocks, num_ns, num_ss)
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>title</code></strong> :&ensp;<code>string</code></dt>
<dd>database title</dd>
<dt><strong><code>num_dims</code></strong> :&ensp;<code>int</code></dt>
<dd>number of model dimensions</dd>
<dt><strong><code>num_nodes</code></strong> :&ensp;<code>int</code></dt>
<dd>number of model nodes</dd>
<dt><strong><code>num_elems</code></strong> :&ensp;<code>int</code></dt>
<dd>number of model elements</dd>
<dt><strong><code>num_blocks</code></strong> :&ensp;<code>int</code></dt>
<dd>number of model element blocks</dd>
<dt><strong><code>num_ns</code></strong> :&ensp;<code>int</code></dt>
<dd>number of model node sets</dd>
<dt><strong><code>num_ss</code></strong> :&ensp;<code>int</code></dt>
<dd>number of model side sets</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>status</code></strong> :&ensp;<code>bool</code></dt>
<dd>True = successful execution</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put_info(self, Title, numDim, numNodes, numElem, numElemBlk,
             numNodeSets, numSideSets):
    &#34;&#34;&#34;
    Initialize static metadata for the database.

    &gt;&gt;&gt; status = exo.put_info(title, num_dims, num_nodes, num_elems,
    ...                      num_blocks, num_ns, num_ss)

    Parameters
    ----------
    title : string
        database title
    num_dims : int
        number of model dimensions
    num_nodes : int
        number of model nodes
    num_elems : int
        number of model elements
    num_blocks : int
        number of model element blocks
    num_ns : int
        number of model node sets
    num_ss : int
        number of model side sets

    Returns
    -------
    status : bool
        True = successful execution

    &#34;&#34;&#34;
    self.__ex_put_info([Title, numDim, numNodes, numElem,
                        numElemBlk, numNodeSets, numSideSets])
    return True</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.put_info_ext"><code class="name flex">
<span>def <span class="ident">put_info_ext</span></span>(<span>self, p)</span>
</code></dt>
<dd>
<div class="desc"><p>put initialization information into exodus file</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; e.put_info_ext(info_struct)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put_info_ext(self, p):
    &#34;&#34;&#34;
    put initialization information into exodus file

    &gt;&gt;&gt; e.put_info_ext(info_struct)
    &#34;&#34;&#34;
    if len(p.title) &gt; MAX_LINE_LENGTH:
        print(&#34;WARNING: Exodus title \&#34;{}\&#34; exceeds maximum line length ({}). It will be truncated.&#34;
              .format(p.title, MAX_LINE_LENGTH))
        p.title = p.title[-1*MAX_LINE_LENGTH:]

    self.Title = ctypes.create_string_buffer(p.title, MAX_LINE_LENGTH + 1)
    self.numDim = ctypes.c_longlong(p.num_dim)
    self.numNodes = ctypes.c_longlong(p.num_nodes)
    self.numElem = ctypes.c_longlong(p.num_elem)
    self.numElemBlk = ctypes.c_longlong(p.num_elem_blk)
    self.numNodeSets = ctypes.c_longlong(p.num_node_sets)
    self.numSideSets = ctypes.c_longlong(p.num_side_sets)
    self.numAssembly = ctypes.c_longlong(p.num_assembly)

    EXODUS_LIB.ex_put_init_ext(self.fileId, ctypes.byref(p))
    return True</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.put_info_records"><code class="name flex">
<span>def <span class="ident">put_info_records</span></span>(<span>self, info)</span>
</code></dt>
<dd>
<div class="desc"><p>store a list of info records where each entry in the list is
one line of info, e.g. a line of an input deck</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; status = exo.put_info_records(info)
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>info_recs</code></strong> :&ensp;<code>&lt;list&lt;tuple[4]&lt;string&gt;&gt;&gt;</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>status</code></strong> :&ensp;<code>bool</code></dt>
<dd>True = successful execution</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put_info_records(self, info):
    &#34;&#34;&#34;
    store a list of info records where each entry in the list is
    one line of info, e.g. a line of an input deck

    &gt;&gt;&gt; status = exo.put_info_records(info)

    Parameters
    ----------
    info_recs : &lt;list&lt;tuple[4]&lt;string&gt;&gt;&gt;

    Returns
    -------
    status : bool
        True = successful execution
    &#34;&#34;&#34;
    for rec in info:
        if len(str(rec).encode(&#39;ascii&#39;)) &gt; MAX_LINE_LENGTH:
            print(&#34;WARNING: max line length reached for one or more info records;&#34;)
            print(
                &#34;         info stored to exodus file is incomplete for these records&#34;)
            break
    return self.__ex_put_info_recs(info)</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.put_name"><code class="name flex">
<span>def <span class="ident">put_name</span></span>(<span>self, object_type, object_id, name)</span>
</code></dt>
<dd>
<div class="desc"><p>put the name of the specified entity_type and entity</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; exo.put_name('EX_ELEM_BLOCK', elem_blk_id, block_name)
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>object_type</code></strong> :&ensp;<code>int</code></dt>
<dd>block/set type</dd>
<dt><strong><code>object_id</code></strong> :&ensp;<code>int</code></dt>
<dd>block/set <em>ID</em> (not <em>INDEX</em>)</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>string</code></dt>
<dd>block/set name</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>elem_blk_name</code></strong> :&ensp;<code>string</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put_name(self, object_type, object_id, name):
    &#34;&#34;&#34;
    put the name of the specified entity_type and entity

    &gt;&gt;&gt; exo.put_name(&#39;EX_ELEM_BLOCK&#39;, elem_blk_id, block_name)

    Parameters
    ----------
    object_type : int
        block/set type
    object_id : int
        block/set *ID* (not *INDEX*)
    name : string
        block/set name

    Returns
    -------
    elem_blk_name : string
    &#34;&#34;&#34;
    self.__ex_put_name(object_type, object_id, name)</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.put_names"><code class="name flex">
<span>def <span class="ident">put_names</span></span>(<span>self, object_type, names)</span>
</code></dt>
<dd>
<div class="desc"><p>store a list of all block/set names of the specified
<code>object_type</code> ordered by <em>INDEX</em>;
(see <code><a title="exodus3.exodus.get_ids" href="#exodus3.exodus.get_ids">exodus.get_ids()</a></code> for explanation of the
difference between <em>ID</em> and <em>INDEX</em>)</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; exo.put_names('EX_ELEM_BLOCK', elem_blk_names)
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>object_type</code></strong> :&ensp;<code>int</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>names</code></strong> :&ensp;<code>&lt;list&lt;string&gt;&gt;</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put_names(self, object_type, names):
    &#34;&#34;&#34;
    store a list of all block/set names of the specified
    `object_type` ordered by *INDEX*;
    (see `exodus.get_ids` for explanation of the
    difference between *ID* and *INDEX*)

    &gt;&gt;&gt; exo.put_names(&#39;EX_ELEM_BLOCK&#39;, elem_blk_names)

    Parameters
    ----------
    object_type : int
    names : &lt;list&lt;string&gt;&gt;
    &#34;&#34;&#34;

    self.__ex_put_names(object_type, names)</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.put_node_count_per_face"><code class="name flex">
<span>def <span class="ident">put_node_count_per_face</span></span>(<span>self, blkID, entityCounts)</span>
</code></dt>
<dd>
<div class="desc"><p>put in a count of nodes in for each face in a polygonal face block</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; status = exo.put_node_count_per_face(blkID, entityCounts)
</code></pre>
<h2 id="parameters">Parameters</h2>
<pre><code>&lt;int&gt;     blkID               id of the block to be added

if array_type == 'ctype':
  &lt;list&lt;float&gt;&gt;  entityCounts

if array_type == 'numpy':
  &lt;np_array&lt;double&gt;&gt;  entityCounts
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>status</code></strong> :&ensp;<code>bool</code></dt>
<dd>True = successful execution</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put_node_count_per_face(self, blkID, entityCounts):
    &#34;&#34;&#34;
    put in a count of nodes in for each face in a polygonal face block

    &gt;&gt;&gt; status = exo.put_node_count_per_face(blkID, entityCounts)

    Parameters
    ----------
        &lt;int&gt;     blkID               id of the block to be added

        if array_type == &#39;ctype&#39;:
          &lt;list&lt;float&gt;&gt;  entityCounts

        if array_type == &#39;numpy&#39;:
          &lt;np_array&lt;double&gt;&gt;  entityCounts

    Returns
    -------
    status : bool
        True = successful execution
    &#34;&#34;&#34;
    ebType = ctypes.c_int(get_entity_type(&#39;EX_FACE_BLOCK&#39;))
    entity_counts = (ctypes.c_int * len(entityCounts))()
    entity_counts[:] = entityCounts
    EXODUS_LIB.ex_put_entity_count_per_polyhedra(
        self.fileId, ebType, ctypes.c_longlong(blkID), entity_counts)
    return True</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.put_node_id_map"><code class="name flex">
<span>def <span class="ident">put_node_id_map</span></span>(<span>self, id_map)</span>
</code></dt>
<dd>
<div class="desc"><p>store mapping of exodus node index to user- or application-
defined node id; node_id_map is ordered the same as the nodal
coordinate arrays returned by exo.get_coords() &ndash; this ordering
follows the exodus node <em>INDEX</em> order, a 1-based system going
from 1 to exo.num_nodes(); a user or application can optionally
use a separate node <em>ID</em> numbering system, so the node_id_map
points to the node <em>ID</em> for each node <em>INDEX</em></p>
<pre><code class="language-python-repl">&gt;&gt;&gt; status = exo.put_node_id_map(node_id_map)
</code></pre>
<h2 id="parameters">Parameters</h2>
<pre><code>&lt;list&lt;int&gt;&gt;  node_id_map
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>status</code></strong> :&ensp;<code>bool</code></dt>
<dd>True = successful execution</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put_node_id_map(self, id_map):
    &#34;&#34;&#34;
    store mapping of exodus node index to user- or application-
    defined node id; node_id_map is ordered the same as the nodal
    coordinate arrays returned by exo.get_coords() -- this ordering
    follows the exodus node *INDEX* order, a 1-based system going
    from 1 to exo.num_nodes(); a user or application can optionally
    use a separate node *ID* numbering system, so the node_id_map
    points to the node *ID* for each node *INDEX*

    &gt;&gt;&gt; status = exo.put_node_id_map(node_id_map)

    Parameters
    ----------
        &lt;list&lt;int&gt;&gt;  node_id_map

    Returns
    -------
    status : bool
        True = successful execution
    &#34;&#34;&#34;
    return self.__ex_put_id_map(&#39;EX_NODE_MAP&#39;, id_map)</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.put_node_set"><code class="name flex">
<span>def <span class="ident">put_node_set</span></span>(<span>self, object_id, nodeSetNodes)</span>
</code></dt>
<dd>
<div class="desc"><p>store a node set by its id and the list of node <em>INDICES</em> in
the node set (see <code><a title="exodus3.exodus.get_id_map" href="#exodus3.exodus.get_id_map">exodus.get_id_map()</a></code> for explanation of node
<em>INDEX</em> versus node <em>ID</em>)</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; exo.put_node_set(node_set_id, ns_nodes)
</code></pre>
<h2 id="parameters">Parameters</h2>
<pre><code>&lt;int&gt;        node_set_id  node set *ID* (not *INDEX*)
&lt;list&lt;int&gt;&gt;  ns_nodes
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put_node_set(self, object_id, nodeSetNodes):
    &#34;&#34;&#34;
    store a node set by its id and the list of node *INDICES* in
    the node set (see `exodus.get_id_map` for explanation of node
    *INDEX* versus node *ID*)

    &gt;&gt;&gt; exo.put_node_set(node_set_id, ns_nodes)

    Parameters
    ----------
        &lt;int&gt;        node_set_id  node set *ID* (not *INDEX*)
        &lt;list&lt;int&gt;&gt;  ns_nodes
    &#34;&#34;&#34;
    self.__ex_put_node_set(object_id, nodeSetNodes)</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.put_node_set_dist_fact"><code class="name flex">
<span>def <span class="ident">put_node_set_dist_fact</span></span>(<span>self, object_id, nodeSetDistFact)</span>
</code></dt>
<dd>
<div class="desc"><p>store the list of distribution factors for nodes in a node set</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; exo.put_node_set_dist_fact(node_set_id, ns_dist_facts)
</code></pre>
<h2 id="parameters">Parameters</h2>
<pre><code>&lt;int&gt;          node_set_id    node set *ID* (not *INDEX*)
&lt;list&lt;float&gt;&gt;  ns_dist_facts  a list of distribution factors,
  e.g. nodal 'weights'
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put_node_set_dist_fact(self, object_id, nodeSetDistFact):
    &#34;&#34;&#34;
    store the list of distribution factors for nodes in a node set

    &gt;&gt;&gt; exo.put_node_set_dist_fact(node_set_id, ns_dist_facts)

    Parameters
    ----------
        &lt;int&gt;          node_set_id    node set *ID* (not *INDEX*)
        &lt;list&lt;float&gt;&gt;  ns_dist_facts  a list of distribution factors,
          e.g. nodal &#39;weights&#39;
    &#34;&#34;&#34;
    self.__ex_put_node_set_dist_fact(object_id, nodeSetDistFact)</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.put_node_set_name"><code class="name flex">
<span>def <span class="ident">put_node_set_name</span></span>(<span>self, object_id, name)</span>
</code></dt>
<dd>
<div class="desc"><p>store the name of a node set</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; exo.put_node_set_name(node_set_id, node_set_name)
</code></pre>
<h2 id="parameters">Parameters</h2>
<pre><code>&lt;int&gt;     node_set_id    node set *ID* (not *INDEX*)
&lt;string&gt;  node_set_name
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put_node_set_name(self, object_id, name):
    &#34;&#34;&#34;
    store the name of a node set

    &gt;&gt;&gt; exo.put_node_set_name(node_set_id, node_set_name)

    Parameters
    ----------
        &lt;int&gt;     node_set_id    node set *ID* (not *INDEX*)
        &lt;string&gt;  node_set_name
    &#34;&#34;&#34;
    self.__ex_put_name(&#39;EX_NODE_SET&#39;, object_id, name)</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.put_node_set_names"><code class="name flex">
<span>def <span class="ident">put_node_set_names</span></span>(<span>self, names)</span>
</code></dt>
<dd>
<div class="desc"><p>store a list of all node set names ordered by node set <em>INDEX</em>;
(see <code><a title="exodus3.exodus.get_ids" href="#exodus3.exodus.get_ids">exodus.get_ids()</a></code> for explanation of the
difference between node set <em>ID</em> and node set <em>INDEX</em>)</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; exo.put_node_set_names(node_set_names)
</code></pre>
<h2 id="parameters">Parameters</h2>
<pre><code>&lt;list&lt;string&gt;&gt;  node_set_names
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put_node_set_names(self, names):
    &#34;&#34;&#34;
    store a list of all node set names ordered by node set *INDEX*;
    (see `exodus.get_ids` for explanation of the
    difference between node set *ID* and node set *INDEX*)

    &gt;&gt;&gt; exo.put_node_set_names(node_set_names)

    Parameters
    ----------
        &lt;list&lt;string&gt;&gt;  node_set_names
    &#34;&#34;&#34;
    self.__ex_put_names(&#39;EX_NODE_SET&#39;, names)</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.put_node_set_params"><code class="name flex">
<span>def <span class="ident">put_node_set_params</span></span>(<span>self, object_id, numSetNodes, numSetDistFacts=None)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="exodus3.exodus.put_set_params" href="#exodus3.exodus.put_set_params">exodus.put_set_params()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put_node_set_params(self, object_id, numSetNodes, numSetDistFacts=None):
    &#34;&#34;&#34; See `exodus.put_set_params` &#34;&#34;&#34;
    if numSetDistFacts is None:
        numSetDistFacts = numSetNodes
    assert numSetDistFacts in (0, numSetNodes)
    self.__ex_put_set_param(&#39;EX_NODE_SET&#39;, object_id, numSetNodes, numSetDistFacts)</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.put_node_set_property_value"><code class="name flex">
<span>def <span class="ident">put_node_set_property_value</span></span>(<span>self, object_id, name, value)</span>
</code></dt>
<dd>
<div class="desc"><p>store a node set property name and its integer value for a
node set</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; status = exo.put_node_set_property_value(node_set_id,
...                   nsprop_name, nsprop_val)
</code></pre>
<h2 id="parameters">Parameters</h2>
<pre><code>&lt;int&gt;     node_set_id  node set *ID* (not *INDEX*)
&lt;string&gt;  nsprop_name
&lt;int&gt;     nsprop_val
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>status</code></strong> :&ensp;<code>bool</code></dt>
<dd>True = successful execution</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put_node_set_property_value(self, object_id, name, value):
    &#34;&#34;&#34;
    store a node set property name and its integer value for a
    node set

    &gt;&gt;&gt; status = exo.put_node_set_property_value(node_set_id,
    ...                   nsprop_name, nsprop_val)

    Parameters
    ----------
        &lt;int&gt;     node_set_id  node set *ID* (not *INDEX*)
        &lt;string&gt;  nsprop_name
        &lt;int&gt;     nsprop_val

    Returns
    -------
    status : bool
        True = successful execution
    &#34;&#34;&#34;
    return self.__ex_put_prop(&#39;EX_NODE_SET&#39;, object_id, name, value)</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.put_node_set_variable_name"><code class="name flex">
<span>def <span class="ident">put_node_set_variable_name</span></span>(<span>self, name, index)</span>
</code></dt>
<dd>
<div class="desc"><p>add the name and index of a new node set variable to the model;
node set variable indexing goes from 1 to
exo.get_node_set_variable_number()</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; status = exo.put_node_set_variable_name(nsvar_name, nsvar_index)
</code></pre>
<h2 id="parameters">Parameters</h2>
<pre><code>&lt;string&gt;  nsvar_name   name of new node set variable
&lt;int&gt;     nsvar_index  1-based index of new node set variable
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>status</code></strong> :&ensp;<code>bool</code></dt>
<dd>True = successful execution</dd>
</dl>
<h2 id="note">Note:</h2>
<p>this method is often called within the following sequence:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; num_nsvars = exo.get_node_set_variable_number()
&gt;&gt;&gt; new_nsvar_index = num_nsvars + 1
&gt;&gt;&gt; num_nsvars += 1
&gt;&gt;&gt; exo.set_node_set_variable_number(num_nsvars)
&gt;&gt;&gt; exo.put_node_set_variable_name(&quot;new_nsvar&quot;, new_nsvar_index)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put_node_set_variable_name(self, name, index):
    &#34;&#34;&#34;
    add the name and index of a new node set variable to the model;
    node set variable indexing goes from 1 to
    exo.get_node_set_variable_number()

    &gt;&gt;&gt; status = exo.put_node_set_variable_name(nsvar_name, nsvar_index)

    Parameters
    ----------
        &lt;string&gt;  nsvar_name   name of new node set variable
        &lt;int&gt;     nsvar_index  1-based index of new node set variable

    Returns
    -------
    status : bool
        True = successful execution

    Note:
    -----
    this method is often called within the following sequence:

    &gt;&gt;&gt; num_nsvars = exo.get_node_set_variable_number()
    &gt;&gt;&gt; new_nsvar_index = num_nsvars + 1
    &gt;&gt;&gt; num_nsvars += 1
    &gt;&gt;&gt; exo.set_node_set_variable_number(num_nsvars)
    &gt;&gt;&gt; exo.put_node_set_variable_name(&#34;new_nsvar&#34;, new_nsvar_index)
    &#34;&#34;&#34;
    NSvarNames = self.get_variable_names(&#39;EX_NODE_SET&#39;)
    if name in NSvarNames:
        print(&#34;WARNING: Node set variable \&#34;{}\&#34; already exists.&#34;.format(name))
    if index &gt; len(NSvarNames):
        raise Exception(&#34;ERROR: variable index out of range.&#34;)
    self.__ex_put_variable_name(&#39;EX_NODE_SET&#39;, index, name)
    return True</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.put_node_set_variable_values"><code class="name flex">
<span>def <span class="ident">put_node_set_variable_values</span></span>(<span>self, object_id, name, step, values)</span>
</code></dt>
<dd>
<div class="desc"><p>store a list of node set variable values for a specified node
set, node set variable name, and time step; the list has one
variable value per node in the set</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; status =
... exo.put_node_set_variable_values(node_set_id,
...     nsvar_name, time_step, nsvar_vals)
</code></pre>
<h2 id="parameters">Parameters</h2>
<pre><code>&lt;int&gt;          node_set_id  node set *ID* (not *INDEX*)
&lt;string&gt;       nsvar_name   name of node set variable
&lt;int&gt;          time_step    1-based index of time step
&lt;list&lt;float&gt;&gt;  nsvar_vals
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>status</code></strong> :&ensp;<code>bool</code></dt>
<dd>True = successful execution</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put_node_set_variable_values(self, object_id, name, step, values):
    &#34;&#34;&#34;
    store a list of node set variable values for a specified node
    set, node set variable name, and time step; the list has one
    variable value per node in the set

    &gt;&gt;&gt; status =
    ... exo.put_node_set_variable_values(node_set_id,
    ...     nsvar_name, time_step, nsvar_vals)

    Parameters
    ----------
        &lt;int&gt;          node_set_id  node set *ID* (not *INDEX*)
        &lt;string&gt;       nsvar_name   name of node set variable
        &lt;int&gt;          time_step    1-based index of time step
        &lt;list&lt;float&gt;&gt;  nsvar_vals

    Returns
    -------
    status : bool
        True = successful execution
    &#34;&#34;&#34;
    self.put_variable_values(&#39;EX_NODE_SET&#39;, object_id, name, step, values)
    return True</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.put_node_variable_name"><code class="name flex">
<span>def <span class="ident">put_node_variable_name</span></span>(<span>self, name, index)</span>
</code></dt>
<dd>
<div class="desc"><p>add the name and index of a new nodal variable to the model;
nodal variable indexing goes from 1 to exo.get_node_variable_number()</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; status = exo.put_node_variable_name(nvar_name, nvar_index)
</code></pre>
<h2 id="parameters">Parameters</h2>
<pre><code>&lt;string&gt;  nvar_name   name of new nodal variable
&lt;int&gt;     nvar_index  1-based index of new nodal variable
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>status</code></strong> :&ensp;<code>bool</code></dt>
<dd>True = successful execution</dd>
</dl>
<h2 id="note">Note:</h2>
<p>this method is often called within the following sequence:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; num_nvars = exo.get_node_variable_number()
&gt;&gt;&gt; new_nvar_index = num_nvars + 1
&gt;&gt;&gt; num_nvars += 1
&gt;&gt;&gt; exo.set_node_variable_number(num_nvars)
&gt;&gt;&gt; exo.put_node_variable_name(&quot;new_nvar_name&quot;, new_nvar_index)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put_node_variable_name(self, name, index):
    &#34;&#34;&#34;
    add the name and index of a new nodal variable to the model;
    nodal variable indexing goes from 1 to exo.get_node_variable_number()

    &gt;&gt;&gt; status = exo.put_node_variable_name(nvar_name, nvar_index)

    Parameters
    ----------
        &lt;string&gt;  nvar_name   name of new nodal variable
        &lt;int&gt;     nvar_index  1-based index of new nodal variable

    Returns
    -------
    status : bool
        True = successful execution

    Note:
    ----
    this method is often called within the following sequence:

    &gt;&gt;&gt; num_nvars = exo.get_node_variable_number()
    &gt;&gt;&gt; new_nvar_index = num_nvars + 1
    &gt;&gt;&gt; num_nvars += 1
    &gt;&gt;&gt; exo.set_node_variable_number(num_nvars)
    &gt;&gt;&gt; exo.put_node_variable_name(&#34;new_nvar_name&#34;, new_nvar_index)
    &#34;&#34;&#34;
    NDvarNames = self.get_variable_names(&#39;EX_NODAL&#39;)
    if name in NDvarNames:
        print(&#34;WARNING: node variable \&#34;{}\&#34; already exists.&#34;.format(name))
    if index &gt; len(NDvarNames):
        raise Exception(&#34;ERROR: variable index out of range.&#34;)
    self.__ex_put_variable_name(&#39;EX_NODAL&#39;, index, name)
    return True</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.put_node_variable_values"><code class="name flex">
<span>def <span class="ident">put_node_variable_values</span></span>(<span>self, name, step, values)</span>
</code></dt>
<dd>
<div class="desc"><p>store a list of nodal variable values for a nodal variable
name and time step</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; status = exo.put_node_variable_values(nvar_name, time_step, nvar_vals)
</code></pre>
<h2 id="parameters">Parameters</h2>
<pre><code>&lt;string&gt;       nvar_name  name of nodal variable
&lt;int&gt;          time_step  1-based index of time step
&lt;list&lt;float&gt;&gt;  nvar_vals
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>status</code></strong> :&ensp;<code>bool</code></dt>
<dd>True = successful execution</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put_node_variable_values(self, name, step, values):
    &#34;&#34;&#34;
    store a list of nodal variable values for a nodal variable
    name and time step

    &gt;&gt;&gt; status = exo.put_node_variable_values(nvar_name, time_step, nvar_vals)

    Parameters
    ----------
        &lt;string&gt;       nvar_name  name of nodal variable
        &lt;int&gt;          time_step  1-based index of time step
        &lt;list&lt;float&gt;&gt;  nvar_vals

    Returns
    -------
    status : bool
        True = successful execution
    &#34;&#34;&#34;
    names = self.get_variable_names(&#39;EX_NODAL&#39;)
    var_id = names.index(name) + 1
    numVals = self.num_nodes()
    self.__ex_put_var(step, &#39;EX_NODAL&#39;, var_id, 0, numVals, values)
    return True</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.put_polyhedra_elem_blk"><code class="name flex">
<span>def <span class="ident">put_polyhedra_elem_blk</span></span>(<span>self, blkID, num_elems_this_blk, num_faces, num_attr_per_elem)</span>
</code></dt>
<dd>
<div class="desc"><p>put in an element block with polyhedral elements</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; status = exo.put_polyhedra_elem_blk(blkID, num_elems_this_blk,
...                                     num_faces, num_attr_per_elem)
</code></pre>
<h2 id="parameters">Parameters</h2>
<pre><code>&lt;int&gt;     blkID               id of the block to be added
&lt;int&gt;     num_elems_this_blk
&lt;int&gt;     num_faces  total number of faces in this block
&lt;int&gt;     num_attr_per_elem
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>status</code></strong> :&ensp;<code>bool</code></dt>
<dd>True = successful execution</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put_polyhedra_elem_blk(self, blkID,
                           num_elems_this_blk,
                           num_faces,
                           num_attr_per_elem):
    &#34;&#34;&#34;
    put in an element block with polyhedral elements

    &gt;&gt;&gt; status = exo.put_polyhedra_elem_blk(blkID, num_elems_this_blk,
    ...                                     num_faces, num_attr_per_elem)

    Parameters
    ----------
        &lt;int&gt;     blkID               id of the block to be added
        &lt;int&gt;     num_elems_this_blk
        &lt;int&gt;     num_faces  total number of faces in this block
        &lt;int&gt;     num_attr_per_elem

    Returns
    -------
    status : bool
        True = successful execution
    &#34;&#34;&#34;

    ebType = ctypes.c_int(get_entity_type(&#39;EX_ELEM_BLOCK&#39;))
    EXODUS_LIB.ex_put_block(self.fileId, ebType, ctypes.c_longlong(blkID),
                            ctypes.create_string_buffer(b&#34;NFACED&#34;),
                            ctypes.c_longlong(num_elems_this_blk),
                            ctypes.c_longlong(0),
                            ctypes.c_longlong(0),
                            ctypes.c_longlong(num_faces),
                            ctypes.c_longlong(num_attr_per_elem))
    return True</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.put_polyhedra_face_blk"><code class="name flex">
<span>def <span class="ident">put_polyhedra_face_blk</span></span>(<span>self, blkID, num_faces_this_blk, num_nodes, num_attr_per_face)</span>
</code></dt>
<dd>
<div class="desc"><p>put in a block of faces</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; status = exo.put_polyhedra_face_blk(blkID, num_faces_this_blk,
...                                     num_nodes, num_attr_per_face)
</code></pre>
<h2 id="parameters">Parameters</h2>
<pre><code>&lt;int&gt;     blkID               id of the block to be added
&lt;int&gt;     num_faces_this_blk
&lt;int&gt;     num_nodes           total number of nodes in this block
&lt;int&gt;     num_attr_per_face
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>status</code></strong> :&ensp;<code>bool</code></dt>
<dd>True = successful execution</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put_polyhedra_face_blk(self, blkID,
                           num_faces_this_blk,
                           num_nodes,
                           num_attr_per_face):
    &#34;&#34;&#34;
    put in a block of faces

    &gt;&gt;&gt; status = exo.put_polyhedra_face_blk(blkID, num_faces_this_blk,
    ...                                     num_nodes, num_attr_per_face)

    Parameters
    ----------
        &lt;int&gt;     blkID               id of the block to be added
        &lt;int&gt;     num_faces_this_blk
        &lt;int&gt;     num_nodes           total number of nodes in this block
        &lt;int&gt;     num_attr_per_face

    Returns
    -------
    status : bool
        True = successful execution
    &#34;&#34;&#34;
    fbType = ctypes.c_int(get_entity_type(&#39;EX_FACE_BLOCK&#39;))
    EXODUS_LIB.ex_put_block(self.fileId, fbType, ctypes.c_longlong(blkID),
                            ctypes.create_string_buffer(b&#34;NSIDED&#34;),
                            ctypes.c_longlong(num_faces_this_blk),
                            ctypes.c_longlong(num_nodes),
                            ctypes.c_longlong(0),
                            ctypes.c_longlong(0),
                            ctypes.c_longlong(num_attr_per_face))
    return True</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.put_qa_records"><code class="name flex">
<span>def <span class="ident">put_qa_records</span></span>(<span>self, records)</span>
</code></dt>
<dd>
<div class="desc"><p>store a list of QA records where each QA record is a length-4 tuple of strings:
1. the software name that accessed/modified the database
2. the software descriptor, e.g. version
3. additional software data
4. time stamp</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; status = exo.put_qa_records()
</code></pre>
<h2 id="parameter">Parameter</h2>
<p>qa_recs : <list\<tuple[4]\<string>>></p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>status</code></strong> :&ensp;<code>bool</code></dt>
<dd>True = successful execution</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put_qa_records(self, records):
    &#34;&#34;&#34;
    store a list of QA records where each QA record is a length-4 tuple of strings:
      1. the software name that accessed/modified the database
      2. the software descriptor, e.g. version
      3. additional software data
      4. time stamp

    &gt;&gt;&gt; status = exo.put_qa_records()

    Parameter
    ---------
    qa_recs : &lt;list&lt;tuple[4]&lt;string&gt;&gt;&gt;

    Returns
    ------
    status : bool
        True = successful execution
    &#34;&#34;&#34;
    for rec in records:
        assert len(rec) == 4
        for recEntry in rec:
            assert len(str(recEntry).encode(&#39;ascii&#39;)) &lt; MAX_STR_LENGTH
    return self.__ex_put_qa(records)</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.put_reduction_variable_name"><code class="name flex">
<span>def <span class="ident">put_reduction_variable_name</span></span>(<span>self, objType, name, index)</span>
</code></dt>
<dd>
<div class="desc"><p>add the name and index of a new reduction variable to the model;
variable indexing goes from 1 to exo.get_reductino_variable_number()</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; status = exo.put_reduction_variable_name('EX_ASSEMBLY', assemvar_name, assemvar_index)
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>objType</code></strong> :&ensp;<code>string</code></dt>
<dd>object type</dd>
<dt><strong><code>var_name</code></strong> :&ensp;<code>string</code></dt>
<dd>name of new variable</dd>
<dt><strong><code>nvar_index</code></strong> :&ensp;<code>int</code></dt>
<dd>1-based index of new nodal variable</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>status</code></strong> :&ensp;<code>bool</code></dt>
<dd>True = successful execution</dd>
</dl>
<h2 id="note">Note:</h2>
<p>this method is often called within the following sequence:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; num_assem_vars = exo.get_reduction_variable_number('EX_ASSEMBLY')
&gt;&gt;&gt; new_assem_var_index = num_assem_vars + 1
&gt;&gt;&gt; num_assem_vars += 1
&gt;&gt;&gt; exo.set_reduction_variable_number('EX_ASSEMBLY', num_assem_vars)
&gt;&gt;&gt; exo.put_reduction_variable_name('EX_ASSEMBLY', &quot;new_assem_var_name&quot;, new_assem_var_index)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put_reduction_variable_name(self, objType, name, index):
    &#34;&#34;&#34;
    add the name and index of a new reduction variable to the model;
    variable indexing goes from 1 to exo.get_reductino_variable_number()

    &gt;&gt;&gt; status = exo.put_reduction_variable_name(&#39;EX_ASSEMBLY&#39;, assemvar_name, assemvar_index)

    Parameters
    ----------
    objType : string
        object type
    var_name : string
        name of new variable
    nvar_index : int
        1-based index of new nodal variable

    Returns
    -------
    status : bool
        True = successful execution

    Note:
    ----
    this method is often called within the following sequence:

    &gt;&gt;&gt; num_assem_vars = exo.get_reduction_variable_number(&#39;EX_ASSEMBLY&#39;)
    &gt;&gt;&gt; new_assem_var_index = num_assem_vars + 1
    &gt;&gt;&gt; num_assem_vars += 1
    &gt;&gt;&gt; exo.set_reduction_variable_number(&#39;EX_ASSEMBLY&#39;, num_assem_vars)
    &gt;&gt;&gt; exo.put_reduction_variable_name(&#39;EX_ASSEMBLY&#39;, &#34;new_assem_var_name&#34;, new_assem_var_index)
    &#34;&#34;&#34;
    varNames = self.get_reduction_variable_names(objType)
    if name in varNames:
        print(&#34;WARNING: variable \&#34;{}\&#34; already exists.&#34;.format(name))
    if index &gt; len(varNames):
        raise Exception(&#34;ERROR: variable index out of range.&#34;)
    self.__ex_put_reduction_variable_name(objType, index, name)
    return True</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.put_reduction_variable_values"><code class="name flex">
<span>def <span class="ident">put_reduction_variable_values</span></span>(<span>self, objType, id, step, values)</span>
</code></dt>
<dd>
<div class="desc"><p>store a list of 'objType' variable values for a specified entity,
and time step</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; status = exo.put_redcution_variable_values('EX_ELEM_BLOCK', elem_blk_id,
...             time_step, evar_vals)
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>objType</code></strong> :&ensp;<code><a title="exodus3.ex_entity_type" href="#exodus3.ex_entity_type">ex_entity_type</a></code></dt>
<dd>type of object begin queried</dd>
<dt><strong><code>id</code></strong> :&ensp;<code>int</code></dt>
<dd>element block <em>ID</em> (not <em>INDEX</em>)
<int>
time_step
1-based index of time step
<list\<float>>
evar_vals</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>status</code></strong> :&ensp;<code>bool</code></dt>
<dd>True = successful execution</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put_reduction_variable_values(self, objType, id, step, values):
    &#34;&#34;&#34;
    store a list of &#39;objType&#39; variable values for a specified entity,
    and time step

    &gt;&gt;&gt; status = exo.put_redcution_variable_values(&#39;EX_ELEM_BLOCK&#39;, elem_blk_id,
    ...             time_step, evar_vals)

    Parameters
    ----------
    objType : ex_entity_type
        type of object begin queried
    id : int
        element block *ID* (not *INDEX*)
        &lt;int&gt;          time_step    1-based index of time step
        &lt;list&lt;float&gt;&gt;  evar_vals

    Returns
    -------
    status : bool
        True = successful execution
    &#34;&#34;&#34;
    numVals = self.get_reduction_variable_number(objType)
    self.__ex_put_reduction_vars(step, objType, id, numVals, values)
    return True</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.put_set_params"><code class="name flex">
<span>def <span class="ident">put_set_params</span></span>(<span>self, object_type, object_id, numSetEntity, numSetDistFacts=None)</span>
</code></dt>
<dd>
<div class="desc"><p>initialize a new set of the specified type</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; exo.put_set_params('EX_NODE_SET', node_set_id,
...                 num_ns_nodes, num_ns_dist_facts)
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>set_id</code></strong> :&ensp;<code>int</code></dt>
<dd>set <em>ID</em> (not <em>INDEX</em>)</dd>
<dt><strong><code>num_set_entity</code></strong> :&ensp;<code>int</code></dt>
<dd>number of nodes/edges/faces/elements to be added to set</dd>
<dt><strong><code>num_dist_facts</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>number of distribution factors (e.g. nodal 'weights') &ndash;
must be equal to zero or num_set_entity</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put_set_params(self, object_type, object_id, numSetEntity, numSetDistFacts=None):
    &#34;&#34;&#34;
    initialize a new set of the specified type

    &gt;&gt;&gt; exo.put_set_params(&#39;EX_NODE_SET&#39;, node_set_id,
    ...                 num_ns_nodes, num_ns_dist_facts)

    Parameters
    ----------
    set_id : int
        set *ID* (not *INDEX*)
    num_set_entity : int
        number of nodes/edges/faces/elements to be added to set
    num_dist_facts : int, optional
        number of distribution factors (e.g. nodal &#39;weights&#39;) --
        must be equal to zero or num_set_entity
    &#34;&#34;&#34;
    if numSetDistFacts is None:
        numSetDistFacts = numSetEntity
    assert numSetDistFacts in (0, numSetEntity)
    self.__ex_put_set_param(object_type, object_id, numSetEntity, numSetDistFacts)</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.put_side_set"><code class="name flex">
<span>def <span class="ident">put_side_set</span></span>(<span>self, object_id, sideSetElements, sideSetSides)</span>
</code></dt>
<dd>
<div class="desc"><p>store a side set by its id and the lists of element and side
indices in the side set; the two lists correspond: together,
ss_elems[i] and ss_sides[i] define the face of an element</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; exo.put_side_set(side_set_id, ss_elems, ss_sides)
</code></pre>
<h2 id="parameters">Parameters</h2>
<pre><code>&lt;int&gt;        side_set_id  side set *ID* (not *INDEX*)
&lt;list&lt;int&gt;&gt;  ss_elems
&lt;list&lt;int&gt;&gt;  ss_sides
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put_side_set(self, object_id, sideSetElements, sideSetSides):
    &#34;&#34;&#34;
    store a side set by its id and the lists of element and side
    indices in the side set; the two lists correspond: together,
    ss_elems[i] and ss_sides[i] define the face of an element

    &gt;&gt;&gt; exo.put_side_set(side_set_id, ss_elems, ss_sides)

    Parameters
    ----------
        &lt;int&gt;        side_set_id  side set *ID* (not *INDEX*)
        &lt;list&lt;int&gt;&gt;  ss_elems
        &lt;list&lt;int&gt;&gt;  ss_sides
    &#34;&#34;&#34;
    self.__ex_put_side_set(object_id, sideSetElements, sideSetSides)</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.put_side_set_dist_fact"><code class="name flex">
<span>def <span class="ident">put_side_set_dist_fact</span></span>(<span>self, object_id, sideSetDistFact)</span>
</code></dt>
<dd>
<div class="desc"><p>store the list of distribution factors for nodes in a side set</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; exo.put_side_set_dist_fact(side_set_id, ss_dist_facts)
</code></pre>
<h2 id="parameters">Parameters</h2>
<pre><code>&lt;int&gt;          node_set_id    node set *ID* (not *INDEX*)
&lt;list&lt;float&gt;&gt;  ns_dist_facts  a list of distribution factors,
  e.g. nodal 'weights'
</code></pre>
<h2 id="note">Note:</h2>
<p>The number of nodes (and distribution factors) in a side set is
the sum of all face nodes.
A single node can be counted more
than once, i.e. once for each face it belongs to in the side set.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put_side_set_dist_fact(self, object_id, sideSetDistFact):
    &#34;&#34;&#34;
    store the list of distribution factors for nodes in a side set

    &gt;&gt;&gt; exo.put_side_set_dist_fact(side_set_id, ss_dist_facts)

    Parameters
    ----------
        &lt;int&gt;          node_set_id    node set *ID* (not *INDEX*)
        &lt;list&lt;float&gt;&gt;  ns_dist_facts  a list of distribution factors,
          e.g. nodal &#39;weights&#39;

    Note:
    -----
    The number of nodes (and distribution factors) in a side set is
    the sum of all face nodes.  A single node can be counted more
    than once, i.e. once for each face it belongs to in the side set.
    &#34;&#34;&#34;
    self.__ex_put_side_set_dist_fact(object_id, sideSetDistFact)</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.put_side_set_name"><code class="name flex">
<span>def <span class="ident">put_side_set_name</span></span>(<span>self, object_id, name)</span>
</code></dt>
<dd>
<div class="desc"><p>store the name of a side set</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; exo.put_side_set_name(side_set_id, side_set_name)
</code></pre>
<h2 id="parameters">Parameters</h2>
<pre><code>&lt;int&gt;     side_set_id    side set *ID* (not *INDEX*)
&lt;string&gt;  side_set_name
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put_side_set_name(self, object_id, name):
    &#34;&#34;&#34;
    store the name of a side set

    &gt;&gt;&gt; exo.put_side_set_name(side_set_id, side_set_name)

    Parameters
    ----------
        &lt;int&gt;     side_set_id    side set *ID* (not *INDEX*)
        &lt;string&gt;  side_set_name
    &#34;&#34;&#34;
    self.__ex_put_name(&#39;EX_SIDE_SET&#39;, object_id, name)</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.put_side_set_names"><code class="name flex">
<span>def <span class="ident">put_side_set_names</span></span>(<span>self, names)</span>
</code></dt>
<dd>
<div class="desc"><p>store a list of all side set names ordered by side set <em>INDEX</em>;
(see <code><a title="exodus3.exodus.get_ids" href="#exodus3.exodus.get_ids">exodus.get_ids()</a></code> for explanation of the
difference between side set <em>ID</em> and side set <em>INDEX</em>)</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; exo.put_side_set_names(side_set_names)
</code></pre>
<h2 id="parameters">Parameters</h2>
<pre><code>&lt;list&lt;string&gt;&gt;  side_set_names
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put_side_set_names(self, names):
    &#34;&#34;&#34;
    store a list of all side set names ordered by side set *INDEX*;
    (see `exodus.get_ids` for explanation of the
    difference between side set *ID* and side set *INDEX*)

    &gt;&gt;&gt; exo.put_side_set_names(side_set_names)

    Parameters
    ----------
        &lt;list&lt;string&gt;&gt;  side_set_names
    &#34;&#34;&#34;
    self.__ex_put_names(&#39;EX_SIDE_SET&#39;, names)</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.put_side_set_params"><code class="name flex">
<span>def <span class="ident">put_side_set_params</span></span>(<span>self, object_id, numSetSides, numSetDistFacts)</span>
</code></dt>
<dd>
<div class="desc"><p>initialize a new side set</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; exo.put_side_set_params(side_set_id, num_ss_sides, num_ss_dist_facts)
</code></pre>
<h2 id="parameters">Parameters</h2>
<pre><code>&lt;int&gt;  side_set_id        side set *ID* (not *INDEX*)
&lt;int&gt;  num_ss_sides       number of sides to be added to set
&lt;int&gt;  num_ss_dist_facts  number of nodal distribution factors
  (e.g. nodal 'weights')
</code></pre>
<h2 id="note">Note:</h2>
<p>The number of nodes (and distribution factors) in a side set is
the sum of all face nodes.
A single node can be counted more
than once, i.e. once for each face it belongs to in the side set.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put_side_set_params(self, object_id, numSetSides, numSetDistFacts):
    &#34;&#34;&#34;
    initialize a new side set

    &gt;&gt;&gt; exo.put_side_set_params(side_set_id, num_ss_sides, num_ss_dist_facts)

    Parameters
    ----------
        &lt;int&gt;  side_set_id        side set *ID* (not *INDEX*)
        &lt;int&gt;  num_ss_sides       number of sides to be added to set
        &lt;int&gt;  num_ss_dist_facts  number of nodal distribution factors
          (e.g. nodal &#39;weights&#39;)

    Note:
    -----
    The number of nodes (and distribution factors) in a side set is
    the sum of all face nodes.  A single node can be counted more
    than once, i.e. once for each face it belongs to in the side set.
    &#34;&#34;&#34;
    self.__ex_put_set_param(&#39;EX_SIDE_SET&#39;, object_id, numSetSides, numSetDistFacts)</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.put_side_set_property_value"><code class="name flex">
<span>def <span class="ident">put_side_set_property_value</span></span>(<span>self, object_id, name, value)</span>
</code></dt>
<dd>
<div class="desc"><p>store a side set property name and its integer value for a
side set</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; status = exo.put_side_set_property_value(side_set_id,
...               ssprop_name, ssprop_val)
</code></pre>
<h2 id="parameters">Parameters</h2>
<pre><code>&lt;int&gt;     side_set_id  side set *ID* (not *INDEX*)
&lt;string&gt;  ssprop_name
&lt;int&gt;     ssprop_val
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>status</code></strong> :&ensp;<code>bool</code></dt>
<dd>True = successful execution</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put_side_set_property_value(self, object_id, name, value):
    &#34;&#34;&#34;
    store a side set property name and its integer value for a
    side set

    &gt;&gt;&gt; status = exo.put_side_set_property_value(side_set_id,
    ...               ssprop_name, ssprop_val)

    Parameters
    ----------
        &lt;int&gt;     side_set_id  side set *ID* (not *INDEX*)
        &lt;string&gt;  ssprop_name
        &lt;int&gt;     ssprop_val

    Returns
    -------
    status : bool
        True = successful execution
    &#34;&#34;&#34;
    return self.__ex_put_prop(&#39;EX_SIDE_SET&#39;, object_id, name, value)</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.put_side_set_variable_name"><code class="name flex">
<span>def <span class="ident">put_side_set_variable_name</span></span>(<span>self, name, index)</span>
</code></dt>
<dd>
<div class="desc"><p>add the name and index of a new side set variable to the model;
side set variable indexing goes from 1 to
exo.get_side_set_variable_number()</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; status = exo.put_side_set_variable_name(ssvar_name, ssvar_index)
</code></pre>
<h2 id="parameters">Parameters</h2>
<pre><code>&lt;string&gt;  ssvar_name   name of new side set variable
&lt;int&gt;     ssvar_index  1-based index of new side set variable
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>status</code></strong> :&ensp;<code>bool</code></dt>
<dd>True = successful execution</dd>
</dl>
<h2 id="note">Note:</h2>
<p>this method is often called within the following sequence:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; num_ssvars = exo.get_side_set_variable_number()
&gt;&gt;&gt; new_ssvar_index = num_ssvars + 1
&gt;&gt;&gt; num_ssvars += 1
&gt;&gt;&gt; exo.set_side_set_variable_number(num_ssvars)
&gt;&gt;&gt; exo.put_side_set_variable_name(&quot;new_ssvar&quot;, new_ssvar_index)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put_side_set_variable_name(self, name, index):
    &#34;&#34;&#34;
    add the name and index of a new side set variable to the model;
    side set variable indexing goes from 1 to
    exo.get_side_set_variable_number()

    &gt;&gt;&gt; status = exo.put_side_set_variable_name(ssvar_name, ssvar_index)

    Parameters
    ----------
        &lt;string&gt;  ssvar_name   name of new side set variable
        &lt;int&gt;     ssvar_index  1-based index of new side set variable

    Returns
    -------
    status : bool
        True = successful execution

    Note:
    -----
    this method is often called within the following sequence:

    &gt;&gt;&gt; num_ssvars = exo.get_side_set_variable_number()
    &gt;&gt;&gt; new_ssvar_index = num_ssvars + 1
    &gt;&gt;&gt; num_ssvars += 1
    &gt;&gt;&gt; exo.set_side_set_variable_number(num_ssvars)
    &gt;&gt;&gt; exo.put_side_set_variable_name(&#34;new_ssvar&#34;, new_ssvar_index)

    &#34;&#34;&#34;
    SSvarNames = self.get_variable_names(&#39;EX_SIDE_SET&#39;)
    if name in SSvarNames:
        print(&#34;WARNING: Side set variable \&#34;{}\&#34; already exists.&#34;.format(name))
    if index &gt; len(SSvarNames):
        raise Exception(&#34;ERROR: variable index out of range.&#34;)
    self.__ex_put_variable_name(&#39;EX_SIDE_SET&#39;, index, name)
    return True</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.put_side_set_variable_values"><code class="name flex">
<span>def <span class="ident">put_side_set_variable_values</span></span>(<span>self, object_id, name, step, values)</span>
</code></dt>
<dd>
<div class="desc"><p>store a list of side set variable values for a specified side
set, side set variable name, and time step; the list has one
variable value per side in the set</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; status = exo.put_side_set_variable_values(side_set_id,
...              ssvar_name, time_step, ssvar_vals)
</code></pre>
<h2 id="parameters">Parameters</h2>
<pre><code>&lt;int&gt;          side_set_id  side set *ID* (not *INDEX*)
&lt;string&gt;       ssvar_name   name of side set variable
&lt;int&gt;          time_step    1-based index of time step
&lt;list&lt;float&gt;&gt;  ssvar_vals
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>status</code></strong> :&ensp;<code>bool</code></dt>
<dd>True = successful execution</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put_side_set_variable_values(self, object_id, name, step, values):
    &#34;&#34;&#34;
    store a list of side set variable values for a specified side
    set, side set variable name, and time step; the list has one
    variable value per side in the set

    &gt;&gt;&gt; status = exo.put_side_set_variable_values(side_set_id,
    ...              ssvar_name, time_step, ssvar_vals)

    Parameters
    ----------
        &lt;int&gt;          side_set_id  side set *ID* (not *INDEX*)
        &lt;string&gt;       ssvar_name   name of side set variable
        &lt;int&gt;          time_step    1-based index of time step
        &lt;list&lt;float&gt;&gt;  ssvar_vals

    Returns
    -------
    status : bool
        True = successful execution
    &#34;&#34;&#34;
    self.put_variable_values(&#39;EX_SIDE_SET&#39;, object_id, name, step, values)
    return True</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.put_time"><code class="name flex">
<span>def <span class="ident">put_time</span></span>(<span>self, step, value)</span>
</code></dt>
<dd>
<div class="desc"><p>store a new time</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; exo.put_time(time_step, time_val)
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>time_step</code></strong> :&ensp;<code>int</code></dt>
<dd>time step index (1-based)</dd>
<dt><strong><code>time_val</code></strong> :&ensp;<code>float</code></dt>
<dd>time value for this step</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>status</code></strong> :&ensp;<code>bool</code></dt>
<dd>True = successful execution</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put_time(self, step, value):
    &#34;&#34;&#34;
    store a new time

    &gt;&gt;&gt; exo.put_time(time_step, time_val)

    Parameters
    ----------
    time_step : int
        time step index (1-based)
    time_val : float
        time value for this step

    Returns
    -------
    status : bool
        True = successful execution
    &#34;&#34;&#34;
    self.__ex_put_time(step, value)
    self.numTimes = ctypes.c_int(self.__ex_inquire_int(ex_inquiry_map(&#39;EX_INQ_TIME&#39;)))
    return True</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.put_variable_name"><code class="name flex">
<span>def <span class="ident">put_variable_name</span></span>(<span>self, objType, name, index)</span>
</code></dt>
<dd>
<div class="desc"><p>add the name and index of a new variable to the model;
variable indexing goes from 1 to exo.get_variable_number()</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; status = exo.put_variable_name('EX_NODAL', nvar_name, nvar_index)
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>objType</code></strong> :&ensp;<code>string</code></dt>
<dd>object type</dd>
<dt><strong><code>var_name</code></strong> :&ensp;<code>string</code></dt>
<dd>name of new variable</dd>
<dt><strong><code>nvar_index</code></strong> :&ensp;<code>int</code></dt>
<dd>1-based index of new nodal variable</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>status</code></strong> :&ensp;<code>bool</code></dt>
<dd>True = successful execution</dd>
</dl>
<h2 id="note">Note:</h2>
<p>this method is often called within the following sequence:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; num_nvars = exo.get_variable_number('EX_NODAL')
&gt;&gt;&gt; new_nvar_index = num_nvars + 1
&gt;&gt;&gt; num_nvars += 1
&gt;&gt;&gt; exo.set_variable_number('EX_NODAL', num_nvars)
&gt;&gt;&gt; exo.put_variable_name('EX_NODAL', &quot;new_nvar_name&quot;, new_nvar_index)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put_variable_name(self, objType, name, index):
    &#34;&#34;&#34;
    add the name and index of a new variable to the model;
    variable indexing goes from 1 to exo.get_variable_number()

    &gt;&gt;&gt; status = exo.put_variable_name(&#39;EX_NODAL&#39;, nvar_name, nvar_index)

    Parameters
    ----------
    objType : string
        object type
    var_name : string
        name of new variable
    nvar_index : int
        1-based index of new nodal variable

    Returns
    -------
    status : bool
        True = successful execution

    Note:
    ----
    this method is often called within the following sequence:

    &gt;&gt;&gt; num_nvars = exo.get_variable_number(&#39;EX_NODAL&#39;)
    &gt;&gt;&gt; new_nvar_index = num_nvars + 1
    &gt;&gt;&gt; num_nvars += 1
    &gt;&gt;&gt; exo.set_variable_number(&#39;EX_NODAL&#39;, num_nvars)
    &gt;&gt;&gt; exo.put_variable_name(&#39;EX_NODAL&#39;, &#34;new_nvar_name&#34;, new_nvar_index)
    &#34;&#34;&#34;
    varNames = self.get_variable_names(objType)
    if name in varNames:
        print(&#34;WARNING: variable \&#34;{}\&#34; already exists.&#34;.format(name))
    if index &gt; len(varNames):
        raise Exception(&#34;ERROR: variable index out of range.&#34;)
    self.__ex_put_variable_name(objType, index, name)
    return True</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.put_variable_values"><code class="name flex">
<span>def <span class="ident">put_variable_values</span></span>(<span>self, objType, entityId, name, step, values)</span>
</code></dt>
<dd>
<div class="desc"><p>store a list of element variable values for a specified element
block, element variable name, and time step</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; status = exo.put_variable_values('EX_ELEM_BLOCK', elem_blk_id,
...             evar_name, time_step, evar_vals)
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>entityId</code></strong> :&ensp;<code>int
entity *ID* (not *INDEX*)</code></dt>
<dd><string>
name
name of variable
<int>
time_step
1-based index of time step
<list\<float>>
values the variable values to be output</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>status</code></strong> :&ensp;<code>bool</code></dt>
<dd>True = successful execution</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put_variable_values(self, objType, entityId, name, step, values):
    &#34;&#34;&#34;
    store a list of element variable values for a specified element
    block, element variable name, and time step

    &gt;&gt;&gt; status = exo.put_variable_values(&#39;EX_ELEM_BLOCK&#39;, elem_blk_id,
    ...             evar_name, time_step, evar_vals)

    Parameters
    ----------
    entityId : int  entity *ID* (not *INDEX*)
        &lt;string&gt;    name    name of variable
        &lt;int&gt;          time_step    1-based index of time step
        &lt;list&lt;float&gt;&gt;  values the variable values to be output

    Returns
    -------
    status : bool
        True = successful execution
    &#34;&#34;&#34;
    names = self.get_variable_names(objType)
    var_id = names.index(name) + 1
    numVals = 0
    if objType == &#39;EX_NODAL&#39;:
        numVals = self.num_nodes()
    elif objType == &#39;EX_ELEM_BLOCK&#39;:
        numVals = self.num_elems_in_blk(entityId)
    elif objType == &#39;EX_NODE_SET&#39;:
        (numVals, _numDistFactInSet) = self.__ex_get_set_param(objType, entityId)
    elif objType == &#39;EX_EDGE_SET&#39;:
        (numVals, _numDistFactInSet) = self.__ex_get_set_param(objType, entityId)
    elif objType == &#39;EX_FACE_SET&#39;:
        (numVals, _numDistFactInSet) = self.__ex_get_set_param(objType, entityId)
    elif objType == &#39;EX_SIDE_SET&#39;:
        (numVals, _numDistFactInSet) = self.__ex_get_set_param(objType, entityId)

    self.__ex_put_var(step, objType, var_id, entityId, numVals, values)
    return True</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.set_element_variable_number"><code class="name flex">
<span>def <span class="ident">set_element_variable_number</span></span>(<span>self, number)</span>
</code></dt>
<dd>
<div class="desc"><p>update the number of element variables in the model</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; status = exo.set_element_variable_number(num_evars)
</code></pre>
<h2 id="parameters">Parameters</h2>
<pre><code>  &lt;int&gt;  num_evars
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>status</code></strong> :&ensp;<code>bool</code></dt>
<dd>True = successful execution</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_element_variable_number(self, number):
    &#34;&#34;&#34;
    update the number of element variables in the model

    &gt;&gt;&gt; status = exo.set_element_variable_number(num_evars)

    Parameters
    ----------
          &lt;int&gt;  num_evars

    Returns
    -------
    status : bool
        True = successful execution
    &#34;&#34;&#34;
    self.__ex_put_variable_param(&#39;EX_ELEM_BLOCK&#39;, number)
    return True</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.set_element_variable_truth_table"><code class="name flex">
<span>def <span class="ident">set_element_variable_truth_table</span></span>(<span>self, table)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="exodus3.exodus.set_variable_truth_table" href="#exodus3.exodus.set_variable_truth_table">exodus.set_variable_truth_table()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_element_variable_truth_table(self, table):
    &#34;&#34;&#34;
    See `exodus.set_variable_truth_table`
    &#34;&#34;&#34;
    return self.set_variable_truth_table(&#39;EX_ELEM_BLOCK&#39;, table)</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.set_global_variable_number"><code class="name flex">
<span>def <span class="ident">set_global_variable_number</span></span>(<span>self, number)</span>
</code></dt>
<dd>
<div class="desc"><p>update the number of global variables in the model</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; status = exo.set_global_variable_number(num_gvars)
</code></pre>
<h2 id="parameters">Parameters</h2>
<pre><code>  &lt;int&gt;  num_gvars
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>status</code></strong> :&ensp;<code>bool</code></dt>
<dd>True = successful execution</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_global_variable_number(self, number):
    &#34;&#34;&#34;
    update the number of global variables in the model

    &gt;&gt;&gt; status = exo.set_global_variable_number(num_gvars)

    Parameters
    ----------
          &lt;int&gt;  num_gvars

    Returns
    -------
    status : bool
        True = successful execution
    &#34;&#34;&#34;
    self.__ex_put_variable_param(&#39;EX_GLOBAL&#39;, number)
    return True</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.set_node_set_variable_number"><code class="name flex">
<span>def <span class="ident">set_node_set_variable_number</span></span>(<span>self, number)</span>
</code></dt>
<dd>
<div class="desc"><p>update the number of node set variables in the model</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; status = exo.set_node_set_variable_number(num_nsvars)
</code></pre>
<h2 id="parameters">Parameters</h2>
<pre><code>  &lt;int&gt;  num_nsvars
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>status</code></strong> :&ensp;<code>bool</code></dt>
<dd>True = successful execution</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_node_set_variable_number(self, number):
    &#34;&#34;&#34;
    update the number of node set variables in the model

    &gt;&gt;&gt; status = exo.set_node_set_variable_number(num_nsvars)

    Parameters
    ----------
          &lt;int&gt;  num_nsvars

    Returns
    -------
    status : bool
        True = successful execution
    &#34;&#34;&#34;
    self.__ex_put_variable_param(&#39;EX_NODE_SET&#39;, number)
    return True</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.set_node_set_variable_truth_table"><code class="name flex">
<span>def <span class="ident">set_node_set_variable_truth_table</span></span>(<span>self, table)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="exodus3.exodus.set_variable_truth_table" href="#exodus3.exodus.set_variable_truth_table">exodus.set_variable_truth_table()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_node_set_variable_truth_table(self, table):
    &#34;&#34;&#34;
    See `exodus.set_variable_truth_table`
    &#34;&#34;&#34;
    return self.set_variable_truth_table(&#39;EX_NODE_SET&#39;, table)</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.set_node_variable_number"><code class="name flex">
<span>def <span class="ident">set_node_variable_number</span></span>(<span>self, number)</span>
</code></dt>
<dd>
<div class="desc"><p>update the number of nodal variables in the model</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; status = exo.set_node_variable_number(num_nvars)
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>num_nvars</code></strong> :&ensp;<code>int</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>status</code></strong> :&ensp;<code>bool</code></dt>
<dd>True = successful execution</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_node_variable_number(self, number):
    &#34;&#34;&#34;
    update the number of nodal variables in the model

    &gt;&gt;&gt; status = exo.set_node_variable_number(num_nvars)

    Parameters
    ----------
    num_nvars : int

    Returns
    -------
    status : bool
        True = successful execution
    &#34;&#34;&#34;
    self.__ex_put_variable_param(&#39;EX_NODAL&#39;, number)
    return True</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.set_reduction_variable_number"><code class="name flex">
<span>def <span class="ident">set_reduction_variable_number</span></span>(<span>self, objType, number)</span>
</code></dt>
<dd>
<div class="desc"><p>update the number of reduction variables in the model</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; status = exo.set_reduction_variable_number('EX_ASSEMBLY', num_nvars)
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>num_nvars</code></strong> :&ensp;<code>&lt;int&gt;</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>status</code></strong> :&ensp;<code>bool</code></dt>
<dd>True = successful execution</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_reduction_variable_number(self, objType, number):
    &#34;&#34;&#34;
    update the number of reduction variables in the model

    &gt;&gt;&gt; status = exo.set_reduction_variable_number(&#39;EX_ASSEMBLY&#39;, num_nvars)

    Parameters
    ----------
    num_nvars :               &lt;int&gt;

    Returns
    -------
    status : bool
        True = successful execution
    &#34;&#34;&#34;
    self.__ex_put_reduction_variable_param(objType, number)
    return True</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.set_side_set_variable_number"><code class="name flex">
<span>def <span class="ident">set_side_set_variable_number</span></span>(<span>self, number)</span>
</code></dt>
<dd>
<div class="desc"><p>update the number of side set variables in the model</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; status = exo.set_side_set_variable_number(num_ssvars)
</code></pre>
<h2 id="parameters">Parameters</h2>
<pre><code>  &lt;int&gt;  num_ssvars
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>status</code></strong> :&ensp;<code>bool</code></dt>
<dd>True = successful execution</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_side_set_variable_number(self, number):
    &#34;&#34;&#34;
    update the number of side set variables in the model

    &gt;&gt;&gt; status = exo.set_side_set_variable_number(num_ssvars)

    Parameters
    ----------
          &lt;int&gt;  num_ssvars

    Returns
    -------
    status : bool
        True = successful execution
    &#34;&#34;&#34;
    self.__ex_put_variable_param(&#39;EX_SIDE_SET&#39;, number)
    return True</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.set_side_set_variable_truth_table"><code class="name flex">
<span>def <span class="ident">set_side_set_variable_truth_table</span></span>(<span>self, table)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="exodus3.exodus.set_variable_truth_table" href="#exodus3.exodus.set_variable_truth_table">exodus.set_variable_truth_table()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_side_set_variable_truth_table(self, table):
    &#34;&#34;&#34;
    See `exodus.set_variable_truth_table`
    &#34;&#34;&#34;
    return self.set_variable_truth_table(&#39;EX_SIDE_SET&#39;, table)</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.set_variable_number"><code class="name flex">
<span>def <span class="ident">set_variable_number</span></span>(<span>self, objType, number)</span>
</code></dt>
<dd>
<div class="desc"><p>update the number of variables in the model</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; status = exo.set_variable_number('EX_NODAL', num_nvars)
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>num_nvars</code></strong> :&ensp;<code>&lt;int&gt;</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>status</code></strong> :&ensp;<code>bool</code></dt>
<dd>True = successful execution</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_variable_number(self, objType, number):
    &#34;&#34;&#34;
    update the number of variables in the model

    &gt;&gt;&gt; status = exo.set_variable_number(&#39;EX_NODAL&#39;, num_nvars)

    Parameters
    ----------
    num_nvars :               &lt;int&gt;

    Returns
    -------
    status : bool
        True = successful execution
    &#34;&#34;&#34;
    self.__ex_put_variable_param(objType, number)
    return True</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.set_variable_truth_table"><code class="name flex">
<span>def <span class="ident">set_variable_truth_table</span></span>(<span>self, objType, table)</span>
</code></dt>
<dd>
<div class="desc"><p>stores a truth table indicating which variables are defined for
all sets/blocks of the specified <code>objType</code> and all variables; variable index cycles
faster than entity index</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; status = exo.set_variable_truth_table('EX_NODE_SET', nsvar_truth_tab)
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>table</code></strong> :&ensp;<code>&lt;list&lt;bool&gt;&gt;</code></dt>
<dd>True for variable defined in a node set, False otherwise</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>status</code></strong> :&ensp;<code>bool</code></dt>
<dd>True = successful execution</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_variable_truth_table(self, objType, table):
    &#34;&#34;&#34;
    stores a truth table indicating which variables are defined for
    all sets/blocks of the specified `objType` and all variables; variable index cycles
    faster than entity index

    &gt;&gt;&gt; status = exo.set_variable_truth_table(&#39;EX_NODE_SET&#39;, nsvar_truth_tab)

    Parameters
    ----------
    table : &lt;list&lt;bool&gt;&gt;
        True for variable defined in a node set, False otherwise

    Returns
    -------
    status : bool
        True = successful execution
    &#34;&#34;&#34;
    return self.__ex_put_truth_table(objType, table)</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.summarize"><code class="name flex">
<span>def <span class="ident">summarize</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Outputs a summary of the exodus file data. Output is similar to:</p>
<pre><code>Database: base_ioshell_copy.e
Title:  This is the title

Number of spatial dimensions = 3                                                 Number of global variables     = 10
Number of node blocks        = 1         Number of nodes              = 1,331    Number of nodal variables      =  2
Number of element blocks     = 1         Number of elements           = 1,000    Number of element variables    =  5
Number of node sets          = 3         Length of node list          =   363    Number of nodeset variables    =  4
Number of element side sets  = 3         Length of element sides      =   300    Number of sideset variables    =  3
Number of assemblies         = 4                                                 Number of assembly variables   = 10
Number of blobs              = 0                                                 Number of blob     variables   =  0
Number of time steps         = 5
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def summarize(self):
    &#34;&#34;&#34;
    Outputs a summary of the exodus file data. Output is similar to:
    ```
    Database: base_ioshell_copy.e
    Title:  This is the title

    Number of spatial dimensions = 3                                                 Number of global variables     = 10
    Number of node blocks        = 1         Number of nodes              = 1,331    Number of nodal variables      =  2
    Number of element blocks     = 1         Number of elements           = 1,000    Number of element variables    =  5
    Number of node sets          = 3         Length of node list          =   363    Number of nodeset variables    =  4
    Number of element side sets  = 3         Length of element sides      =   300    Number of sideset variables    =  3
    Number of assemblies         = 4                                                 Number of assembly variables   = 10
    Number of blobs              = 0                                                 Number of blob     variables   =  0
    Number of time steps         = 5
    ```
    &#34;&#34;&#34;

    total_sides = 0
    sidesets = self.get_ids(&#39;EX_SIDE_SET&#39;)
    for sideset in sidesets:
        total_sides += self.num_faces_in_side_set(sideset)

    total_ns_nodes = 0
    nodesets = self.get_ids(&#39;EX_NODE_SET&#39;)
    for nodeset in nodesets:
        total_ns_nodes += self.num_nodes_in_node_set(nodeset)

    num_glo_vars = self.get_variable_number(&#39;EX_GLOBAL&#39;)
    num_nod_vars = self.get_variable_number(&#39;EX_NODAL&#39;)
    num_ele_vars = self.get_variable_number(&#39;EX_ELEM_BLOCK&#39;)
    num_ns_vars = self.get_variable_number(&#39;EX_NODE_SET&#39;)
    num_ss_vars = self.get_variable_number(&#39;EX_SIDE_SET&#39;)
    num_assem_vars = self.get_reduction_variable_number(&#39;EX_ASSEMBLY&#39;)
    num_blob_vars = self.get_reduction_variable_number(&#39;EX_BLOB&#39;)

    print(&#34;\n Database: {0}\n&#34;
          &#34; Title:\t{17}\n\n&#34;
          &#34; Number of spatial dimensions = {1:3d}\t&#34;
          &#34;                                   {2:11s}\t&#34;
          &#34; Number of global variables     = {11:6d}\n&#34;
          &#34; Number of node blocks        = {5:3d}\t&#34;
          &#34; Number of nodes              = {3:10n}\t&#34;
          &#34; Number of nodal variables      = {12:6d}\n&#34;
          &#34; Number of element blocks     = {6:3n}\t&#34;
          &#34; Number of elements           = {4:10n}\t&#34;
          &#34; Number of element variables    = {13:6d}\n&#34;
          &#34; Number of node sets          = {7:3n}\t&#34;
          &#34; Length of node list          = {9:10n}\t&#34;
          &#34; Number of nodeset variables    = {14:6d}\n&#34;
          &#34; Number of element side sets  = {8:3n}\t&#34;
          &#34; Length of element sides      = {10:10n}\t&#34;
          &#34; Number of sideset variables    = {15:6d}\n&#34;
          &#34; Number of assemblies         = {18:3n}\t&#34;
          &#34;                                   {2:11s}\t&#34;
          &#34; Number of assembly red vars    = {19:6d}\n&#34;
          &#34; Number of blobs              = {20:3n}\t&#34;
          &#34;                                   {2:11s}\t&#34;
          &#34; Number of blob red vars        = {21:6d}\n&#34;
          &#34; Number of time steps         = {16:3n}\n&#34;
          .format(self.fileName,
                  self.num_dimensions(), &#34;&#34;,
                  self.num_nodes(),
                  self.num_elems(),
                  1,
                  self.num_blks(),
                  self.num_node_sets(),
                  self.num_side_sets(),
                  total_ns_nodes, total_sides,
                  num_glo_vars, num_nod_vars, num_ele_vars,
                  num_ns_vars, num_ss_vars, self.num_times(), self.title(),
                  self.num_assembly(), num_assem_vars,
                  self.num_blob(), num_blob_vars))</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.title"><code class="name flex">
<span>def <span class="ident">title</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>get the database title</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; title = exo.title()
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>title</code></strong> :&ensp;<code>string</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def title(self):
    &#34;&#34;&#34;
    get the database title

    &gt;&gt;&gt; title = exo.title()

    Returns
    -------
    title : string
    &#34;&#34;&#34;
    return self.Title.value.decode(&#39;utf8&#39;)</code></pre>
</details>
</dd>
<dt id="exodus3.exodus.version_num"><code class="name flex">
<span>def <span class="ident">version_num</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>get exodus version number used to create the database</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; version = exo.version_num()
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>version</code></strong> :&ensp;<code>string</code></dt>
<dd>representation of version number</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def version_num(self):
    &#34;&#34;&#34;
    get exodus version number used to create the database

    &gt;&gt;&gt; version = exo.version_num()

    Returns
    -------
    version : string
        representation of version number
    &#34;&#34;&#34;
    return &#34;%1.2f&#34; % self.version.value</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="exodus3.add_variables" href="#exodus3.add_variables">add_variables</a></code></li>
<li><code><a title="exodus3.basename" href="#exodus3.basename">basename</a></code></li>
<li><code><a title="exodus3.collectElemConnectivity" href="#exodus3.collectElemConnectivity">collectElemConnectivity</a></code></li>
<li><code><a title="exodus3.collectLocalElemToLocalElems" href="#exodus3.collectLocalElemToLocalElems">collectLocalElemToLocalElems</a></code></li>
<li><code><a title="exodus3.collectLocalNodeToLocalElems" href="#exodus3.collectLocalNodeToLocalElems">collectLocalNodeToLocalElems</a></code></li>
<li><code><a title="exodus3.copyTransfer" href="#exodus3.copyTransfer">copyTransfer</a></code></li>
<li><code><a title="exodus3.copy_mesh" href="#exodus3.copy_mesh">copy_mesh</a></code></li>
<li><code><a title="exodus3.ctype_to_numpy" href="#exodus3.ctype_to_numpy">ctype_to_numpy</a></code></li>
<li><code><a title="exodus3.ex_entity_type_to_objType" href="#exodus3.ex_entity_type_to_objType">ex_entity_type_to_objType</a></code></li>
<li><code><a title="exodus3.ex_inquiry_map" href="#exodus3.ex_inquiry_map">ex_inquiry_map</a></code></li>
<li><code><a title="exodus3.ex_obj_to_inq" href="#exodus3.ex_obj_to_inq">ex_obj_to_inq</a></code></li>
<li><code><a title="exodus3.getExodusVersion" href="#exodus3.getExodusVersion">getExodusVersion</a></code></li>
<li><code><a title="exodus3.get_entity_type" href="#exodus3.get_entity_type">get_entity_type</a></code></li>
<li><code><a title="exodus3.internal_add_variables" href="#exodus3.internal_add_variables">internal_add_variables</a></code></li>
<li><code><a title="exodus3.internal_transfer_variables" href="#exodus3.internal_transfer_variables">internal_transfer_variables</a></code></li>
<li><code><a title="exodus3.setup_ex_assembly" href="#exodus3.setup_ex_assembly">setup_ex_assembly</a></code></li>
<li><code><a title="exodus3.transfer_variables" href="#exodus3.transfer_variables">transfer_variables</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="exodus3.assembly" href="#exodus3.assembly">assembly</a></code></h4>
</li>
<li>
<h4><code><a title="exodus3.attribute" href="#exodus3.attribute">attribute</a></code></h4>
</li>
<li>
<h4><code><a title="exodus3.blob" href="#exodus3.blob">blob</a></code></h4>
</li>
<li>
<h4><code><a title="exodus3.ex_assembly" href="#exodus3.ex_assembly">ex_assembly</a></code></h4>
<ul class="">
<li><code><a title="exodus3.ex_assembly.entity_count" href="#exodus3.ex_assembly.entity_count">entity_count</a></code></li>
<li><code><a title="exodus3.ex_assembly.entity_list" href="#exodus3.ex_assembly.entity_list">entity_list</a></code></li>
<li><code><a title="exodus3.ex_assembly.id" href="#exodus3.ex_assembly.id">id</a></code></li>
<li><code><a title="exodus3.ex_assembly.name" href="#exodus3.ex_assembly.name">name</a></code></li>
<li><code><a title="exodus3.ex_assembly.type" href="#exodus3.ex_assembly.type">type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exodus3.ex_attribute" href="#exodus3.ex_attribute">ex_attribute</a></code></h4>
<ul class="two-column">
<li><code><a title="exodus3.ex_attribute.entity_id" href="#exodus3.ex_attribute.entity_id">entity_id</a></code></li>
<li><code><a title="exodus3.ex_attribute.entity_type" href="#exodus3.ex_attribute.entity_type">entity_type</a></code></li>
<li><code><a title="exodus3.ex_attribute.name" href="#exodus3.ex_attribute.name">name</a></code></li>
<li><code><a title="exodus3.ex_attribute.type" href="#exodus3.ex_attribute.type">type</a></code></li>
<li><code><a title="exodus3.ex_attribute.value_count" href="#exodus3.ex_attribute.value_count">value_count</a></code></li>
<li><code><a title="exodus3.ex_attribute.values" href="#exodus3.ex_attribute.values">values</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exodus3.ex_blob" href="#exodus3.ex_blob">ex_blob</a></code></h4>
<ul class="">
<li><code><a title="exodus3.ex_blob.id" href="#exodus3.ex_blob.id">id</a></code></li>
<li><code><a title="exodus3.ex_blob.name" href="#exodus3.ex_blob.name">name</a></code></li>
<li><code><a title="exodus3.ex_blob.num_entry" href="#exodus3.ex_blob.num_entry">num_entry</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exodus3.ex_entity_type" href="#exodus3.ex_entity_type">ex_entity_type</a></code></h4>
<ul class="two-column">
<li><code><a title="exodus3.ex_entity_type.EX_ASSEMBLY" href="#exodus3.ex_entity_type.EX_ASSEMBLY">EX_ASSEMBLY</a></code></li>
<li><code><a title="exodus3.ex_entity_type.EX_BLOB" href="#exodus3.ex_entity_type.EX_BLOB">EX_BLOB</a></code></li>
<li><code><a title="exodus3.ex_entity_type.EX_COORDINATE" href="#exodus3.ex_entity_type.EX_COORDINATE">EX_COORDINATE</a></code></li>
<li><code><a title="exodus3.ex_entity_type.EX_EDGE_BLOCK" href="#exodus3.ex_entity_type.EX_EDGE_BLOCK">EX_EDGE_BLOCK</a></code></li>
<li><code><a title="exodus3.ex_entity_type.EX_EDGE_MAP" href="#exodus3.ex_entity_type.EX_EDGE_MAP">EX_EDGE_MAP</a></code></li>
<li><code><a title="exodus3.ex_entity_type.EX_EDGE_SET" href="#exodus3.ex_entity_type.EX_EDGE_SET">EX_EDGE_SET</a></code></li>
<li><code><a title="exodus3.ex_entity_type.EX_ELEM_BLOCK" href="#exodus3.ex_entity_type.EX_ELEM_BLOCK">EX_ELEM_BLOCK</a></code></li>
<li><code><a title="exodus3.ex_entity_type.EX_ELEM_MAP" href="#exodus3.ex_entity_type.EX_ELEM_MAP">EX_ELEM_MAP</a></code></li>
<li><code><a title="exodus3.ex_entity_type.EX_ELEM_SET" href="#exodus3.ex_entity_type.EX_ELEM_SET">EX_ELEM_SET</a></code></li>
<li><code><a title="exodus3.ex_entity_type.EX_FACE_BLOCK" href="#exodus3.ex_entity_type.EX_FACE_BLOCK">EX_FACE_BLOCK</a></code></li>
<li><code><a title="exodus3.ex_entity_type.EX_FACE_MAP" href="#exodus3.ex_entity_type.EX_FACE_MAP">EX_FACE_MAP</a></code></li>
<li><code><a title="exodus3.ex_entity_type.EX_FACE_SET" href="#exodus3.ex_entity_type.EX_FACE_SET">EX_FACE_SET</a></code></li>
<li><code><a title="exodus3.ex_entity_type.EX_GLOBAL" href="#exodus3.ex_entity_type.EX_GLOBAL">EX_GLOBAL</a></code></li>
<li><code><a title="exodus3.ex_entity_type.EX_INVALID" href="#exodus3.ex_entity_type.EX_INVALID">EX_INVALID</a></code></li>
<li><code><a title="exodus3.ex_entity_type.EX_NODAL" href="#exodus3.ex_entity_type.EX_NODAL">EX_NODAL</a></code></li>
<li><code><a title="exodus3.ex_entity_type.EX_NODE_BLOCK" href="#exodus3.ex_entity_type.EX_NODE_BLOCK">EX_NODE_BLOCK</a></code></li>
<li><code><a title="exodus3.ex_entity_type.EX_NODE_MAP" href="#exodus3.ex_entity_type.EX_NODE_MAP">EX_NODE_MAP</a></code></li>
<li><code><a title="exodus3.ex_entity_type.EX_NODE_SET" href="#exodus3.ex_entity_type.EX_NODE_SET">EX_NODE_SET</a></code></li>
<li><code><a title="exodus3.ex_entity_type.EX_SIDE_SET" href="#exodus3.ex_entity_type.EX_SIDE_SET">EX_SIDE_SET</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exodus3.ex_init_params" href="#exodus3.ex_init_params">ex_init_params</a></code></h4>
<ul class="two-column">
<li><code><a title="exodus3.ex_init_params.num_assembly" href="#exodus3.ex_init_params.num_assembly">num_assembly</a></code></li>
<li><code><a title="exodus3.ex_init_params.num_blob" href="#exodus3.ex_init_params.num_blob">num_blob</a></code></li>
<li><code><a title="exodus3.ex_init_params.num_dim" href="#exodus3.ex_init_params.num_dim">num_dim</a></code></li>
<li><code><a title="exodus3.ex_init_params.num_edge" href="#exodus3.ex_init_params.num_edge">num_edge</a></code></li>
<li><code><a title="exodus3.ex_init_params.num_edge_blk" href="#exodus3.ex_init_params.num_edge_blk">num_edge_blk</a></code></li>
<li><code><a title="exodus3.ex_init_params.num_edge_maps" href="#exodus3.ex_init_params.num_edge_maps">num_edge_maps</a></code></li>
<li><code><a title="exodus3.ex_init_params.num_edge_sets" href="#exodus3.ex_init_params.num_edge_sets">num_edge_sets</a></code></li>
<li><code><a title="exodus3.ex_init_params.num_elem" href="#exodus3.ex_init_params.num_elem">num_elem</a></code></li>
<li><code><a title="exodus3.ex_init_params.num_elem_blk" href="#exodus3.ex_init_params.num_elem_blk">num_elem_blk</a></code></li>
<li><code><a title="exodus3.ex_init_params.num_elem_maps" href="#exodus3.ex_init_params.num_elem_maps">num_elem_maps</a></code></li>
<li><code><a title="exodus3.ex_init_params.num_elem_sets" href="#exodus3.ex_init_params.num_elem_sets">num_elem_sets</a></code></li>
<li><code><a title="exodus3.ex_init_params.num_face" href="#exodus3.ex_init_params.num_face">num_face</a></code></li>
<li><code><a title="exodus3.ex_init_params.num_face_blk" href="#exodus3.ex_init_params.num_face_blk">num_face_blk</a></code></li>
<li><code><a title="exodus3.ex_init_params.num_face_maps" href="#exodus3.ex_init_params.num_face_maps">num_face_maps</a></code></li>
<li><code><a title="exodus3.ex_init_params.num_face_sets" href="#exodus3.ex_init_params.num_face_sets">num_face_sets</a></code></li>
<li><code><a title="exodus3.ex_init_params.num_node_maps" href="#exodus3.ex_init_params.num_node_maps">num_node_maps</a></code></li>
<li><code><a title="exodus3.ex_init_params.num_node_sets" href="#exodus3.ex_init_params.num_node_sets">num_node_sets</a></code></li>
<li><code><a title="exodus3.ex_init_params.num_nodes" href="#exodus3.ex_init_params.num_nodes">num_nodes</a></code></li>
<li><code><a title="exodus3.ex_init_params.num_side_sets" href="#exodus3.ex_init_params.num_side_sets">num_side_sets</a></code></li>
<li><code><a title="exodus3.ex_init_params.title" href="#exodus3.ex_init_params.title">title</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exodus3.ex_inquiry" href="#exodus3.ex_inquiry">ex_inquiry</a></code></h4>
<ul class="">
<li><code><a title="exodus3.ex_inquiry.EX_INQ_API_VERS" href="#exodus3.ex_inquiry.EX_INQ_API_VERS">EX_INQ_API_VERS</a></code></li>
<li><code><a title="exodus3.ex_inquiry.EX_INQ_ASSEMBLY" href="#exodus3.ex_inquiry.EX_INQ_ASSEMBLY">EX_INQ_ASSEMBLY</a></code></li>
<li><code><a title="exodus3.ex_inquiry.EX_INQ_BLOB" href="#exodus3.ex_inquiry.EX_INQ_BLOB">EX_INQ_BLOB</a></code></li>
<li><code><a title="exodus3.ex_inquiry.EX_INQ_COORD_FRAMES" href="#exodus3.ex_inquiry.EX_INQ_COORD_FRAMES">EX_INQ_COORD_FRAMES</a></code></li>
<li><code><a title="exodus3.ex_inquiry.EX_INQ_DB_FLOAT_SIZE" href="#exodus3.ex_inquiry.EX_INQ_DB_FLOAT_SIZE">EX_INQ_DB_FLOAT_SIZE</a></code></li>
<li><code><a title="exodus3.ex_inquiry.EX_INQ_DB_MAX_ALLOWED_NAME_LENGTH" href="#exodus3.ex_inquiry.EX_INQ_DB_MAX_ALLOWED_NAME_LENGTH">EX_INQ_DB_MAX_ALLOWED_NAME_LENGTH</a></code></li>
<li><code><a title="exodus3.ex_inquiry.EX_INQ_DB_MAX_USED_NAME_LENGTH" href="#exodus3.ex_inquiry.EX_INQ_DB_MAX_USED_NAME_LENGTH">EX_INQ_DB_MAX_USED_NAME_LENGTH</a></code></li>
<li><code><a title="exodus3.ex_inquiry.EX_INQ_DB_VERS" href="#exodus3.ex_inquiry.EX_INQ_DB_VERS">EX_INQ_DB_VERS</a></code></li>
<li><code><a title="exodus3.ex_inquiry.EX_INQ_DIM" href="#exodus3.ex_inquiry.EX_INQ_DIM">EX_INQ_DIM</a></code></li>
<li><code><a title="exodus3.ex_inquiry.EX_INQ_EB_PROP" href="#exodus3.ex_inquiry.EX_INQ_EB_PROP">EX_INQ_EB_PROP</a></code></li>
<li><code><a title="exodus3.ex_inquiry.EX_INQ_EDGE" href="#exodus3.ex_inquiry.EX_INQ_EDGE">EX_INQ_EDGE</a></code></li>
<li><code><a title="exodus3.ex_inquiry.EX_INQ_EDGE_BLK" href="#exodus3.ex_inquiry.EX_INQ_EDGE_BLK">EX_INQ_EDGE_BLK</a></code></li>
<li><code><a title="exodus3.ex_inquiry.EX_INQ_EDGE_MAP" href="#exodus3.ex_inquiry.EX_INQ_EDGE_MAP">EX_INQ_EDGE_MAP</a></code></li>
<li><code><a title="exodus3.ex_inquiry.EX_INQ_EDGE_PROP" href="#exodus3.ex_inquiry.EX_INQ_EDGE_PROP">EX_INQ_EDGE_PROP</a></code></li>
<li><code><a title="exodus3.ex_inquiry.EX_INQ_EDGE_SETS" href="#exodus3.ex_inquiry.EX_INQ_EDGE_SETS">EX_INQ_EDGE_SETS</a></code></li>
<li><code><a title="exodus3.ex_inquiry.EX_INQ_ELEM" href="#exodus3.ex_inquiry.EX_INQ_ELEM">EX_INQ_ELEM</a></code></li>
<li><code><a title="exodus3.ex_inquiry.EX_INQ_ELEM_BLK" href="#exodus3.ex_inquiry.EX_INQ_ELEM_BLK">EX_INQ_ELEM_BLK</a></code></li>
<li><code><a title="exodus3.ex_inquiry.EX_INQ_ELEM_MAP" href="#exodus3.ex_inquiry.EX_INQ_ELEM_MAP">EX_INQ_ELEM_MAP</a></code></li>
<li><code><a title="exodus3.ex_inquiry.EX_INQ_ELEM_SETS" href="#exodus3.ex_inquiry.EX_INQ_ELEM_SETS">EX_INQ_ELEM_SETS</a></code></li>
<li><code><a title="exodus3.ex_inquiry.EX_INQ_ELS_DF_LEN" href="#exodus3.ex_inquiry.EX_INQ_ELS_DF_LEN">EX_INQ_ELS_DF_LEN</a></code></li>
<li><code><a title="exodus3.ex_inquiry.EX_INQ_ELS_LEN" href="#exodus3.ex_inquiry.EX_INQ_ELS_LEN">EX_INQ_ELS_LEN</a></code></li>
<li><code><a title="exodus3.ex_inquiry.EX_INQ_ELS_PROP" href="#exodus3.ex_inquiry.EX_INQ_ELS_PROP">EX_INQ_ELS_PROP</a></code></li>
<li><code><a title="exodus3.ex_inquiry.EX_INQ_EM_PROP" href="#exodus3.ex_inquiry.EX_INQ_EM_PROP">EX_INQ_EM_PROP</a></code></li>
<li><code><a title="exodus3.ex_inquiry.EX_INQ_ES_DF_LEN" href="#exodus3.ex_inquiry.EX_INQ_ES_DF_LEN">EX_INQ_ES_DF_LEN</a></code></li>
<li><code><a title="exodus3.ex_inquiry.EX_INQ_ES_LEN" href="#exodus3.ex_inquiry.EX_INQ_ES_LEN">EX_INQ_ES_LEN</a></code></li>
<li><code><a title="exodus3.ex_inquiry.EX_INQ_ES_PROP" href="#exodus3.ex_inquiry.EX_INQ_ES_PROP">EX_INQ_ES_PROP</a></code></li>
<li><code><a title="exodus3.ex_inquiry.EX_INQ_FACE" href="#exodus3.ex_inquiry.EX_INQ_FACE">EX_INQ_FACE</a></code></li>
<li><code><a title="exodus3.ex_inquiry.EX_INQ_FACE_BLK" href="#exodus3.ex_inquiry.EX_INQ_FACE_BLK">EX_INQ_FACE_BLK</a></code></li>
<li><code><a title="exodus3.ex_inquiry.EX_INQ_FACE_MAP" href="#exodus3.ex_inquiry.EX_INQ_FACE_MAP">EX_INQ_FACE_MAP</a></code></li>
<li><code><a title="exodus3.ex_inquiry.EX_INQ_FACE_PROP" href="#exodus3.ex_inquiry.EX_INQ_FACE_PROP">EX_INQ_FACE_PROP</a></code></li>
<li><code><a title="exodus3.ex_inquiry.EX_INQ_FACE_SETS" href="#exodus3.ex_inquiry.EX_INQ_FACE_SETS">EX_INQ_FACE_SETS</a></code></li>
<li><code><a title="exodus3.ex_inquiry.EX_INQ_FILE_TYPE" href="#exodus3.ex_inquiry.EX_INQ_FILE_TYPE">EX_INQ_FILE_TYPE</a></code></li>
<li><code><a title="exodus3.ex_inquiry.EX_INQ_FS_DF_LEN" href="#exodus3.ex_inquiry.EX_INQ_FS_DF_LEN">EX_INQ_FS_DF_LEN</a></code></li>
<li><code><a title="exodus3.ex_inquiry.EX_INQ_FS_LEN" href="#exodus3.ex_inquiry.EX_INQ_FS_LEN">EX_INQ_FS_LEN</a></code></li>
<li><code><a title="exodus3.ex_inquiry.EX_INQ_FS_PROP" href="#exodus3.ex_inquiry.EX_INQ_FS_PROP">EX_INQ_FS_PROP</a></code></li>
<li><code><a title="exodus3.ex_inquiry.EX_INQ_INFO" href="#exodus3.ex_inquiry.EX_INQ_INFO">EX_INQ_INFO</a></code></li>
<li><code><a title="exodus3.ex_inquiry.EX_INQ_INVALID" href="#exodus3.ex_inquiry.EX_INQ_INVALID">EX_INQ_INVALID</a></code></li>
<li><code><a title="exodus3.ex_inquiry.EX_INQ_LIB_VERS" href="#exodus3.ex_inquiry.EX_INQ_LIB_VERS">EX_INQ_LIB_VERS</a></code></li>
<li><code><a title="exodus3.ex_inquiry.EX_INQ_MAX_READ_NAME_LENGTH" href="#exodus3.ex_inquiry.EX_INQ_MAX_READ_NAME_LENGTH">EX_INQ_MAX_READ_NAME_LENGTH</a></code></li>
<li><code><a title="exodus3.ex_inquiry.EX_INQ_NM_PROP" href="#exodus3.ex_inquiry.EX_INQ_NM_PROP">EX_INQ_NM_PROP</a></code></li>
<li><code><a title="exodus3.ex_inquiry.EX_INQ_NODES" href="#exodus3.ex_inquiry.EX_INQ_NODES">EX_INQ_NODES</a></code></li>
<li><code><a title="exodus3.ex_inquiry.EX_INQ_NODE_MAP" href="#exodus3.ex_inquiry.EX_INQ_NODE_MAP">EX_INQ_NODE_MAP</a></code></li>
<li><code><a title="exodus3.ex_inquiry.EX_INQ_NODE_SETS" href="#exodus3.ex_inquiry.EX_INQ_NODE_SETS">EX_INQ_NODE_SETS</a></code></li>
<li><code><a title="exodus3.ex_inquiry.EX_INQ_NS_DF_LEN" href="#exodus3.ex_inquiry.EX_INQ_NS_DF_LEN">EX_INQ_NS_DF_LEN</a></code></li>
<li><code><a title="exodus3.ex_inquiry.EX_INQ_NS_NODE_LEN" href="#exodus3.ex_inquiry.EX_INQ_NS_NODE_LEN">EX_INQ_NS_NODE_LEN</a></code></li>
<li><code><a title="exodus3.ex_inquiry.EX_INQ_NS_PROP" href="#exodus3.ex_inquiry.EX_INQ_NS_PROP">EX_INQ_NS_PROP</a></code></li>
<li><code><a title="exodus3.ex_inquiry.EX_INQ_QA" href="#exodus3.ex_inquiry.EX_INQ_QA">EX_INQ_QA</a></code></li>
<li><code><a title="exodus3.ex_inquiry.EX_INQ_SIDE_SETS" href="#exodus3.ex_inquiry.EX_INQ_SIDE_SETS">EX_INQ_SIDE_SETS</a></code></li>
<li><code><a title="exodus3.ex_inquiry.EX_INQ_SS_DF_LEN" href="#exodus3.ex_inquiry.EX_INQ_SS_DF_LEN">EX_INQ_SS_DF_LEN</a></code></li>
<li><code><a title="exodus3.ex_inquiry.EX_INQ_SS_ELEM_LEN" href="#exodus3.ex_inquiry.EX_INQ_SS_ELEM_LEN">EX_INQ_SS_ELEM_LEN</a></code></li>
<li><code><a title="exodus3.ex_inquiry.EX_INQ_SS_NODE_LEN" href="#exodus3.ex_inquiry.EX_INQ_SS_NODE_LEN">EX_INQ_SS_NODE_LEN</a></code></li>
<li><code><a title="exodus3.ex_inquiry.EX_INQ_SS_PROP" href="#exodus3.ex_inquiry.EX_INQ_SS_PROP">EX_INQ_SS_PROP</a></code></li>
<li><code><a title="exodus3.ex_inquiry.EX_INQ_TIME" href="#exodus3.ex_inquiry.EX_INQ_TIME">EX_INQ_TIME</a></code></li>
<li><code><a title="exodus3.ex_inquiry.EX_INQ_TITLE" href="#exodus3.ex_inquiry.EX_INQ_TITLE">EX_INQ_TITLE</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exodus3.ex_options" href="#exodus3.ex_options">ex_options</a></code></h4>
<ul class="">
<li><code><a title="exodus3.ex_options.EX_ABORT" href="#exodus3.ex_options.EX_ABORT">EX_ABORT</a></code></li>
<li><code><a title="exodus3.ex_options.EX_DEBUG" href="#exodus3.ex_options.EX_DEBUG">EX_DEBUG</a></code></li>
<li><code><a title="exodus3.ex_options.EX_DEFAULT" href="#exodus3.ex_options.EX_DEFAULT">EX_DEFAULT</a></code></li>
<li><code><a title="exodus3.ex_options.EX_NULLVERBOSE" href="#exodus3.ex_options.EX_NULLVERBOSE">EX_NULLVERBOSE</a></code></li>
<li><code><a title="exodus3.ex_options.EX_VERBOSE" href="#exodus3.ex_options.EX_VERBOSE">EX_VERBOSE</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exodus3.ex_type" href="#exodus3.ex_type">ex_type</a></code></h4>
<ul class="">
<li><code><a title="exodus3.ex_type.EX_CHAR" href="#exodus3.ex_type.EX_CHAR">EX_CHAR</a></code></li>
<li><code><a title="exodus3.ex_type.EX_DOUBLE" href="#exodus3.ex_type.EX_DOUBLE">EX_DOUBLE</a></code></li>
<li><code><a title="exodus3.ex_type.EX_INTEGER" href="#exodus3.ex_type.EX_INTEGER">EX_INTEGER</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exodus3.exodus" href="#exodus3.exodus">exodus</a></code></h4>
<ul class="">
<li><code><a title="exodus3.exodus.close" href="#exodus3.exodus.close">close</a></code></li>
<li><code><a title="exodus3.exodus.copy" href="#exodus3.exodus.copy">copy</a></code></li>
<li><code><a title="exodus3.exodus.elem_blk_info" href="#exodus3.exodus.elem_blk_info">elem_blk_info</a></code></li>
<li><code><a title="exodus3.exodus.elem_type" href="#exodus3.exodus.elem_type">elem_type</a></code></li>
<li><code><a title="exodus3.exodus.get_all_global_variable_values" href="#exodus3.exodus.get_all_global_variable_values">get_all_global_variable_values</a></code></li>
<li><code><a title="exodus3.exodus.get_all_node_set_params" href="#exodus3.exodus.get_all_node_set_params">get_all_node_set_params</a></code></li>
<li><code><a title="exodus3.exodus.get_all_side_set_params" href="#exodus3.exodus.get_all_side_set_params">get_all_side_set_params</a></code></li>
<li><code><a title="exodus3.exodus.get_assemblies" href="#exodus3.exodus.get_assemblies">get_assemblies</a></code></li>
<li><code><a title="exodus3.exodus.get_assembly" href="#exodus3.exodus.get_assembly">get_assembly</a></code></li>
<li><code><a title="exodus3.exodus.get_attribute_count" href="#exodus3.exodus.get_attribute_count">get_attribute_count</a></code></li>
<li><code><a title="exodus3.exodus.get_attributes" href="#exodus3.exodus.get_attributes">get_attributes</a></code></li>
<li><code><a title="exodus3.exodus.get_blob" href="#exodus3.exodus.get_blob">get_blob</a></code></li>
<li><code><a title="exodus3.exodus.get_block_id_map" href="#exodus3.exodus.get_block_id_map">get_block_id_map</a></code></li>
<li><code><a title="exodus3.exodus.get_coord" href="#exodus3.exodus.get_coord">get_coord</a></code></li>
<li><code><a title="exodus3.exodus.get_coord_names" href="#exodus3.exodus.get_coord_names">get_coord_names</a></code></li>
<li><code><a title="exodus3.exodus.get_coords" href="#exodus3.exodus.get_coords">get_coords</a></code></li>
<li><code><a title="exodus3.exodus.get_elem_attr" href="#exodus3.exodus.get_elem_attr">get_elem_attr</a></code></li>
<li><code><a title="exodus3.exodus.get_elem_attr_values" href="#exodus3.exodus.get_elem_attr_values">get_elem_attr_values</a></code></li>
<li><code><a title="exodus3.exodus.get_elem_blk_ids" href="#exodus3.exodus.get_elem_blk_ids">get_elem_blk_ids</a></code></li>
<li><code><a title="exodus3.exodus.get_elem_blk_name" href="#exodus3.exodus.get_elem_blk_name">get_elem_blk_name</a></code></li>
<li><code><a title="exodus3.exodus.get_elem_blk_names" href="#exodus3.exodus.get_elem_blk_names">get_elem_blk_names</a></code></li>
<li><code><a title="exodus3.exodus.get_elem_connectivity" href="#exodus3.exodus.get_elem_connectivity">get_elem_connectivity</a></code></li>
<li><code><a title="exodus3.exodus.get_elem_id_map" href="#exodus3.exodus.get_elem_id_map">get_elem_id_map</a></code></li>
<li><code><a title="exodus3.exodus.get_elem_num_map" href="#exodus3.exodus.get_elem_num_map">get_elem_num_map</a></code></li>
<li><code><a title="exodus3.exodus.get_elem_order_map" href="#exodus3.exodus.get_elem_order_map">get_elem_order_map</a></code></li>
<li><code><a title="exodus3.exodus.get_element_attribute_names" href="#exodus3.exodus.get_element_attribute_names">get_element_attribute_names</a></code></li>
<li><code><a title="exodus3.exodus.get_element_property_names" href="#exodus3.exodus.get_element_property_names">get_element_property_names</a></code></li>
<li><code><a title="exodus3.exodus.get_element_property_value" href="#exodus3.exodus.get_element_property_value">get_element_property_value</a></code></li>
<li><code><a title="exodus3.exodus.get_element_variable_names" href="#exodus3.exodus.get_element_variable_names">get_element_variable_names</a></code></li>
<li><code><a title="exodus3.exodus.get_element_variable_number" href="#exodus3.exodus.get_element_variable_number">get_element_variable_number</a></code></li>
<li><code><a title="exodus3.exodus.get_element_variable_truth_table" href="#exodus3.exodus.get_element_variable_truth_table">get_element_variable_truth_table</a></code></li>
<li><code><a title="exodus3.exodus.get_element_variable_values" href="#exodus3.exodus.get_element_variable_values">get_element_variable_values</a></code></li>
<li><code><a title="exodus3.exodus.get_global_variable_names" href="#exodus3.exodus.get_global_variable_names">get_global_variable_names</a></code></li>
<li><code><a title="exodus3.exodus.get_global_variable_number" href="#exodus3.exodus.get_global_variable_number">get_global_variable_number</a></code></li>
<li><code><a title="exodus3.exodus.get_global_variable_value" href="#exodus3.exodus.get_global_variable_value">get_global_variable_value</a></code></li>
<li><code><a title="exodus3.exodus.get_global_variable_values" href="#exodus3.exodus.get_global_variable_values">get_global_variable_values</a></code></li>
<li><code><a title="exodus3.exodus.get_id_map" href="#exodus3.exodus.get_id_map">get_id_map</a></code></li>
<li><code><a title="exodus3.exodus.get_ids" href="#exodus3.exodus.get_ids">get_ids</a></code></li>
<li><code><a title="exodus3.exodus.get_info_records" href="#exodus3.exodus.get_info_records">get_info_records</a></code></li>
<li><code><a title="exodus3.exodus.get_name" href="#exodus3.exodus.get_name">get_name</a></code></li>
<li><code><a title="exodus3.exodus.get_names" href="#exodus3.exodus.get_names">get_names</a></code></li>
<li><code><a title="exodus3.exodus.get_node_id_map" href="#exodus3.exodus.get_node_id_map">get_node_id_map</a></code></li>
<li><code><a title="exodus3.exodus.get_node_num_map" href="#exodus3.exodus.get_node_num_map">get_node_num_map</a></code></li>
<li><code><a title="exodus3.exodus.get_node_set_dist_facts" href="#exodus3.exodus.get_node_set_dist_facts">get_node_set_dist_facts</a></code></li>
<li><code><a title="exodus3.exodus.get_node_set_ids" href="#exodus3.exodus.get_node_set_ids">get_node_set_ids</a></code></li>
<li><code><a title="exodus3.exodus.get_node_set_name" href="#exodus3.exodus.get_node_set_name">get_node_set_name</a></code></li>
<li><code><a title="exodus3.exodus.get_node_set_names" href="#exodus3.exodus.get_node_set_names">get_node_set_names</a></code></li>
<li><code><a title="exodus3.exodus.get_node_set_nodes" href="#exodus3.exodus.get_node_set_nodes">get_node_set_nodes</a></code></li>
<li><code><a title="exodus3.exodus.get_node_set_params" href="#exodus3.exodus.get_node_set_params">get_node_set_params</a></code></li>
<li><code><a title="exodus3.exodus.get_node_set_property_names" href="#exodus3.exodus.get_node_set_property_names">get_node_set_property_names</a></code></li>
<li><code><a title="exodus3.exodus.get_node_set_property_value" href="#exodus3.exodus.get_node_set_property_value">get_node_set_property_value</a></code></li>
<li><code><a title="exodus3.exodus.get_node_set_variable_names" href="#exodus3.exodus.get_node_set_variable_names">get_node_set_variable_names</a></code></li>
<li><code><a title="exodus3.exodus.get_node_set_variable_number" href="#exodus3.exodus.get_node_set_variable_number">get_node_set_variable_number</a></code></li>
<li><code><a title="exodus3.exodus.get_node_set_variable_truth_table" href="#exodus3.exodus.get_node_set_variable_truth_table">get_node_set_variable_truth_table</a></code></li>
<li><code><a title="exodus3.exodus.get_node_set_variable_values" href="#exodus3.exodus.get_node_set_variable_values">get_node_set_variable_values</a></code></li>
<li><code><a title="exodus3.exodus.get_node_variable_names" href="#exodus3.exodus.get_node_variable_names">get_node_variable_names</a></code></li>
<li><code><a title="exodus3.exodus.get_node_variable_number" href="#exodus3.exodus.get_node_variable_number">get_node_variable_number</a></code></li>
<li><code><a title="exodus3.exodus.get_node_variable_values" href="#exodus3.exodus.get_node_variable_values">get_node_variable_values</a></code></li>
<li><code><a title="exodus3.exodus.get_partial_element_variable_values" href="#exodus3.exodus.get_partial_element_variable_values">get_partial_element_variable_values</a></code></li>
<li><code><a title="exodus3.exodus.get_partial_node_set_variable_values" href="#exodus3.exodus.get_partial_node_set_variable_values">get_partial_node_set_variable_values</a></code></li>
<li><code><a title="exodus3.exodus.get_partial_node_variable_values" href="#exodus3.exodus.get_partial_node_variable_values">get_partial_node_variable_values</a></code></li>
<li><code><a title="exodus3.exodus.get_partial_side_set_variable_values" href="#exodus3.exodus.get_partial_side_set_variable_values">get_partial_side_set_variable_values</a></code></li>
<li><code><a title="exodus3.exodus.get_qa_records" href="#exodus3.exodus.get_qa_records">get_qa_records</a></code></li>
<li><code><a title="exodus3.exodus.get_reduction_variable_name" href="#exodus3.exodus.get_reduction_variable_name">get_reduction_variable_name</a></code></li>
<li><code><a title="exodus3.exodus.get_reduction_variable_names" href="#exodus3.exodus.get_reduction_variable_names">get_reduction_variable_names</a></code></li>
<li><code><a title="exodus3.exodus.get_reduction_variable_number" href="#exodus3.exodus.get_reduction_variable_number">get_reduction_variable_number</a></code></li>
<li><code><a title="exodus3.exodus.get_reduction_variable_values" href="#exodus3.exodus.get_reduction_variable_values">get_reduction_variable_values</a></code></li>
<li><code><a title="exodus3.exodus.get_set_params" href="#exodus3.exodus.get_set_params">get_set_params</a></code></li>
<li><code><a title="exodus3.exodus.get_side_set" href="#exodus3.exodus.get_side_set">get_side_set</a></code></li>
<li><code><a title="exodus3.exodus.get_side_set_dist_fact" href="#exodus3.exodus.get_side_set_dist_fact">get_side_set_dist_fact</a></code></li>
<li><code><a title="exodus3.exodus.get_side_set_ids" href="#exodus3.exodus.get_side_set_ids">get_side_set_ids</a></code></li>
<li><code><a title="exodus3.exodus.get_side_set_name" href="#exodus3.exodus.get_side_set_name">get_side_set_name</a></code></li>
<li><code><a title="exodus3.exodus.get_side_set_names" href="#exodus3.exodus.get_side_set_names">get_side_set_names</a></code></li>
<li><code><a title="exodus3.exodus.get_side_set_node_list" href="#exodus3.exodus.get_side_set_node_list">get_side_set_node_list</a></code></li>
<li><code><a title="exodus3.exodus.get_side_set_params" href="#exodus3.exodus.get_side_set_params">get_side_set_params</a></code></li>
<li><code><a title="exodus3.exodus.get_side_set_property_names" href="#exodus3.exodus.get_side_set_property_names">get_side_set_property_names</a></code></li>
<li><code><a title="exodus3.exodus.get_side_set_property_value" href="#exodus3.exodus.get_side_set_property_value">get_side_set_property_value</a></code></li>
<li><code><a title="exodus3.exodus.get_side_set_variable_names" href="#exodus3.exodus.get_side_set_variable_names">get_side_set_variable_names</a></code></li>
<li><code><a title="exodus3.exodus.get_side_set_variable_number" href="#exodus3.exodus.get_side_set_variable_number">get_side_set_variable_number</a></code></li>
<li><code><a title="exodus3.exodus.get_side_set_variable_truth_table" href="#exodus3.exodus.get_side_set_variable_truth_table">get_side_set_variable_truth_table</a></code></li>
<li><code><a title="exodus3.exodus.get_side_set_variable_values" href="#exodus3.exodus.get_side_set_variable_values">get_side_set_variable_values</a></code></li>
<li><code><a title="exodus3.exodus.get_sierra_input" href="#exodus3.exodus.get_sierra_input">get_sierra_input</a></code></li>
<li><code><a title="exodus3.exodus.get_times" href="#exodus3.exodus.get_times">get_times</a></code></li>
<li><code><a title="exodus3.exodus.get_variable_names" href="#exodus3.exodus.get_variable_names">get_variable_names</a></code></li>
<li><code><a title="exodus3.exodus.get_variable_number" href="#exodus3.exodus.get_variable_number">get_variable_number</a></code></li>
<li><code><a title="exodus3.exodus.get_variable_truth_table" href="#exodus3.exodus.get_variable_truth_table">get_variable_truth_table</a></code></li>
<li><code><a title="exodus3.exodus.get_variable_values" href="#exodus3.exodus.get_variable_values">get_variable_values</a></code></li>
<li><code><a title="exodus3.exodus.inquire" href="#exodus3.exodus.inquire">inquire</a></code></li>
<li><code><a title="exodus3.exodus.num_assembly" href="#exodus3.exodus.num_assembly">num_assembly</a></code></li>
<li><code><a title="exodus3.exodus.num_attr" href="#exodus3.exodus.num_attr">num_attr</a></code></li>
<li><code><a title="exodus3.exodus.num_blks" href="#exodus3.exodus.num_blks">num_blks</a></code></li>
<li><code><a title="exodus3.exodus.num_blob" href="#exodus3.exodus.num_blob">num_blob</a></code></li>
<li><code><a title="exodus3.exodus.num_dimensions" href="#exodus3.exodus.num_dimensions">num_dimensions</a></code></li>
<li><code><a title="exodus3.exodus.num_elems" href="#exodus3.exodus.num_elems">num_elems</a></code></li>
<li><code><a title="exodus3.exodus.num_elems_in_blk" href="#exodus3.exodus.num_elems_in_blk">num_elems_in_blk</a></code></li>
<li><code><a title="exodus3.exodus.num_faces_in_side_set" href="#exodus3.exodus.num_faces_in_side_set">num_faces_in_side_set</a></code></li>
<li><code><a title="exodus3.exodus.num_info_records" href="#exodus3.exodus.num_info_records">num_info_records</a></code></li>
<li><code><a title="exodus3.exodus.num_node_sets" href="#exodus3.exodus.num_node_sets">num_node_sets</a></code></li>
<li><code><a title="exodus3.exodus.num_nodes" href="#exodus3.exodus.num_nodes">num_nodes</a></code></li>
<li><code><a title="exodus3.exodus.num_nodes_in_node_set" href="#exodus3.exodus.num_nodes_in_node_set">num_nodes_in_node_set</a></code></li>
<li><code><a title="exodus3.exodus.num_nodes_per_elem" href="#exodus3.exodus.num_nodes_per_elem">num_nodes_per_elem</a></code></li>
<li><code><a title="exodus3.exodus.num_qa_records" href="#exodus3.exodus.num_qa_records">num_qa_records</a></code></li>
<li><code><a title="exodus3.exodus.num_side_sets" href="#exodus3.exodus.num_side_sets">num_side_sets</a></code></li>
<li><code><a title="exodus3.exodus.num_times" href="#exodus3.exodus.num_times">num_times</a></code></li>
<li><code><a title="exodus3.exodus.put_all_global_variable_values" href="#exodus3.exodus.put_all_global_variable_values">put_all_global_variable_values</a></code></li>
<li><code><a title="exodus3.exodus.put_assemblies" href="#exodus3.exodus.put_assemblies">put_assemblies</a></code></li>
<li><code><a title="exodus3.exodus.put_assembly" href="#exodus3.exodus.put_assembly">put_assembly</a></code></li>
<li><code><a title="exodus3.exodus.put_attribute" href="#exodus3.exodus.put_attribute">put_attribute</a></code></li>
<li><code><a title="exodus3.exodus.put_concat_elem_blk" href="#exodus3.exodus.put_concat_elem_blk">put_concat_elem_blk</a></code></li>
<li><code><a title="exodus3.exodus.put_coord_names" href="#exodus3.exodus.put_coord_names">put_coord_names</a></code></li>
<li><code><a title="exodus3.exodus.put_coords" href="#exodus3.exodus.put_coords">put_coords</a></code></li>
<li><code><a title="exodus3.exodus.put_elem_attr" href="#exodus3.exodus.put_elem_attr">put_elem_attr</a></code></li>
<li><code><a title="exodus3.exodus.put_elem_attr_values" href="#exodus3.exodus.put_elem_attr_values">put_elem_attr_values</a></code></li>
<li><code><a title="exodus3.exodus.put_elem_blk_info" href="#exodus3.exodus.put_elem_blk_info">put_elem_blk_info</a></code></li>
<li><code><a title="exodus3.exodus.put_elem_blk_name" href="#exodus3.exodus.put_elem_blk_name">put_elem_blk_name</a></code></li>
<li><code><a title="exodus3.exodus.put_elem_blk_names" href="#exodus3.exodus.put_elem_blk_names">put_elem_blk_names</a></code></li>
<li><code><a title="exodus3.exodus.put_elem_connectivity" href="#exodus3.exodus.put_elem_connectivity">put_elem_connectivity</a></code></li>
<li><code><a title="exodus3.exodus.put_elem_face_conn" href="#exodus3.exodus.put_elem_face_conn">put_elem_face_conn</a></code></li>
<li><code><a title="exodus3.exodus.put_elem_id_map" href="#exodus3.exodus.put_elem_id_map">put_elem_id_map</a></code></li>
<li><code><a title="exodus3.exodus.put_element_attribute_names" href="#exodus3.exodus.put_element_attribute_names">put_element_attribute_names</a></code></li>
<li><code><a title="exodus3.exodus.put_element_property_value" href="#exodus3.exodus.put_element_property_value">put_element_property_value</a></code></li>
<li><code><a title="exodus3.exodus.put_element_variable_name" href="#exodus3.exodus.put_element_variable_name">put_element_variable_name</a></code></li>
<li><code><a title="exodus3.exodus.put_element_variable_values" href="#exodus3.exodus.put_element_variable_values">put_element_variable_values</a></code></li>
<li><code><a title="exodus3.exodus.put_face_count_per_polyhedra" href="#exodus3.exodus.put_face_count_per_polyhedra">put_face_count_per_polyhedra</a></code></li>
<li><code><a title="exodus3.exodus.put_face_node_conn" href="#exodus3.exodus.put_face_node_conn">put_face_node_conn</a></code></li>
<li><code><a title="exodus3.exodus.put_global_variable_name" href="#exodus3.exodus.put_global_variable_name">put_global_variable_name</a></code></li>
<li><code><a title="exodus3.exodus.put_global_variable_value" href="#exodus3.exodus.put_global_variable_value">put_global_variable_value</a></code></li>
<li><code><a title="exodus3.exodus.put_id_map" href="#exodus3.exodus.put_id_map">put_id_map</a></code></li>
<li><code><a title="exodus3.exodus.put_info" href="#exodus3.exodus.put_info">put_info</a></code></li>
<li><code><a title="exodus3.exodus.put_info_ext" href="#exodus3.exodus.put_info_ext">put_info_ext</a></code></li>
<li><code><a title="exodus3.exodus.put_info_records" href="#exodus3.exodus.put_info_records">put_info_records</a></code></li>
<li><code><a title="exodus3.exodus.put_name" href="#exodus3.exodus.put_name">put_name</a></code></li>
<li><code><a title="exodus3.exodus.put_names" href="#exodus3.exodus.put_names">put_names</a></code></li>
<li><code><a title="exodus3.exodus.put_node_count_per_face" href="#exodus3.exodus.put_node_count_per_face">put_node_count_per_face</a></code></li>
<li><code><a title="exodus3.exodus.put_node_id_map" href="#exodus3.exodus.put_node_id_map">put_node_id_map</a></code></li>
<li><code><a title="exodus3.exodus.put_node_set" href="#exodus3.exodus.put_node_set">put_node_set</a></code></li>
<li><code><a title="exodus3.exodus.put_node_set_dist_fact" href="#exodus3.exodus.put_node_set_dist_fact">put_node_set_dist_fact</a></code></li>
<li><code><a title="exodus3.exodus.put_node_set_name" href="#exodus3.exodus.put_node_set_name">put_node_set_name</a></code></li>
<li><code><a title="exodus3.exodus.put_node_set_names" href="#exodus3.exodus.put_node_set_names">put_node_set_names</a></code></li>
<li><code><a title="exodus3.exodus.put_node_set_params" href="#exodus3.exodus.put_node_set_params">put_node_set_params</a></code></li>
<li><code><a title="exodus3.exodus.put_node_set_property_value" href="#exodus3.exodus.put_node_set_property_value">put_node_set_property_value</a></code></li>
<li><code><a title="exodus3.exodus.put_node_set_variable_name" href="#exodus3.exodus.put_node_set_variable_name">put_node_set_variable_name</a></code></li>
<li><code><a title="exodus3.exodus.put_node_set_variable_values" href="#exodus3.exodus.put_node_set_variable_values">put_node_set_variable_values</a></code></li>
<li><code><a title="exodus3.exodus.put_node_variable_name" href="#exodus3.exodus.put_node_variable_name">put_node_variable_name</a></code></li>
<li><code><a title="exodus3.exodus.put_node_variable_values" href="#exodus3.exodus.put_node_variable_values">put_node_variable_values</a></code></li>
<li><code><a title="exodus3.exodus.put_polyhedra_elem_blk" href="#exodus3.exodus.put_polyhedra_elem_blk">put_polyhedra_elem_blk</a></code></li>
<li><code><a title="exodus3.exodus.put_polyhedra_face_blk" href="#exodus3.exodus.put_polyhedra_face_blk">put_polyhedra_face_blk</a></code></li>
<li><code><a title="exodus3.exodus.put_qa_records" href="#exodus3.exodus.put_qa_records">put_qa_records</a></code></li>
<li><code><a title="exodus3.exodus.put_reduction_variable_name" href="#exodus3.exodus.put_reduction_variable_name">put_reduction_variable_name</a></code></li>
<li><code><a title="exodus3.exodus.put_reduction_variable_values" href="#exodus3.exodus.put_reduction_variable_values">put_reduction_variable_values</a></code></li>
<li><code><a title="exodus3.exodus.put_set_params" href="#exodus3.exodus.put_set_params">put_set_params</a></code></li>
<li><code><a title="exodus3.exodus.put_side_set" href="#exodus3.exodus.put_side_set">put_side_set</a></code></li>
<li><code><a title="exodus3.exodus.put_side_set_dist_fact" href="#exodus3.exodus.put_side_set_dist_fact">put_side_set_dist_fact</a></code></li>
<li><code><a title="exodus3.exodus.put_side_set_name" href="#exodus3.exodus.put_side_set_name">put_side_set_name</a></code></li>
<li><code><a title="exodus3.exodus.put_side_set_names" href="#exodus3.exodus.put_side_set_names">put_side_set_names</a></code></li>
<li><code><a title="exodus3.exodus.put_side_set_params" href="#exodus3.exodus.put_side_set_params">put_side_set_params</a></code></li>
<li><code><a title="exodus3.exodus.put_side_set_property_value" href="#exodus3.exodus.put_side_set_property_value">put_side_set_property_value</a></code></li>
<li><code><a title="exodus3.exodus.put_side_set_variable_name" href="#exodus3.exodus.put_side_set_variable_name">put_side_set_variable_name</a></code></li>
<li><code><a title="exodus3.exodus.put_side_set_variable_values" href="#exodus3.exodus.put_side_set_variable_values">put_side_set_variable_values</a></code></li>
<li><code><a title="exodus3.exodus.put_time" href="#exodus3.exodus.put_time">put_time</a></code></li>
<li><code><a title="exodus3.exodus.put_variable_name" href="#exodus3.exodus.put_variable_name">put_variable_name</a></code></li>
<li><code><a title="exodus3.exodus.put_variable_values" href="#exodus3.exodus.put_variable_values">put_variable_values</a></code></li>
<li><code><a title="exodus3.exodus.set_element_variable_number" href="#exodus3.exodus.set_element_variable_number">set_element_variable_number</a></code></li>
<li><code><a title="exodus3.exodus.set_element_variable_truth_table" href="#exodus3.exodus.set_element_variable_truth_table">set_element_variable_truth_table</a></code></li>
<li><code><a title="exodus3.exodus.set_global_variable_number" href="#exodus3.exodus.set_global_variable_number">set_global_variable_number</a></code></li>
<li><code><a title="exodus3.exodus.set_node_set_variable_number" href="#exodus3.exodus.set_node_set_variable_number">set_node_set_variable_number</a></code></li>
<li><code><a title="exodus3.exodus.set_node_set_variable_truth_table" href="#exodus3.exodus.set_node_set_variable_truth_table">set_node_set_variable_truth_table</a></code></li>
<li><code><a title="exodus3.exodus.set_node_variable_number" href="#exodus3.exodus.set_node_variable_number">set_node_variable_number</a></code></li>
<li><code><a title="exodus3.exodus.set_reduction_variable_number" href="#exodus3.exodus.set_reduction_variable_number">set_reduction_variable_number</a></code></li>
<li><code><a title="exodus3.exodus.set_side_set_variable_number" href="#exodus3.exodus.set_side_set_variable_number">set_side_set_variable_number</a></code></li>
<li><code><a title="exodus3.exodus.set_side_set_variable_truth_table" href="#exodus3.exodus.set_side_set_variable_truth_table">set_side_set_variable_truth_table</a></code></li>
<li><code><a title="exodus3.exodus.set_variable_number" href="#exodus3.exodus.set_variable_number">set_variable_number</a></code></li>
<li><code><a title="exodus3.exodus.set_variable_truth_table" href="#exodus3.exodus.set_variable_truth_table">set_variable_truth_table</a></code></li>
<li><code><a title="exodus3.exodus.summarize" href="#exodus3.exodus.summarize">summarize</a></code></li>
<li><code><a title="exodus3.exodus.title" href="#exodus3.exodus.title">title</a></code></li>
<li><code><a title="exodus3.exodus.version_num" href="#exodus3.exodus.version_num">version_num</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>