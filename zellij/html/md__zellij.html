<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Zellij: Zellij</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="CustomDoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Zellij
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Zellij</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md1">Execution</a></li>
<li class="level1"><a href="#autotoc_md2">Lattice Description File Format</a><ul><li class="level2"><a href="#autotoc_md3">Unit Cell Dictionary</a></li>
<li class="level2"><a href="#autotoc_md4">Lattice Definition</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md5">Unit Cell Template Mesh Requirements</a></li>
<li class="level1"><a href="#autotoc_md6">Sideset Handling</a></li>
<li class="level1"><a href="#autotoc_md7">Parallel Execution</a><ul><li class="level2"><a href="#autotoc_md8">Partial Parallel Output Mode</a></li>
<li class="level2"><a href="#autotoc_md9">Parallel Capable Parallel Execution</a></li>
<li class="level2"><a href="#autotoc_md10">Maximum Open File Complications</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md11">Execution Complexity</a><ul><li class="level2"><a href="#autotoc_md12">Memory Complexity</a></li>
<li class="level2"><a href="#autotoc_md13">Execution Time Complexity</a></li>
<li class="level2"><a href="#autotoc_md14">Efficiency at the NetCDF level</a><ul><li class="level3"><a href="#autotoc_md15">Format</a></li>
<li class="level3"><a href="#autotoc_md16">Integer Size</a></li>
<li class="level3"><a href="#autotoc_md17">Compression</a></li>
<li class="level3"><a href="#autotoc_md18">Recommendations</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p><a class="anchor" id="autotoc_md0"></a> Zellij is a "mesh concatenation" application for generating a mesh consisting of a "lattice" containing one or more "unit cell" template meshes. The lattice is a two-dimensional arrangement of the unit cell template meshes.</p>
<p>The unit cell template meshes are placed by zellij into the specified locations in the lattice and the nodes on the boundaries of the unit cell meshes are united or coincident. Each unit cell mesh must have the same exterior boundary meshes and coordinate extents on the X and Y coordinate faces, but the Z faces are only required to have the same coordinate extent; the Z face meshes are not required to be the same among the different unit cells.</p>
<p>The lattice can be represented as a IxJ regular grid with each "cell" in the grid or lattice containing one of the unit cell template meshes.</p>
<h1><a class="anchor" id="autotoc_md1"></a>
Execution</h1>
<p>Executing zellij with the <code>-help</code> option will result in output similar to the following:</p>
<div class="fragment"><div class="line">Zellij</div>
<div class="line">        (A code for tiling 1 or more template databases into a single output database.)</div>
<div class="line">        (Version: 1.4.1) Modified: 2021/03/16</div>
<div class="line">        Parallel Capability Not Enabled.</div>
<div class="line"> </div>
<div class="line">usage: zellij [options] -lattice &lt;lattice_definition_file&gt;</div>
<div class="line">        -lattice &lt;$val&gt; (Name of file to read lattice definition from. [required])</div>
<div class="line">        -output &lt;$val&gt; (Name of output file to create. Default is `zellij-out.e`)</div>
<div class="line"> </div>
<div class="line">        -rcb (Use recursive coordinate bisection method to decompose the input mesh in a parallel run.)</div>
<div class="line">        -rib (Use recursive inertial bisection method to decompose the input mesh in a parallel run.)</div>
<div class="line">        -hsfc (Use hilbert space-filling curve method to decompose the input mesh in a parallel run. [default])</div>
<div class="line">        -linear (Use the linear method to decompose the input mesh in a parallel run.</div>
<div class="line">                Elements in order first n/p to proc 0, next to proc 1.)</div>
<div class="line">        -cyclic (Use the cyclic method to decompose the input mesh in a parallel run.</div>
<div class="line">                Elements handed out to id % proc_count)</div>
<div class="line">        -random (Use the random method to decompose the input mesh in a parallel run.</div>
<div class="line">                Elements assigned randomly to processors in a way that preserves balance</div>
<div class="line">                (do _not_ use for a real run))</div>
<div class="line"> </div>
<div class="line">        -ranks &lt;$val&gt; (Number of ranks to decompose mesh across)</div>
<div class="line">        -start_rank &lt;$val&gt; (In partial output mode, start outputting decomposed files at this rank)</div>
<div class="line">        -rank_count &lt;$val&gt; (In partial output or subcycle modes, output this number of ranks)</div>
<div class="line">        -subcycle (Process cells in groups of &#39;-rank_count&#39;.  Helps minimize open files,</div>
<div class="line">                but is faster than only having a single file open.)</div>
<div class="line">        -scale &lt;$val&gt; (Scale the output mesh coordinates by the specified value)</div>
<div class="line">        -minimize_open_files [$val] (Close files after accessing them to avoid issues with too many open files.</div>
<div class="line">                If argument is &#39;output&#39; then close output, if &#39;unit&#39; then close unit cells;</div>
<div class="line">                if &#39;all&#39; or no argument close all.</div>
<div class="line">                Should not need to use this option unless you get an error message indicating this issue.)</div>
<div class="line"> </div>
<div class="line">        -ignore_sidesets (Do not copy any sidesets in the unit cells to the output file.)</div>
<div class="line">        -generate_sidesets &lt;$val&gt; (Which surfaces on the output mesh should have sidesets generated,</div>
<div class="line">                 Valid options are:</div>
<div class="line">                 &#39;x&#39; or &#39;i&#39; for surface on minimum X coordinate, default name = `min_i`</div>
<div class="line">                 &#39;y&#39; or &#39;j&#39; for surface on minimum Y coordinate, default name = `min_j`</div>
<div class="line">                 &#39;z&#39; or &#39;k&#39; for surface on minimum Z coordinate, default name = `min_k`</div>
<div class="line">                 &#39;X&#39; or &#39;I&#39; for surface on maximum X coordinate, default name = `max_i`</div>
<div class="line">                 &#39;Y&#39; or &#39;J&#39; for surface on maximum Y coordinate, default name = `max_j`</div>
<div class="line">                 &#39;Z&#39; or &#39;K&#39; for surface on maximum Z coordinate, default name = `max_k`</div>
<div class="line">                 For example `xyXY` would generate sidesets on min/max X and Y surfaces.)</div>
<div class="line">        -sideset_names &lt;$val&gt; (Specify names for one or more of the generated sidesets.</div>
<div class="line">                 Form is `axis:name,axis:name,...`</div>
<div class="line">                 where &#39;axis&#39; is one of &#39;ijkIJKxyzXYZ&#39;, and &#39;name&#39; is the name of the sideset.</div>
<div class="line">                 The default names are &#39;min_i&#39;, &#39;max_i&#39;, &#39;min_j&#39;, &#39;max_j&#39;, &#39;min_k&#39;, &#39;max_k&#39;.</div>
<div class="line">                 For example `x:left,X:right` would name the sideset on the min x face &#39;left&#39; and the max X face &#39;right&#39;.)</div>
<div class="line"> </div>
<div class="line">        -netcdf3 (Output database will be a netcdf3 native classical netcdf file format (32-bit only))</div>
<div class="line">        -netcdf4 (Output database will be a netcdf4 hdf5-based file instead of the classical netcdf file format (default))</div>
<div class="line">        -netcdf5 (Output database will be a netcdf5 (CDF5) file instead of the classical netcdf file format)</div>
<div class="line"> </div>
<div class="line">        -32-bit (True if forcing the use of 32-bit integers for the output file)</div>
<div class="line">        -64-bit (True if forcing the use of 64-bit integers for the output file (default))</div>
<div class="line"> </div>
<div class="line">        -zlib (Use the Zlib / libz compression method if compression is enabled (default) [exodus only].)</div>
<div class="line">        -szip (Use SZip compression. [exodus only, enables netcdf-4])</div>
<div class="line">        -compress &lt;$val&gt; (Specify the hdf5 zlib compression level [0..9] or szip [even, 4..32] to be used on the output file.)</div>
<div class="line"> </div>
<div class="line">        -separate_cells (Do not equivalence the nodes between adjacent unit cells.)</div>
<div class="line">        -repeat &lt;$val&gt; (Each lattice entry will be used the specified number of times as will</div>
<div class="line">                each row in the lattice (for debugging). `-repeat 2` would double the lattice.)</div>
<div class="line">        -skip &lt;$val&gt; (Skip the specified number of lattice entries and rows. For example, -skip 1</div>
<div class="line">                would read every other entry on the row and every other row. (for debugging))</div>
<div class="line">        -help (Print this summary and exit)</div>
<div class="line">        -version (Print version and exit)</div>
<div class="line">        -debug &lt;$val&gt; (debug level (values are or&#39;d)</div>
<div class="line">                   1 = Time stamp information.</div>
<div class="line">                   2 = Memory information.</div>
<div class="line">                   4 = Verbose Unit Cell information.</div>
<div class="line">                   8 = Verbose output of Grid finalization calculations.</div>
<div class="line">                  16 = Put exodus library into verbose mode.</div>
<div class="line">                  32 = Verbose decomposition information.</div>
<div class="line">                  64 = Verbose output database summary information.</div>
<div class="line">                 128 = Verbose sideset generation information.)</div>
<div class="line">        -copyright (Show copyright and license data.)</div>
<div class="line"> </div>
<div class="line">        Can also set options via ZELLIJ_OPTIONS environment variable.</div>
<div class="line"> </div>
<div class="line">        -&gt;-&gt;-&gt; Send email to gdsjaar@sandia.gov for zellij support.&lt;-&lt;-&lt;-</div>
</div><!-- fragment --><p> The only required option is <code>-lattice</code> followed by the name of the file containing the lattice description. The other options are used to specify compression of the output file; the format of the output file; or to request additional debug output.</p>
<p>If the <code>-output &lt;filename&gt;</code> option is not specified, then the output mesh will be named <code>zellij-out.e</code>.</p>
<h1><a class="anchor" id="autotoc_md2"></a>
Lattice Description File Format</h1>
<p>The format of the lattice description file is fairly simple, but is also very rigid. There are two sections of the file &ndash; the <em>unit cell</em> dictionary and the <em>lattice</em> definition.</p>
<h2><a class="anchor" id="autotoc_md3"></a>
Unit Cell Dictionary</h2>
<p>The unit cell dictionary defines the unit cell template meshes that will be placed in the lattice. The dictionary begins with a line containing <code>BEGIN_DICTIONARY</code> followed by one or more lines defining the unit cells and is then ended with a line containing <code>END_DICTIONARY</code></p>
<p>The syntax of the lines defining the unit cells consists of two fields &ndash; an arbitrary <em>key</em> and the filename containing the Exodus file defining the mesh for this unit cell. The only restriction on the <em>key</em> is that it must be unique in the dictionary. The filenames must specify the path (either absolute or relative to the current execution directory) to the Exodus file; it can optionally be delimited by double quotes. The filenames do not need to be unique, but it is more efficient in both memory and time if each unit cell template mesh is unique.</p>
<p>As an example, here is a valid dictionary definition:</p>
<div class="fragment"><div class="line">BEGIN_DICTIONARY</div>
<div class="line">  0001 &quot;../zellij-example/xatom-1b.e&quot;</div>
<div class="line">  0002 &quot;../zellij-example/xatom-Y.e&quot;</div>
<div class="line">  0003 &quot;../zellij-example/xatom-X.e&quot;</div>
<div class="line">  0004 &quot;../zellij-example/xatom-2b.e&quot;</div>
<div class="line">END_DICTIONARY</div>
</div><!-- fragment --><p> The unit cell dictionary must appear before the lattice definition in the lattice description file.</p>
<p>If an error is detected during the parsing of the unit cell dictionary, the code will output an error message and terminate. Errors can be incorrect syntax, missing unit cell template meshes, duplicate keys, or problems reading the mesh description from a unit cell template mesh. The unit cell template mesh file is accessed and partially read at the time that zellij parses the corresponding unit cell dictionary line.</p>
<h2><a class="anchor" id="autotoc_md4"></a>
Lattice Definition</h2>
<p>The lattice definition specifies the size of the lattice and the distribution of the unit cell(s) within that lattice. The lattice definition must follow the unit cell dictionary in the lattice description file.</p>
<p>The first line of the lattice definition begins with the line <code>BEGIN_LATTICE {i} {j} 1</code> where <code>{i}</code> and <code>{j}</code> specify the size of the <code>IxJ</code> arrangement of unit cells. For example, the line <code>BEGIN_LATTICE 5 5 1</code> would define a lattice containing 25 unit cell instances arranged in a 5 by 5 regular grid.</p>
<p>The last line of the lattice definition is the line <code>END_LATTICE</code>. When that line is encountered, zellij will begin outputting the mesh.</p>
<p>Between the <code>BEGIN_LATTICE</code> and <code>END_LATTICE</code> are <code>{j}</code> lines with <code>{i}</code> entries per line. The entries are any of the _key_s that were specified in the unit cell dictionary.</p>
<p>As an example, here is a valid lattice definition using the keys of the example dictionary from the previous section:</p>
<div class="fragment"><div class="line">BEGIN_LATTICE 5  5  1</div>
<div class="line">  0001 0002 0003 0002 0001</div>
<div class="line">  0002 0003 0003 0003 0002</div>
<div class="line">  0003 0003 0004 0003 0003</div>
<div class="line">  0002 0003 0003 0003 0002</div>
<div class="line">  0001 0002 0003 0002 0001</div>
<div class="line">END_LATTICE</div>
</div><!-- fragment --><p>Although the lattice is typically symmetric and square, this is not a requirement and is not checked.</p>
<p>If an error is detected during the parsing of the <em>lattice</em>, the code will output an error message and terminate. Errors can include invalid keys, incorrect number of lattice definition lines, or incorrect number of keys on a definition line.</p>
<p>Note that zellij does not require that the unit cell keys be numeric; the following example shows a different method for specifying the same lattice definition file as the previous example:</p>
<div class="fragment"><div class="line">BEGIN_DICTIONARY</div>
<div class="line">  - &quot;../zellij-example/xatom-1b.e&quot;</div>
<div class="line">  | &quot;../zellij-example/xatom-Y.e&quot;</div>
<div class="line">  + &quot;../zellij-example/xatom-X.e&quot;</div>
<div class="line">  * &quot;../zellij-example/xatom-2b.e&quot;</div>
<div class="line">END_DICTIONARY</div>
<div class="line"> </div>
<div class="line">BEGIN_LATTICE 5  5  1</div>
<div class="line">  - | + | -</div>
<div class="line">  | + + + |</div>
<div class="line">  + + * + +</div>
<div class="line">  | + + + |</div>
<div class="line">  - | + | -</div>
<div class="line">END_LATTICE</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md5"></a>
Unit Cell Template Mesh Requirements</h1>
<p>Zellij requires that the boundary mesh (<code>X</code> and <code>Y</code> faces) of each of the unit cell templates be a <em>regular</em> "structured" mesh. Basically this means that the faces of the mesh elements on the boundary are in a regular rectangular grid such that each mesh face is rectangular (90 degree corners) and that the boundary mesh on the minimum <code>X</code> face is the same as that on the maximum <code>X</code> face and similarly for the minimum <code>Y</code> face and the maximum <code>Y</code> face.</p>
<p>Additionally, the X faces on <em>all</em> unit cells must match and the Y faces on <em>all</em> unit cells must match both in structure and in coordinate extent. This requirement is verified during execution. The <code>Z</code> faces are less constrained with the only requirement being that the coordinate extents of all <code>Z</code> faces must be the same (which follows from the <code>X</code> and <code>Y</code> face requirement); the structure of the mesh on the <code>Z</code> faces is arbitrary.</p>
<p>The unit cell meshes can contain any number of element blocks; however, each element block <em>must</em> contain hexahedral elements with 8-nodes per element. The element blocks do not need to be the same in each unit cell mesh, but if they do share the same element block <code>id</code>, then those elements will be combined into the same element block in the output mesh with the same <code>id</code>.</p>
<p>The output mesh will contain the union of all element blocks existing on the input mesh unit cells. For example, if:</p>
<ul>
<li>unit cell <code>0001</code> has element blocks <code>1 10 100</code></li>
<li>unit cell <code>0002</code> has element blocks <code>2 20 200</code></li>
<li>unit cell <code>0003</code> has element blocks <code>1 2 10 20</code></li>
<li>unit cell <code>0004</code> has element blocks <code>10 20 100 200</code></li>
</ul>
<p>The output mesh will have element blocks <code>1 2 10 20 100 200</code></p>
<h1><a class="anchor" id="autotoc_md6"></a>
Sideset Handling</h1>
<p>By default, zellij will replicate any sidesets that are defined on the input unit cell meshes to the output mesh file. The sidesets will have the same names and ids as the sidesets on the input unit cell meshes. If you do not want the sidesets replicated, you can add the command line option <code>-ignore_sidesets</code> and any sidesets on the input unit cell meshes will be ignored.</p>
<p>Zellij can also generate new sidesets on the boundaries of the output mesh via the command line option <code>-generate_sidesets &lt;axes&gt;</code> where <code>axes</code> is one or more letters specifying the face of the output mesh on which to generate a sideset. Valid letters are <code>xyzXYZ</code> or <code>ijkIJK</code> which correspond to:</p>
<ul>
<li><code>x</code> or <code>i</code> for surface on minimum X coordinate (default name = <code>min_i</code>)</li>
<li><code>y</code> or <code>j</code> for surface on minimum Y coordinate (default name = <code>min_j</code>)</li>
<li><code>z</code> or <code>k</code> for surface on minimum Z coordinate (default name = <code>min_k</code>)</li>
<li><code>X</code> or <code>I</code> for surface on maximum X coordinate (default name = <code>max_i</code>)</li>
<li><code>Y</code> or <code>J</code> for surface on maximum Y coordinate (default name = <code>max_j</code>)</li>
<li><code>Z</code> or <code>K</code> for surface on maximum Z coordinate (default name = <code>max_k</code>)</li>
</ul>
<p>For example <code>-generate_sidesets xyXY</code> would generate sideset on the surfaces corresponding to the minimum and maximum X and Y coordinates on the output mesh.</p>
<p>By default, the generated sidesets will be named as shown in the list above. The names can be changed with the <code>-sideset_names &lt;arg&gt;</code> command line option. The syntax of <code>&lt;arg&gt;</code> is <code>axis:name,axis:name,...</code> where <code>axis</code> is one of <code>ijkIJK</code> or <code>xyzXYZ</code> and <code>name</code> is the name of the specified sideset. For example, <code>-sideset_names x:left,X:right</code> would name the sidesets on the minimum x and maximum X faces <code>left</code> and <code>right</code> respectively. There will be an error if two or more sidesets have the same name.</p>
<h1><a class="anchor" id="autotoc_md7"></a>
Parallel Execution</h1>
<p>Zellij can produce a mesh decomposed into a file-per-rank for use in a parallel analysis application. Note that Zellij itself is run serially. The main option that tells Zellij to produce the decomposed files is <code>-ranks &lt;number_of_ranks&gt;</code>. If this is specified, then Zellij will create <code>number_of_ranks</code> individual files each containing a portion of the complete model. The files will have the information needed by a parallel application to read the data and set up the correct communication paths and identify the nodes that are shared across processor boundaries.</p>
<p>The decomposition method can also be specified. This determines the algorithm that is used to break the lattice into <code>number_of_ranks</code> pieces each with approximately the same computational complexity. The decomposition methods are:</p>
<ul>
<li><code>-rcb</code> Use recursive coordinate bisection method to decompose the input mesh in a parallel run.</li>
<li><code>-rib</code> Use recursive inertial bisection method to decompose the input mesh in a parallel run.</li>
<li><code>-hsfc</code> Use hilbert space-filling curve method to decompose the input mesh in a parallel run.</li>
<li><code>-linear</code> Use the linear method to decompose the input mesh in a parallel run. Elements in order first <code>n/p</code> to proc 0, next to proc 1.</li>
<li><code>-cyclic</code> Use the cyclic method to decompose the input mesh in a parallel run. Elements handed out to <code>id % proc_count</code>.</li>
<li><code>-random</code> Use the random method to decompose the input mesh in a parallel run. Elements are assigned randomly to processors in a way that preserves balance (do <em>not</em> use for a real run))</li>
</ul>
<p>The <code>-hsfc</code> method is the default if no other decomposition method is specified. Note that the decomposition occurs at the <em>grid</em> level so the elements of each grid cell will not be split across multiple ranks. The grid cells are weighted by the number of elements in the cell which should produce a balanced decomposition if there are unit cells of varying element counts.</p>
<p>The <code>-linear</code>, <code>-cyclic</code>, and <code>-random</code> methods are typically used for debugging and testing Zellij and should not be used in a production run, especially the <code>-random</code> method.</p>
<h2><a class="anchor" id="autotoc_md8"></a>
Partial Parallel Output Mode</h2>
<p>There is a <em>partial parallel output</em> mode in which you can tell Zellij to only output a portion of the parallel decomposed files. This is selected with the <code>-start_rank &lt;rank&gt;</code> and <code>-rank_count &lt;count&gt;</code> options. In this case, Zellij will only output the ranks from <code>rank</code> up to <code>rank+count-1</code>. For example, if you run <code>zellij -ranks 10 -start_rank 5 -rank_count 3</code>, then zellij would output files for ranks 5, 6, and 7. This is somewhat inefficient since zellij will do many of the calculations for all ranks and only output the specified ranks; however, it does allow you to run multiple copies of zellij simultaneously. For example, you could run:</p>
<div class="fragment"><div class="line">zellij -ranks 16 --start_rank  0 --rank_count 4</div>
<div class="line">zellij -ranks 16 --start_rank  4 --rank_count 4</div>
<div class="line">zellij -ranks 16 --start_rank  8 --rank_count 4</div>
<div class="line">zellij -ranks 16 --start_rank 12 --rank_count 4</div>
</div><!-- fragment --><p>simultaneously and all 16 files should be output faster than running a single execution that wrote all of the files.</p>
<h2><a class="anchor" id="autotoc_md9"></a>
Parallel Capable Parallel Execution</h2>
<p>If Zellij is compiled with parallel capability enabled (This is shown at the beginning of the <code>-help</code> output or the version information output when zellij begins executing as <code>Parallel Capability Enabled</code>), then you can run Zellij in parallel using the normal <code>mpiexec -np &lt;#&gt; zellij &lt;normal zellij options&gt;</code> command. In this case, there will be <code>#</code> copies of zellij running simultaneously and each copy will divide up the output files and work among each process/copy.</p>
<p>For example, if you run <code>mpiexec -np 8 zellij -ranks 1024 -latice lattice.txt</code>, then there will be 8 copies of zellij running and each will output <code>1024/8 = 128</code> output files.</p>
<h2><a class="anchor" id="autotoc_md10"></a>
Maximum Open File Complications</h2>
<p>Most compute systems have a limit on the number of files that a program can have open simultaneously. For many systems, this limit is 1024. The files that zellij deals with are (1) the unit cell meshes and (2) the per-rank output files, and (3) the standard input, output, and error files. Because of this, it is somewhat easy for a zellij execution to exceed the open file limit. Zellij attempts to handle this automatically using logic similar to:</p>
<ul>
<li>If the unit cell count exceeds the open file limit, then close each unit cell after each access before opening the next unit cell mesh.</li>
<li>If the number of <code>-ranks</code> that zellij is creating exceeds the open file count, then determine how many output files can be open at one time (max_open = open file limit - 3 - number of unit cells open simultaneously) and run zellij in a <code>subcycle</code> mode where it is only writing to <code>max_open</code> files at one time.</li>
<li>If the <code>max_open</code> calculated in the above bullet is too small, then set the mode to only open a single unit cell mesh at a time and redo the calculation.</li>
<li>If all else fails, run with only a single unit cell file open and only a single output mesh rank file open.</li>
</ul>
<p>If the above logic fails and Zellij is unable to run without exceeding the open file count, you can specify the behavior manually using a combination of the <code>-minimize_open_files=&lt;UNIT|OUTPUT|ALL&gt;</code> option and the <code>-subcycle</code> and <code>-rank_count &lt;#&gt;</code> options.</p>
<p>The options to <code>-minimize_open_files</code> are:</p>
<ul>
<li><code>UNIT</code> - only have a single unit cell mesh open at one time; close before accessing another unit cell mesh.</li>
<li><code>OUTPUT</code> - only have a single output rank mesh file open at one time.</li>
<li><code>ALL</code> - both of the above options.</li>
</ul>
<p>The <code>-subcycle</code> and <code>-rank_count &lt;#&gt;</code> options cause zellij to output <code>#</code> output files at a time and then cycle to the next <code>#</code> output files until all files have been output. For example, <code>zellij -ranks 1024 -subcycle -rank_count 256</code> would do the following:</p>
<ul>
<li>First cycle would output ranks 0 to 255,</li>
<li>Second cycle would output ranks 256 to 511,</li>
<li>Third cycle would output ranks 512 to 767,</li>
<li>Fourth cycle would output ranks 768 to 1023.</li>
</ul>
<p>In this mode, there will the <code>#</code> output files open simultaneously (unless <code>-minimize_open_files=OUTPUT|ALL</code> was specified also). So the total number of open files will be <code>unit cell count + 3 + #</code> or <code>1 + 3 + #</code> if <code>-minimize_open_files=UNIT</code> was specified.</p>
<h1><a class="anchor" id="autotoc_md11"></a>
Execution Complexity</h1>
<p>Zellij is intended to produce extremely large meshes and is therefore very concerned with both memory efficiency and execution time efficiency.</p>
<h2><a class="anchor" id="autotoc_md12"></a>
Memory Complexity</h2>
<p>Zellij stores the following data:</p>
<ul>
<li>For each unit cell template mesh:<ul>
<li>metadata</li>
<li>64-bit Ids of nodes on each min_I, max_I, min_J, max_J face</li>
</ul>
</li>
<li>For each entry in the lattice definition:<ul>
<li>metadata (approximately 1KiByte)</li>
<li>temporarily it will hold 64-bit Ids of nodes on the max_I and max_J faces. This will be deleted once the upper <code>I</code> and upper <code>J</code> "neighbor" entry has been processed (see below)</li>
</ul>
</li>
<li>For the lattice:<ul>
<li>vector containing the lattice definition.</li>
</ul>
</li>
</ul>
<p>The main memory use once the output file is being processed is the temporary storage containing the nodes on the <code>max_I</code> and <code>max_J</code> faces. The lattice is processed cell by cell. For an <code>II by JJ</code> sized grid, the cells are processed in the order <code>(1,1), (2,1), ... , (II, 1), (1,2), (2,2), ..., (II, JJ)</code>. The temporary storage on the <code>max_I</code> face is only needed until the next cell is processed. That is, for cell <code>(i,j)</code>, its <code>max_I</code> nodes will be used during the processing of cell <code>(i+1, j)</code> and then deleted.</p>
<p>The temporary storage on the <code>max_J</code> face is retained for a longer time. For cell <code>(i,j)</code>, the <code>max_J</code> storage is needed for cell <code>(i, j+1)</code> and then deleted.</p>
<p>For a grid of size <code>(II, JJ)</code>, there will at most be:</p>
<ul>
<li>1 temporary vector of size <code>max_I</code> nodes</li>
<li><code>II</code> temporary vectors of size <code>max_J</code> nodes.</li>
</ul>
<p>If you have a lattice that is rectangular (<code>II != JJ</code>), then it is more efficient for memory usage to make the <code>I</code> direction the smallest value if possible.</p>
<p>In addition to the above memory usage, zellij must also transfer the mesh coordinate data and element block connectivity data for each lattice entry to the output file. Zellij outputs the model using the following pseudo-code:</p>
<div class="fragment"><div class="line">for each j : J</div>
<div class="line">  for each i : I</div>
<div class="line">     read cell(i,j)  x, y, and z local coordinates</div>
<div class="line">     map coordinates to offset in output mesh</div>
<div class="line">     eliminate nodes that join to an already output neighbor cell</div>
<div class="line">     write cell(i,j) x, y, and z global coordinates</div>
<div class="line"> </div>
<div class="line">for each j : J</div>
<div class="line">   for each i : I</div>
<div class="line">      for each element block in cell(i,j) mesh</div>
<div class="line">         read block connectivity</div>
<div class="line">         map local node ids to global node ids</div>
<div class="line">         write block connectivity</div>
</div><!-- fragment --><p>The maximum memory use will be the size of storage needed for the <code>x</code> <code>y</code> and <code>z</code> coordinates of a unit cell mesh or the storage needed to hold the connectivity for a single unit cell element block.</p>
<p>Note that the memory requirements are proportional to the size of an individual unit cell mesh and not a function of the size of the output mesh. It is possible to create meshes which are much larger than the amount of memory present on the compute system running zellij.</p>
<p>The memory being used by zellij during execution will be output if the <code>--debug 2</code> argument is specified at execution time.</p>
<h2><a class="anchor" id="autotoc_md13"></a>
Execution Time Complexity</h2>
<p>For a large model, the majority of the execution time is related to:</p>
<ul>
<li>Read/process/write element block connectivity</li>
<li>Read/process/write nodal coordinates</li>
<li>Categorize boundary nodes on each unit cell mesh</li>
</ul>
<h2><a class="anchor" id="autotoc_md14"></a>
Efficiency at the NetCDF level</h2>
<p>The Exodus format which is used for the unit cell template meshes and the output mesh uses the NetCDF library for on-disk storage. There are several variants of the NetCDF on-disk storage including the format: <code>netcdf3</code>, <code>netcdf4</code>, and <code>netcdf5</code> and the integer size (32-bit integers or 64-bit integers). Although these details are usually transparent to the user, they can affect the execution time especially when very large meshes are being processed.</p>
<h3><a class="anchor" id="autotoc_md15"></a>
Format</h3>
<p>The <code>netcdf3</code> format is the original native NetCDF format. At the time the library was being developed, the <code>byte endianness</code> of data stored on disk was not standard among the computes in use at that time and the NetCDF developers had to pick an <code>endianness</code> for the data. They picked the XDR standard which stood for <em>eXternal Data Representation</em> which was used for communicating between different computer systems. Regretfully, the representation used by XDR turned out to be opposite of the representation used by (almost?) all systems in use today, so each read and write of data in the <code>netcdf3</code> format results in a translation of the endianness. This translation is very fast, but is overhead that would not be needed if the on-disk format was the opposite representation. This representation is also used by the <code>netcdf5</code> format.</p>
<p>However, the NetCDF <code>netcdf4</code> format is based on using the HDF5 library to manage the underlying data format on disk and it can read and write data using the native endianness of the system on which the data is being read and written and therefore does not incur the cost of transforming the data's endianness.</p>
<h3><a class="anchor" id="autotoc_md16"></a>
Integer Size</h3>
<p>By default, most current mesh generators will output a mesh using 32-bit integer data. This is sufficient to represent a mesh with up to approximately 2.1 billion nodes and elements.</p>
<p>If the input mesh and the output mesh have the same integer size, then there is no data conversion needed. The data will be read as <code>N</code>-bit integers, processed as <code>N</code>-bit integers, and written as <code>N</code>-bit integers. However, if the input mesh is <code>N</code>-bit integers and the output mesh is <code>M</code>-bit integers, then the NetCDF library will convert all integer data (element block connectivity typically) from <code>N</code> bits to <code>M</code> bits which for large meshes can incur an execution time overhead.</p>
<h3><a class="anchor" id="autotoc_md17"></a>
Compression</h3>
<p>The NetCDF library supports compression of the output file. Typically, the <code>zlib</code> compression algorithm is used, but recently NetCDF begain supporting the <code>szip</code> compression and a few more algorithms are starting to be supported.</p>
<p>The benefit of the compression is that it can result in much smaller output (and input) mesh files; the disadvantage is that the default <code>zlib</code> compression algorithm is not very fast and can increase the execution time of zellij. The <code>szip</code> compression algorithm is faster with typically (but not always) slightly less compression, but it still will incur an overhead in execution time.</p>
<h3><a class="anchor" id="autotoc_md18"></a>
Recommendations</h3>
<p>For minimal overhead, it is recommended that:</p>
<ul>
<li>Use the <code>netcdf4</code> format for all input and output meshes</li>
<li>Use the same integer size for all input and output meshes<ul>
<li>The integer size of the output mesh can be specified using the <code>-32</code> or <code>-64</code> options.</li>
<li>The <code>-64</code> option is the default.</li>
</ul>
</li>
</ul>
<p>It is most efficient if the format and integer size of the input mesh matches the output mesh. The format of the input meshes can be converted using the <code>io_shell</code> application with the <code>-netcdf4</code> and <code>-64</code> or <code>-32</code> options. The format and integer size of a mesh can be queried using the <code>exo_format</code> application.</p>
<p>For illustration, here is the execution time for several runs with different format and integer size. In all cases, the input and output mesh sizes are the same:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">input   </th><th class="markdownTableHeadCenter">output   </th><th class="markdownTableHeadCenter">integer input   </th><th class="markdownTableHeadCenter">integer output   </th><th class="markdownTableHeadCenter">execution time    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">netcdf3   </td><td class="markdownTableBodyCenter">netcdf3   </td><td class="markdownTableBodyCenter">32   </td><td class="markdownTableBodyCenter">32   </td><td class="markdownTableBodyCenter">7.0    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">netcdf3   </td><td class="markdownTableBodyCenter">netcdf4   </td><td class="markdownTableBodyCenter">32   </td><td class="markdownTableBodyCenter">32   </td><td class="markdownTableBodyCenter">2.6    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">netcdf3   </td><td class="markdownTableBodyCenter">netcdf4   </td><td class="markdownTableBodyCenter">32   </td><td class="markdownTableBodyCenter">64   </td><td class="markdownTableBodyCenter">3.8    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">netcdf4   </td><td class="markdownTableBodyCenter">netcdf3   </td><td class="markdownTableBodyCenter">32   </td><td class="markdownTableBodyCenter">32   </td><td class="markdownTableBodyCenter">6.5    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">netcdf4   </td><td class="markdownTableBodyCenter">netcdf3   </td><td class="markdownTableBodyCenter">64   </td><td class="markdownTableBodyCenter">32   </td><td class="markdownTableBodyCenter">7.4    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">netcdf4   </td><td class="markdownTableBodyCenter">netcdf5   </td><td class="markdownTableBodyCenter">64   </td><td class="markdownTableBodyCenter">64   </td><td class="markdownTableBodyCenter">9.4    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">netcdf4   </td><td class="markdownTableBodyCenter">netcdf4   </td><td class="markdownTableBodyCenter">32   </td><td class="markdownTableBodyCenter">32   </td><td class="markdownTableBodyCenter">2.4    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">netcdf4   </td><td class="markdownTableBodyCenter">netcdf4   </td><td class="markdownTableBodyCenter">32   </td><td class="markdownTableBodyCenter">64   </td><td class="markdownTableBodyCenter">3.6    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">netcdf4   </td><td class="markdownTableBodyCenter">netcdf4   </td><td class="markdownTableBodyCenter">64   </td><td class="markdownTableBodyCenter">32   </td><td class="markdownTableBodyCenter">3.2    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">netcdf4   </td><td class="markdownTableBodyCenter">netcdf4   </td><td class="markdownTableBodyCenter">64   </td><td class="markdownTableBodyCenter">64   </td><td class="markdownTableBodyCenter">3.3   </td></tr>
</table>
<p>The fastest option is both input and output using 32-bit integers and the <code>netcdf4</code> format. Almost as fast is the case where the input format is <code>netcdf3</code> and the output <code>netcdf4</code>. The <code>64-bit</code> integer options with both input and output using <code>netcdf4</code> are slightly slower, but this is probably due to the doubling of the size of the integer data being read and written.</p>
<p>The output mesh in this case consisted of 37.3 million elements and 38.5 million nodes in a grid of 46 x 46 unit cells. There were 56 unit cell template meshes. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7
</small></address>
</body>
</html>
