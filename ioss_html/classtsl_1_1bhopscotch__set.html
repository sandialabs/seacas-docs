<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>IOSS: tsl::bhopscotch_set&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="CustomDoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">IOSS<span id="projectnumber">&#160;2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('classtsl_1_1bhopscotch__set.html','','classtsl_1_1bhopscotch__set-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">tsl::bhopscotch_set&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="bhopscotch__set_8h_source.html">bhopscotch_set.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for tsl::bhopscotch_set&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" loading="lazy" frameborder="0" src="classtsl_1_1bhopscotch__set__coll__graph.svg" width="100%" height="516"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:KeySelect" id="r_KeySelect"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__set_1_1KeySelect.html">KeySelect</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-types" class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a42dce508be37a6f7b694f8a18ee5554d" id="r_a42dce508be37a6f7b694f8a18ee5554d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a42dce508be37a6f7b694f8a18ee5554d">key_type</a> = typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#ac2da7bb97307e334553fe9cba15d0689">ht::key_type</a></td></tr>
<tr class="memitem:a5dba07d4206217a586ec8b10674d0788" id="r_a5dba07d4206217a586ec8b10674d0788"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5dba07d4206217a586ec8b10674d0788">value_type</a> = typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#afed3e1f425ac47050c9d8b96c2c5e319">ht::value_type</a></td></tr>
<tr class="memitem:adfe28f55c3c51048b90c94f95e70b254" id="r_adfe28f55c3c51048b90c94f95e70b254"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adfe28f55c3c51048b90c94f95e70b254">size_type</a> = typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#a0f2a8dda76d11a1531be2c2e7fb82061">ht::size_type</a></td></tr>
<tr class="memitem:a8d6578a6c3bdd268f66b657950f8f6e9" id="r_a8d6578a6c3bdd268f66b657950f8f6e9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d6578a6c3bdd268f66b657950f8f6e9">difference_type</a> = typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#a3a8a8e910088e7bdbfe63be530d31956">ht::difference_type</a></td></tr>
<tr class="memitem:a9abb25ad29802ea7f4b5739cf9d57c9f" id="r_a9abb25ad29802ea7f4b5739cf9d57c9f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9abb25ad29802ea7f4b5739cf9d57c9f">hasher</a> = typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#a0ffe6a6aaa0794dcf4979fc23e583462">ht::hasher</a></td></tr>
<tr class="memitem:af8f59d8436d8bd927950a2875f61853b" id="r_af8f59d8436d8bd927950a2875f61853b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af8f59d8436d8bd927950a2875f61853b">key_equal</a> = typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#a69a00efe0c98e7d89d3eeb8ef5e43190">ht::key_equal</a></td></tr>
<tr class="memitem:aac0fb26ecfc1e0bac31698e489d987f0" id="r_aac0fb26ecfc1e0bac31698e489d987f0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aac0fb26ecfc1e0bac31698e489d987f0">key_compare</a> = Compare</td></tr>
<tr class="memitem:a593ea7b428b2a98d45b61ddb7d4412f0" id="r_a593ea7b428b2a98d45b61ddb7d4412f0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a593ea7b428b2a98d45b61ddb7d4412f0">allocator_type</a> = typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#a8af583783f638a3faac62c52b876aa67">ht::allocator_type</a></td></tr>
<tr class="memitem:a1030ac167086de9041220f2f6dd1d3c8" id="r_a1030ac167086de9041220f2f6dd1d3c8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1030ac167086de9041220f2f6dd1d3c8">reference</a> = typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#a257bb0ff019c2756bc2c192e76f31ce5">ht::reference</a></td></tr>
<tr class="memitem:a907e7c159415b1f368c8ed177844d511" id="r_a907e7c159415b1f368c8ed177844d511"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a907e7c159415b1f368c8ed177844d511">const_reference</a> = typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#ae45966f2a709f1d7f03d42cd19fb29ea">ht::const_reference</a></td></tr>
<tr class="memitem:a51909220f65b79bbe625c4cf7349044f" id="r_a51909220f65b79bbe625c4cf7349044f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a51909220f65b79bbe625c4cf7349044f">pointer</a> = typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#a31276a8ba5b00732857fd0267a5b6fdd">ht::pointer</a></td></tr>
<tr class="memitem:ad67a0eb0af2eedf49270953f7455e629" id="r_ad67a0eb0af2eedf49270953f7455e629"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad67a0eb0af2eedf49270953f7455e629">const_pointer</a> = typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#a85e8fb0e24e28aef2c0ec4ce9e3f9d01">ht::const_pointer</a></td></tr>
<tr class="memitem:aabc10d644f92fc6b16707b8da6d250a9" id="r_aabc10d644f92fc6b16707b8da6d250a9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aabc10d644f92fc6b16707b8da6d250a9">iterator</a> = typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#ab697c644e6dec536d6ab028ba085b591">ht::iterator</a></td></tr>
<tr class="memitem:acca0be5d2184d2a03d6bbe3ab2c349e4" id="r_acca0be5d2184d2a03d6bbe3ab2c349e4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acca0be5d2184d2a03d6bbe3ab2c349e4">const_iterator</a> = typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#a2af6f88c2b254b2c9ff83c70eea7c952">ht::const_iterator</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7acfc31d931c6734560ce98eb0ceb020" id="r_a7acfc31d931c6734560ce98eb0ceb020"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7acfc31d931c6734560ce98eb0ceb020">bhopscotch_set</a> ()</td></tr>
<tr class="memitem:a5d4ee2b86bca361d3ecf68a379e9b605" id="r_a5d4ee2b86bca361d3ecf68a379e9b605"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5d4ee2b86bca361d3ecf68a379e9b605">bhopscotch_set</a> (<a class="el" href="#adfe28f55c3c51048b90c94f95e70b254">size_type</a> <a class="el" href="#a48f085051bacbb4f8a713207ce750a2e">bucket_count</a>, const Hash &amp;hash=Hash(), const KeyEqual &amp;equal=KeyEqual(), const Allocator &amp;alloc=Allocator(), const Compare &amp;comp=Compare())</td></tr>
<tr class="memitem:a574c7d0e981cbb9a08f24ab857dc312a" id="r_a574c7d0e981cbb9a08f24ab857dc312a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a574c7d0e981cbb9a08f24ab857dc312a">bhopscotch_set</a> (<a class="el" href="#adfe28f55c3c51048b90c94f95e70b254">size_type</a> <a class="el" href="#a48f085051bacbb4f8a713207ce750a2e">bucket_count</a>, const Allocator &amp;alloc)</td></tr>
<tr class="memitem:af77904a0a6b0162bb6ba9ff97b695d28" id="r_af77904a0a6b0162bb6ba9ff97b695d28"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af77904a0a6b0162bb6ba9ff97b695d28">bhopscotch_set</a> (<a class="el" href="#adfe28f55c3c51048b90c94f95e70b254">size_type</a> <a class="el" href="#a48f085051bacbb4f8a713207ce750a2e">bucket_count</a>, const Hash &amp;hash, const Allocator &amp;alloc)</td></tr>
<tr class="memitem:a950059296854a10a45595e9adeb45eed" id="r_a950059296854a10a45595e9adeb45eed"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a950059296854a10a45595e9adeb45eed">bhopscotch_set</a> (const Allocator &amp;alloc)</td></tr>
<tr class="memitem:a82b9231383d44c81acd80284dcc07fea" id="r_a82b9231383d44c81acd80284dcc07fea"><td class="memTemplParams" colspan="2">template&lt;class InputIt&gt; </td></tr>
<tr class="memitem:a82b9231383d44c81acd80284dcc07fea template"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a82b9231383d44c81acd80284dcc07fea">bhopscotch_set</a> (InputIt first, InputIt last, <a class="el" href="#adfe28f55c3c51048b90c94f95e70b254">size_type</a> <a class="el" href="#a48f085051bacbb4f8a713207ce750a2e">bucket_count</a>=<a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#a3b4d20d3ff76dd7e703bb18368332368">ht::DEFAULT_INIT_BUCKETS_SIZE</a>, const Hash &amp;hash=Hash(), const KeyEqual &amp;equal=KeyEqual(), const Allocator &amp;alloc=Allocator())</td></tr>
<tr class="memitem:a090cd853b3222206338b823476ef258b" id="r_a090cd853b3222206338b823476ef258b"><td class="memTemplParams" colspan="2">template&lt;class InputIt&gt; </td></tr>
<tr class="memitem:a090cd853b3222206338b823476ef258b template"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a090cd853b3222206338b823476ef258b">bhopscotch_set</a> (InputIt first, InputIt last, <a class="el" href="#adfe28f55c3c51048b90c94f95e70b254">size_type</a> <a class="el" href="#a48f085051bacbb4f8a713207ce750a2e">bucket_count</a>, const Allocator &amp;alloc)</td></tr>
<tr class="memitem:aa240c3bf9bbc2e4426faabae830651fd" id="r_aa240c3bf9bbc2e4426faabae830651fd"><td class="memTemplParams" colspan="2">template&lt;class InputIt&gt; </td></tr>
<tr class="memitem:aa240c3bf9bbc2e4426faabae830651fd template"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa240c3bf9bbc2e4426faabae830651fd">bhopscotch_set</a> (InputIt first, InputIt last, <a class="el" href="#adfe28f55c3c51048b90c94f95e70b254">size_type</a> <a class="el" href="#a48f085051bacbb4f8a713207ce750a2e">bucket_count</a>, const Hash &amp;hash, const Allocator &amp;alloc)</td></tr>
<tr class="memitem:ab1b7077d7a0ab6ad36ecb38ab9bff26e" id="r_ab1b7077d7a0ab6ad36ecb38ab9bff26e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab1b7077d7a0ab6ad36ecb38ab9bff26e">bhopscotch_set</a> (std::initializer_list&lt; <a class="el" href="#a5dba07d4206217a586ec8b10674d0788">value_type</a> &gt; init, <a class="el" href="#adfe28f55c3c51048b90c94f95e70b254">size_type</a> <a class="el" href="#a48f085051bacbb4f8a713207ce750a2e">bucket_count</a>=<a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#a3b4d20d3ff76dd7e703bb18368332368">ht::DEFAULT_INIT_BUCKETS_SIZE</a>, const Hash &amp;hash=Hash(), const KeyEqual &amp;equal=KeyEqual(), const Allocator &amp;alloc=Allocator())</td></tr>
<tr class="memitem:aaa84c4d8419c0b22f5d7fbdd482e14f2" id="r_aaa84c4d8419c0b22f5d7fbdd482e14f2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaa84c4d8419c0b22f5d7fbdd482e14f2">bhopscotch_set</a> (std::initializer_list&lt; <a class="el" href="#a5dba07d4206217a586ec8b10674d0788">value_type</a> &gt; init, <a class="el" href="#adfe28f55c3c51048b90c94f95e70b254">size_type</a> <a class="el" href="#a48f085051bacbb4f8a713207ce750a2e">bucket_count</a>, const Allocator &amp;alloc)</td></tr>
<tr class="memitem:a0ac5998651c113d85cb329bfc182b2a0" id="r_a0ac5998651c113d85cb329bfc182b2a0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0ac5998651c113d85cb329bfc182b2a0">bhopscotch_set</a> (std::initializer_list&lt; <a class="el" href="#a5dba07d4206217a586ec8b10674d0788">value_type</a> &gt; init, <a class="el" href="#adfe28f55c3c51048b90c94f95e70b254">size_type</a> <a class="el" href="#a48f085051bacbb4f8a713207ce750a2e">bucket_count</a>, const Hash &amp;hash, const Allocator &amp;alloc)</td></tr>
<tr class="memitem:a4d66683b0a2a7552ef4805735c8e8a30" id="r_a4d66683b0a2a7552ef4805735c8e8a30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1bhopscotch__set.html">bhopscotch_set</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4d66683b0a2a7552ef4805735c8e8a30">operator=</a> (std::initializer_list&lt; <a class="el" href="#a5dba07d4206217a586ec8b10674d0788">value_type</a> &gt; ilist)</td></tr>
<tr class="memitem:a5387ca6d803a7d5459034b719004e286" id="r_a5387ca6d803a7d5459034b719004e286"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a593ea7b428b2a98d45b61ddb7d4412f0">allocator_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5387ca6d803a7d5459034b719004e286">get_allocator</a> () const</td></tr>
<tr class="memitem:a6cb58244769bc1bf969c8b836fa3a1d9" id="r_a6cb58244769bc1bf969c8b836fa3a1d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#aabc10d644f92fc6b16707b8da6d250a9">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6cb58244769bc1bf969c8b836fa3a1d9">begin</a> () noexcept</td></tr>
<tr class="memitem:a6371fa450b064e2854889cbcecc7b51f" id="r_a6371fa450b064e2854889cbcecc7b51f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#acca0be5d2184d2a03d6bbe3ab2c349e4">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6371fa450b064e2854889cbcecc7b51f">begin</a> () const noexcept</td></tr>
<tr class="memitem:a6c65031364d0eacfc7676c05a467bb16" id="r_a6c65031364d0eacfc7676c05a467bb16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#acca0be5d2184d2a03d6bbe3ab2c349e4">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6c65031364d0eacfc7676c05a467bb16">cbegin</a> () const noexcept</td></tr>
<tr class="memitem:ac8ae42547785e9acbd445dc6a236fc85" id="r_ac8ae42547785e9acbd445dc6a236fc85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#aabc10d644f92fc6b16707b8da6d250a9">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac8ae42547785e9acbd445dc6a236fc85">end</a> () noexcept</td></tr>
<tr class="memitem:aaf559ad9976188b9afc376e9412441b3" id="r_aaf559ad9976188b9afc376e9412441b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#acca0be5d2184d2a03d6bbe3ab2c349e4">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaf559ad9976188b9afc376e9412441b3">end</a> () const noexcept</td></tr>
<tr class="memitem:a3f015877d2d4806cbf77ffbcc4dfe415" id="r_a3f015877d2d4806cbf77ffbcc4dfe415"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#acca0be5d2184d2a03d6bbe3ab2c349e4">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f015877d2d4806cbf77ffbcc4dfe415">cend</a> () const noexcept</td></tr>
<tr class="memitem:ad626f87d13e2f9894c6066c1f7726bac" id="r_ad626f87d13e2f9894c6066c1f7726bac"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad626f87d13e2f9894c6066c1f7726bac">empty</a> () const noexcept</td></tr>
<tr class="memitem:a9604059a0f2cf4b950e4199e9d2d9192" id="r_a9604059a0f2cf4b950e4199e9d2d9192"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#adfe28f55c3c51048b90c94f95e70b254">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9604059a0f2cf4b950e4199e9d2d9192">size</a> () const noexcept</td></tr>
<tr class="memitem:a1f4017a11298fe2940f0162b1164173b" id="r_a1f4017a11298fe2940f0162b1164173b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#adfe28f55c3c51048b90c94f95e70b254">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f4017a11298fe2940f0162b1164173b">max_size</a> () const noexcept</td></tr>
<tr class="memitem:afbf2da17736f2f821c793f471a7e42b1" id="r_afbf2da17736f2f821c793f471a7e42b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afbf2da17736f2f821c793f471a7e42b1">clear</a> () noexcept</td></tr>
<tr class="memitem:a134e3ae1657332312404bd1210758a18" id="r_a134e3ae1657332312404bd1210758a18"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="#aabc10d644f92fc6b16707b8da6d250a9">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a134e3ae1657332312404bd1210758a18">insert</a> (const <a class="el" href="#a5dba07d4206217a586ec8b10674d0788">value_type</a> &amp;value)</td></tr>
<tr class="memitem:a3957015e5955fc553003bbfe225836a0" id="r_a3957015e5955fc553003bbfe225836a0"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="#aabc10d644f92fc6b16707b8da6d250a9">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3957015e5955fc553003bbfe225836a0">insert</a> (<a class="el" href="#a5dba07d4206217a586ec8b10674d0788">value_type</a> &amp;&amp;value)</td></tr>
<tr class="memitem:aa1c6e8b61239a029bbec5795c8ef98e1" id="r_aa1c6e8b61239a029bbec5795c8ef98e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#aabc10d644f92fc6b16707b8da6d250a9">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa1c6e8b61239a029bbec5795c8ef98e1">insert</a> (<a class="el" href="#acca0be5d2184d2a03d6bbe3ab2c349e4">const_iterator</a> hint, const <a class="el" href="#a5dba07d4206217a586ec8b10674d0788">value_type</a> &amp;value)</td></tr>
<tr class="memitem:ada344d4394e3c2c61b447daed144fdec" id="r_ada344d4394e3c2c61b447daed144fdec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#aabc10d644f92fc6b16707b8da6d250a9">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada344d4394e3c2c61b447daed144fdec">insert</a> (<a class="el" href="#acca0be5d2184d2a03d6bbe3ab2c349e4">const_iterator</a> hint, <a class="el" href="#a5dba07d4206217a586ec8b10674d0788">value_type</a> &amp;&amp;value)</td></tr>
<tr class="memitem:abbf3ef37d1b6c341b03ddc6446f6971d" id="r_abbf3ef37d1b6c341b03ddc6446f6971d"><td class="memTemplParams" colspan="2">template&lt;class InputIt&gt; </td></tr>
<tr class="memitem:abbf3ef37d1b6c341b03ddc6446f6971d template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abbf3ef37d1b6c341b03ddc6446f6971d">insert</a> (InputIt first, InputIt last)</td></tr>
<tr class="memitem:a921bcb9a4da2eb3caa6dcb03b8654b4e" id="r_a921bcb9a4da2eb3caa6dcb03b8654b4e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a921bcb9a4da2eb3caa6dcb03b8654b4e">insert</a> (std::initializer_list&lt; <a class="el" href="#a5dba07d4206217a586ec8b10674d0788">value_type</a> &gt; ilist)</td></tr>
<tr class="memitem:aa3672ffc92587dfd78809da10bc84159" id="r_aa3672ffc92587dfd78809da10bc84159"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:aa3672ffc92587dfd78809da10bc84159 template"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="#aabc10d644f92fc6b16707b8da6d250a9">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa3672ffc92587dfd78809da10bc84159">emplace</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memitem:a6ccd3deac1c065d6736ea059b43e8944" id="r_a6ccd3deac1c065d6736ea059b43e8944"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a6ccd3deac1c065d6736ea059b43e8944 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#aabc10d644f92fc6b16707b8da6d250a9">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ccd3deac1c065d6736ea059b43e8944">emplace_hint</a> (<a class="el" href="#acca0be5d2184d2a03d6bbe3ab2c349e4">const_iterator</a> hint, Args &amp;&amp;...args)</td></tr>
<tr class="memitem:acbe3e5a929ed649cca1cadb314b676d7" id="r_acbe3e5a929ed649cca1cadb314b676d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#aabc10d644f92fc6b16707b8da6d250a9">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acbe3e5a929ed649cca1cadb314b676d7">erase</a> (<a class="el" href="#aabc10d644f92fc6b16707b8da6d250a9">iterator</a> pos)</td></tr>
<tr class="memitem:ae1fb06cf0ef8e1b4834a088c12d168e9" id="r_ae1fb06cf0ef8e1b4834a088c12d168e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#aabc10d644f92fc6b16707b8da6d250a9">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae1fb06cf0ef8e1b4834a088c12d168e9">erase</a> (<a class="el" href="#acca0be5d2184d2a03d6bbe3ab2c349e4">const_iterator</a> pos)</td></tr>
<tr class="memitem:a1f553a3ede0d4419f4d880c10fedf604" id="r_a1f553a3ede0d4419f4d880c10fedf604"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#aabc10d644f92fc6b16707b8da6d250a9">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f553a3ede0d4419f4d880c10fedf604">erase</a> (<a class="el" href="#acca0be5d2184d2a03d6bbe3ab2c349e4">const_iterator</a> first, <a class="el" href="#acca0be5d2184d2a03d6bbe3ab2c349e4">const_iterator</a> last)</td></tr>
<tr class="memitem:ab049877cdfbe936177841d35a864a05f" id="r_ab049877cdfbe936177841d35a864a05f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#adfe28f55c3c51048b90c94f95e70b254">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab049877cdfbe936177841d35a864a05f">erase</a> (const <a class="el" href="#a42dce508be37a6f7b694f8a18ee5554d">key_type</a> &amp;key)</td></tr>
<tr class="memitem:a64a116b5e03bd75b3416444191f6894c" id="r_a64a116b5e03bd75b3416444191f6894c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#adfe28f55c3c51048b90c94f95e70b254">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a64a116b5e03bd75b3416444191f6894c">erase</a> (const <a class="el" href="#a42dce508be37a6f7b694f8a18ee5554d">key_type</a> &amp;key, std::size_t precalculated_hash)</td></tr>
<tr class="memitem:a3bcf1322a7cca63005e3813c131e6f02" id="r_a3bcf1322a7cca63005e3813c131e6f02"><td class="memTemplParams" colspan="2">template&lt;class K, class KE = KeyEqual, class CP = Compare, typename std::enable_if&lt; <a class="el" href="#a5e1654919c2609c7501081a2749ac1c5">has_is_transparent</a>&lt; KE &gt;::value &amp;&amp;<a class="el" href="#a5e1654919c2609c7501081a2749ac1c5">has_is_transparent</a>&lt; CP &gt;::value &gt;::type * = nullptr&gt; </td></tr>
<tr class="memitem:a3bcf1322a7cca63005e3813c131e6f02 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#adfe28f55c3c51048b90c94f95e70b254">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3bcf1322a7cca63005e3813c131e6f02">erase</a> (const K &amp;key)</td></tr>
<tr class="memitem:a39b9600bf6e08dc0dfb530d7e9cfd369" id="r_a39b9600bf6e08dc0dfb530d7e9cfd369"><td class="memTemplParams" colspan="2">template&lt;class K, class KE = KeyEqual, class CP = Compare, typename std::enable_if&lt; <a class="el" href="#a5e1654919c2609c7501081a2749ac1c5">has_is_transparent</a>&lt; KE &gt;::value &amp;&amp;<a class="el" href="#a5e1654919c2609c7501081a2749ac1c5">has_is_transparent</a>&lt; CP &gt;::value &gt;::type * = nullptr&gt; </td></tr>
<tr class="memitem:a39b9600bf6e08dc0dfb530d7e9cfd369 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#adfe28f55c3c51048b90c94f95e70b254">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a39b9600bf6e08dc0dfb530d7e9cfd369">erase</a> (const K &amp;key, std::size_t precalculated_hash)</td></tr>
<tr class="memitem:a566b0e12433024c3daa2fffefb030ce3" id="r_a566b0e12433024c3daa2fffefb030ce3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a566b0e12433024c3daa2fffefb030ce3">swap</a> (<a class="el" href="classtsl_1_1bhopscotch__set.html">bhopscotch_set</a> &amp;other)</td></tr>
<tr class="memitem:a089e2f4437d910b3ef0a2b526c5c7886" id="r_a089e2f4437d910b3ef0a2b526c5c7886"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#adfe28f55c3c51048b90c94f95e70b254">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a089e2f4437d910b3ef0a2b526c5c7886">count</a> (const Key &amp;key) const</td></tr>
<tr class="memitem:a692d5e11d474d8bfaf77ceae652bd1f8" id="r_a692d5e11d474d8bfaf77ceae652bd1f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#adfe28f55c3c51048b90c94f95e70b254">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a692d5e11d474d8bfaf77ceae652bd1f8">count</a> (const Key &amp;key, std::size_t precalculated_hash) const</td></tr>
<tr class="memitem:a0c525cd0d5d5d5df8206129d801335ae" id="r_a0c525cd0d5d5d5df8206129d801335ae"><td class="memTemplParams" colspan="2">template&lt;class K, class KE = KeyEqual, class CP = Compare, typename std::enable_if&lt; <a class="el" href="#a5e1654919c2609c7501081a2749ac1c5">has_is_transparent</a>&lt; KE &gt;::value &amp;&amp;<a class="el" href="#a5e1654919c2609c7501081a2749ac1c5">has_is_transparent</a>&lt; CP &gt;::value &gt;::type * = nullptr&gt; </td></tr>
<tr class="memitem:a0c525cd0d5d5d5df8206129d801335ae template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#adfe28f55c3c51048b90c94f95e70b254">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c525cd0d5d5d5df8206129d801335ae">count</a> (const K &amp;key) const</td></tr>
<tr class="memitem:a6fc3b54f32756523f84e476e8e613dc3" id="r_a6fc3b54f32756523f84e476e8e613dc3"><td class="memTemplParams" colspan="2">template&lt;class K, class KE = KeyEqual, class CP = Compare, typename std::enable_if&lt; <a class="el" href="#a5e1654919c2609c7501081a2749ac1c5">has_is_transparent</a>&lt; KE &gt;::value &amp;&amp;<a class="el" href="#a5e1654919c2609c7501081a2749ac1c5">has_is_transparent</a>&lt; CP &gt;::value &gt;::type * = nullptr&gt; </td></tr>
<tr class="memitem:a6fc3b54f32756523f84e476e8e613dc3 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#adfe28f55c3c51048b90c94f95e70b254">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6fc3b54f32756523f84e476e8e613dc3">count</a> (const K &amp;key, std::size_t precalculated_hash) const</td></tr>
<tr class="memitem:a11f93a2f37653ca1a4992cf1b4c7f56a" id="r_a11f93a2f37653ca1a4992cf1b4c7f56a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#aabc10d644f92fc6b16707b8da6d250a9">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a11f93a2f37653ca1a4992cf1b4c7f56a">find</a> (const Key &amp;key)</td></tr>
<tr class="memitem:adf9c72c01f33dc5e5c1febb3d7850596" id="r_adf9c72c01f33dc5e5c1febb3d7850596"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#aabc10d644f92fc6b16707b8da6d250a9">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adf9c72c01f33dc5e5c1febb3d7850596">find</a> (const Key &amp;key, std::size_t precalculated_hash)</td></tr>
<tr class="memitem:aca6d1de8e18672205787a41e072cf302" id="r_aca6d1de8e18672205787a41e072cf302"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#acca0be5d2184d2a03d6bbe3ab2c349e4">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aca6d1de8e18672205787a41e072cf302">find</a> (const Key &amp;key) const</td></tr>
<tr class="memitem:a90b9f52662f5160301ea2b33f21ef5a8" id="r_a90b9f52662f5160301ea2b33f21ef5a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#acca0be5d2184d2a03d6bbe3ab2c349e4">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a90b9f52662f5160301ea2b33f21ef5a8">find</a> (const Key &amp;key, std::size_t precalculated_hash) const</td></tr>
<tr class="memitem:ace4907fe666af1d6a3bbb3172497938f" id="r_ace4907fe666af1d6a3bbb3172497938f"><td class="memTemplParams" colspan="2">template&lt;class K, class KE = KeyEqual, class CP = Compare, typename std::enable_if&lt; <a class="el" href="#a5e1654919c2609c7501081a2749ac1c5">has_is_transparent</a>&lt; KE &gt;::value &amp;&amp;<a class="el" href="#a5e1654919c2609c7501081a2749ac1c5">has_is_transparent</a>&lt; CP &gt;::value &gt;::type * = nullptr&gt; </td></tr>
<tr class="memitem:ace4907fe666af1d6a3bbb3172497938f template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#aabc10d644f92fc6b16707b8da6d250a9">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ace4907fe666af1d6a3bbb3172497938f">find</a> (const K &amp;key)</td></tr>
<tr class="memitem:a4335d819addfe1b41c6b6f8d84bc8a5b" id="r_a4335d819addfe1b41c6b6f8d84bc8a5b"><td class="memTemplParams" colspan="2">template&lt;class K, class KE = KeyEqual, class CP = Compare, typename std::enable_if&lt; <a class="el" href="#a5e1654919c2609c7501081a2749ac1c5">has_is_transparent</a>&lt; KE &gt;::value &amp;&amp;<a class="el" href="#a5e1654919c2609c7501081a2749ac1c5">has_is_transparent</a>&lt; CP &gt;::value &gt;::type * = nullptr&gt; </td></tr>
<tr class="memitem:a4335d819addfe1b41c6b6f8d84bc8a5b template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#aabc10d644f92fc6b16707b8da6d250a9">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4335d819addfe1b41c6b6f8d84bc8a5b">find</a> (const K &amp;key, std::size_t precalculated_hash)</td></tr>
<tr class="memitem:abcf726c4ad38747d13222cadbd7ee8ea" id="r_abcf726c4ad38747d13222cadbd7ee8ea"><td class="memTemplParams" colspan="2">template&lt;class K, class KE = KeyEqual, class CP = Compare, typename std::enable_if&lt; <a class="el" href="#a5e1654919c2609c7501081a2749ac1c5">has_is_transparent</a>&lt; KE &gt;::value &amp;&amp;<a class="el" href="#a5e1654919c2609c7501081a2749ac1c5">has_is_transparent</a>&lt; CP &gt;::value &gt;::type * = nullptr&gt; </td></tr>
<tr class="memitem:abcf726c4ad38747d13222cadbd7ee8ea template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#acca0be5d2184d2a03d6bbe3ab2c349e4">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abcf726c4ad38747d13222cadbd7ee8ea">find</a> (const K &amp;key) const</td></tr>
<tr class="memitem:a069de0d06bbc53fff3932254bfa72885" id="r_a069de0d06bbc53fff3932254bfa72885"><td class="memTemplParams" colspan="2">template&lt;class K, class KE = KeyEqual, class CP = Compare, typename std::enable_if&lt; <a class="el" href="#a5e1654919c2609c7501081a2749ac1c5">has_is_transparent</a>&lt; KE &gt;::value &amp;&amp;<a class="el" href="#a5e1654919c2609c7501081a2749ac1c5">has_is_transparent</a>&lt; CP &gt;::value &gt;::type * = nullptr&gt; </td></tr>
<tr class="memitem:a069de0d06bbc53fff3932254bfa72885 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#acca0be5d2184d2a03d6bbe3ab2c349e4">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a069de0d06bbc53fff3932254bfa72885">find</a> (const K &amp;key, std::size_t precalculated_hash) const</td></tr>
<tr class="memitem:a0c9d13caa0cd0f0fd05c4d5d25eb256e" id="r_a0c9d13caa0cd0f0fd05c4d5d25eb256e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c9d13caa0cd0f0fd05c4d5d25eb256e">contains</a> (const Key &amp;key) const</td></tr>
<tr class="memitem:afea5c514821124b77ff62571a3921502" id="r_afea5c514821124b77ff62571a3921502"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afea5c514821124b77ff62571a3921502">contains</a> (const Key &amp;key, std::size_t precalculated_hash) const</td></tr>
<tr class="memitem:af05774a8f798a1e678d9ce0cb265378a" id="r_af05774a8f798a1e678d9ce0cb265378a"><td class="memTemplParams" colspan="2">template&lt;class K, class KE = KeyEqual, typename std::enable_if&lt; <a class="el" href="#a5e1654919c2609c7501081a2749ac1c5">has_is_transparent</a>&lt; KE &gt;::value &gt;::type * = nullptr&gt; </td></tr>
<tr class="memitem:af05774a8f798a1e678d9ce0cb265378a template"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af05774a8f798a1e678d9ce0cb265378a">contains</a> (const K &amp;key) const</td></tr>
<tr class="memitem:a68d1447d74c1059b4b2cf586567db401" id="r_a68d1447d74c1059b4b2cf586567db401"><td class="memTemplParams" colspan="2">template&lt;class K, class KE = KeyEqual, typename std::enable_if&lt; <a class="el" href="#a5e1654919c2609c7501081a2749ac1c5">has_is_transparent</a>&lt; KE &gt;::value &gt;::type * = nullptr&gt; </td></tr>
<tr class="memitem:a68d1447d74c1059b4b2cf586567db401 template"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a68d1447d74c1059b4b2cf586567db401">contains</a> (const K &amp;key, std::size_t precalculated_hash) const</td></tr>
<tr class="memitem:a426d3f59a083fa4a42d9be8552ddc6c3" id="r_a426d3f59a083fa4a42d9be8552ddc6c3"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="#aabc10d644f92fc6b16707b8da6d250a9">iterator</a>, <a class="el" href="#aabc10d644f92fc6b16707b8da6d250a9">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a426d3f59a083fa4a42d9be8552ddc6c3">equal_range</a> (const Key &amp;key)</td></tr>
<tr class="memitem:a74e0f5b38221fc99a20f3e461bc2e048" id="r_a74e0f5b38221fc99a20f3e461bc2e048"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="#aabc10d644f92fc6b16707b8da6d250a9">iterator</a>, <a class="el" href="#aabc10d644f92fc6b16707b8da6d250a9">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a74e0f5b38221fc99a20f3e461bc2e048">equal_range</a> (const Key &amp;key, std::size_t precalculated_hash)</td></tr>
<tr class="memitem:a4c8c453741e0c78e3bc755076d9c2ba0" id="r_a4c8c453741e0c78e3bc755076d9c2ba0"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="#acca0be5d2184d2a03d6bbe3ab2c349e4">const_iterator</a>, <a class="el" href="#acca0be5d2184d2a03d6bbe3ab2c349e4">const_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4c8c453741e0c78e3bc755076d9c2ba0">equal_range</a> (const Key &amp;key) const</td></tr>
<tr class="memitem:a37d5822b859c49a58c2d5b5ec6889e28" id="r_a37d5822b859c49a58c2d5b5ec6889e28"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="#acca0be5d2184d2a03d6bbe3ab2c349e4">const_iterator</a>, <a class="el" href="#acca0be5d2184d2a03d6bbe3ab2c349e4">const_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a37d5822b859c49a58c2d5b5ec6889e28">equal_range</a> (const Key &amp;key, std::size_t precalculated_hash) const</td></tr>
<tr class="memitem:a860951a8d60de66991484e60e3188a6e" id="r_a860951a8d60de66991484e60e3188a6e"><td class="memTemplParams" colspan="2">template&lt;class K, class KE = KeyEqual, class CP = Compare, typename std::enable_if&lt; <a class="el" href="#a5e1654919c2609c7501081a2749ac1c5">has_is_transparent</a>&lt; KE &gt;::value &amp;&amp;<a class="el" href="#a5e1654919c2609c7501081a2749ac1c5">has_is_transparent</a>&lt; CP &gt;::value &gt;::type * = nullptr&gt; </td></tr>
<tr class="memitem:a860951a8d60de66991484e60e3188a6e template"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="#aabc10d644f92fc6b16707b8da6d250a9">iterator</a>, <a class="el" href="#aabc10d644f92fc6b16707b8da6d250a9">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a860951a8d60de66991484e60e3188a6e">equal_range</a> (const K &amp;key)</td></tr>
<tr class="memitem:ab2d09cb4aa700bc3f60db84a1a0ce345" id="r_ab2d09cb4aa700bc3f60db84a1a0ce345"><td class="memTemplParams" colspan="2">template&lt;class K, class KE = KeyEqual, class CP = Compare, typename std::enable_if&lt; <a class="el" href="#a5e1654919c2609c7501081a2749ac1c5">has_is_transparent</a>&lt; KE &gt;::value &amp;&amp;<a class="el" href="#a5e1654919c2609c7501081a2749ac1c5">has_is_transparent</a>&lt; CP &gt;::value &gt;::type * = nullptr&gt; </td></tr>
<tr class="memitem:ab2d09cb4aa700bc3f60db84a1a0ce345 template"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="#aabc10d644f92fc6b16707b8da6d250a9">iterator</a>, <a class="el" href="#aabc10d644f92fc6b16707b8da6d250a9">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab2d09cb4aa700bc3f60db84a1a0ce345">equal_range</a> (const K &amp;key, std::size_t precalculated_hash)</td></tr>
<tr class="memitem:a37874de45adbd5bd3a3f4853c0881dbc" id="r_a37874de45adbd5bd3a3f4853c0881dbc"><td class="memTemplParams" colspan="2">template&lt;class K, class KE = KeyEqual, class CP = Compare, typename std::enable_if&lt; <a class="el" href="#a5e1654919c2609c7501081a2749ac1c5">has_is_transparent</a>&lt; KE &gt;::value &amp;&amp;<a class="el" href="#a5e1654919c2609c7501081a2749ac1c5">has_is_transparent</a>&lt; CP &gt;::value &gt;::type * = nullptr&gt; </td></tr>
<tr class="memitem:a37874de45adbd5bd3a3f4853c0881dbc template"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="#acca0be5d2184d2a03d6bbe3ab2c349e4">const_iterator</a>, <a class="el" href="#acca0be5d2184d2a03d6bbe3ab2c349e4">const_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a37874de45adbd5bd3a3f4853c0881dbc">equal_range</a> (const K &amp;key) const</td></tr>
<tr class="memitem:afb65abd98e17d7d4cb38f212ae65d280" id="r_afb65abd98e17d7d4cb38f212ae65d280"><td class="memTemplParams" colspan="2">template&lt;class K, class KE = KeyEqual, class CP = Compare, typename std::enable_if&lt; <a class="el" href="#a5e1654919c2609c7501081a2749ac1c5">has_is_transparent</a>&lt; KE &gt;::value &amp;&amp;<a class="el" href="#a5e1654919c2609c7501081a2749ac1c5">has_is_transparent</a>&lt; CP &gt;::value &gt;::type * = nullptr&gt; </td></tr>
<tr class="memitem:afb65abd98e17d7d4cb38f212ae65d280 template"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="#acca0be5d2184d2a03d6bbe3ab2c349e4">const_iterator</a>, <a class="el" href="#acca0be5d2184d2a03d6bbe3ab2c349e4">const_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afb65abd98e17d7d4cb38f212ae65d280">equal_range</a> (const K &amp;key, std::size_t precalculated_hash) const</td></tr>
<tr class="memitem:a48f085051bacbb4f8a713207ce750a2e" id="r_a48f085051bacbb4f8a713207ce750a2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#adfe28f55c3c51048b90c94f95e70b254">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a48f085051bacbb4f8a713207ce750a2e">bucket_count</a> () const</td></tr>
<tr class="memitem:a33ab8fed34703417ab024c664dfe4ccc" id="r_a33ab8fed34703417ab024c664dfe4ccc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#adfe28f55c3c51048b90c94f95e70b254">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a33ab8fed34703417ab024c664dfe4ccc">max_bucket_count</a> () const</td></tr>
<tr class="memitem:ab8d6cf41b390f562d4af528a45e7e2d4" id="r_ab8d6cf41b390f562d4af528a45e7e2d4"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab8d6cf41b390f562d4af528a45e7e2d4">load_factor</a> () const</td></tr>
<tr class="memitem:aa8dc6419d907972a53b1f8dc68d2e4c8" id="r_aa8dc6419d907972a53b1f8dc68d2e4c8"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa8dc6419d907972a53b1f8dc68d2e4c8">max_load_factor</a> () const</td></tr>
<tr class="memitem:af7b4c99c39b415127636ffd46815b32f" id="r_af7b4c99c39b415127636ffd46815b32f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af7b4c99c39b415127636ffd46815b32f">max_load_factor</a> (float ml)</td></tr>
<tr class="memitem:a0efe9b0121ec9c8cb18a40663c0ddf71" id="r_a0efe9b0121ec9c8cb18a40663c0ddf71"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0efe9b0121ec9c8cb18a40663c0ddf71">rehash</a> (<a class="el" href="#adfe28f55c3c51048b90c94f95e70b254">size_type</a> count_)</td></tr>
<tr class="memitem:acaba32a2f9c6a8161dd64bffff0f783d" id="r_acaba32a2f9c6a8161dd64bffff0f783d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acaba32a2f9c6a8161dd64bffff0f783d">reserve</a> (<a class="el" href="#adfe28f55c3c51048b90c94f95e70b254">size_type</a> count_)</td></tr>
<tr class="memitem:a72cfd16bbab23d7cc42585d7e1d7e32a" id="r_a72cfd16bbab23d7cc42585d7e1d7e32a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a9abb25ad29802ea7f4b5739cf9d57c9f">hasher</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a72cfd16bbab23d7cc42585d7e1d7e32a">hash_function</a> () const</td></tr>
<tr class="memitem:aadf2cd4a08305f6ccdd2d1de362ee9ee" id="r_aadf2cd4a08305f6ccdd2d1de362ee9ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#af8f59d8436d8bd927950a2875f61853b">key_equal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aadf2cd4a08305f6ccdd2d1de362ee9ee">key_eq</a> () const</td></tr>
<tr class="memitem:af9d235af8175c7b14f712ada0aa71443" id="r_af9d235af8175c7b14f712ada0aa71443"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#aac0fb26ecfc1e0bac31698e489d987f0">key_compare</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af9d235af8175c7b14f712ada0aa71443">key_comp</a> () const</td></tr>
<tr class="memitem:a019521464241af361a3709fe67269618" id="r_a019521464241af361a3709fe67269618"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#aabc10d644f92fc6b16707b8da6d250a9">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a019521464241af361a3709fe67269618">mutable_iterator</a> (<a class="el" href="#acca0be5d2184d2a03d6bbe3ab2c349e4">const_iterator</a> pos)</td></tr>
<tr class="memitem:a20b28747795deb75cfb6c8bfadeede56" id="r_a20b28747795deb75cfb6c8bfadeede56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#adfe28f55c3c51048b90c94f95e70b254">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a20b28747795deb75cfb6c8bfadeede56">overflow_size</a> () const noexcept</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pri-types" class="groupheader"><a id="pri-types" name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:a5e1654919c2609c7501081a2749ac1c5" id="r_a5e1654919c2609c7501081a2749ac1c5"><td class="memTemplParams" colspan="2">template&lt;typename U&gt; </td></tr>
<tr class="memitem:a5e1654919c2609c7501081a2749ac1c5 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5e1654919c2609c7501081a2749ac1c5">has_is_transparent</a> = <a class="el" href="structtsl_1_1detail__hopscotch__hash_1_1has__is__transparent.html">tsl::detail_hopscotch_hash::has_is_transparent</a>&lt;U&gt;</td></tr>
<tr class="memitem:a585def3f40eabb0b15b7a3ef6f004620" id="r_a585def3f40eabb0b15b7a3ef6f004620"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a585def3f40eabb0b15b7a3ef6f004620">overflow_container_type</a> = std::set&lt;Key, Compare, Allocator&gt;</td></tr>
<tr class="memitem:aa79eeeb4f32c31085422caa2023999c6" id="r_aa79eeeb4f32c31085422caa2023999c6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa79eeeb4f32c31085422caa2023999c6">ht</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pri-attribs" class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a251f7c9cf2c158e26c4a81886cd8be22" id="r_a251f7c9cf2c158e26c4a81886cd8be22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#aa79eeeb4f32c31085422caa2023999c6">ht</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a251f7c9cf2c158e26c4a81886cd8be22">m_ht</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-friends" class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a5874b4eefd2b1cd9f135e7a5b38daabd" id="r_a5874b4eefd2b1cd9f135e7a5b38daabd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5874b4eefd2b1cd9f135e7a5b38daabd">operator==</a> (const <a class="el" href="classtsl_1_1bhopscotch__set.html">bhopscotch_set</a> &amp;lhs, const <a class="el" href="classtsl_1_1bhopscotch__set.html">bhopscotch_set</a> &amp;rhs)</td></tr>
<tr class="memitem:a881b4c14f4b87d7566c05b752420e82f" id="r_a881b4c14f4b87d7566c05b752420e82f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a881b4c14f4b87d7566c05b752420e82f">operator!=</a> (const <a class="el" href="classtsl_1_1bhopscotch__set.html">bhopscotch_set</a> &amp;lhs, const <a class="el" href="classtsl_1_1bhopscotch__set.html">bhopscotch_set</a> &amp;rhs)</td></tr>
<tr class="memitem:aa7824d6ebb5065faea439641d2b59bd5" id="r_aa7824d6ebb5065faea439641d2b59bd5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa7824d6ebb5065faea439641d2b59bd5">swap</a> (<a class="el" href="classtsl_1_1bhopscotch__set.html">bhopscotch_set</a> &amp;lhs, <a class="el" href="classtsl_1_1bhopscotch__set.html">bhopscotch_set</a> &amp;rhs)</td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt;<br />
class tsl::bhopscotch_set&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;</div><p>Similar to <a class="el" href="classtsl_1_1hopscotch__set.html">tsl::hopscotch_set</a> but instead of using a list for overflowing elements it uses a binary search tree. It thus needs an additional template parameter Compare. Compare should be arithmetically coherent with KeyEqual.</p>
<p>The binary search tree allows the set to have a worst-case scenario of O(log
n) for search and delete, even if the hash function maps all the elements to the same bucket. For insert, the amortized worst case is O(log n), but the worst case is O(n) in case of rehash.</p>
<p>This makes the set resistant to DoS attacks (but doesn't preclude you to have a good hash function, as an element in the bucket array is faster to retrieve than in the tree).</p>
<p>Implementation of a hash set using the hopscotch hashing algorithm.</p>
<p>The Key must be either nothrow move-constructible, copy-constructible or both.</p>
<p>The size of the neighborhood (NeighborhoodSize) must be &gt; 0 and &lt;= 62 if StoreHash is false. When StoreHash is true, 32-bits of the hash will be stored alongside the neighborhood limiting the NeighborhoodSize to &lt;= 30. There is no memory usage difference between 'NeighborhoodSize 62; StoreHash false' and 'NeighborhoodSize 30; StoreHash true'.</p>
<p>Storing the hash may improve performance on insert during the rehash process if the hash takes time to compute. It may also improve read performance if the KeyEqual function takes time (or incurs a cache-miss). If used with simple Hash and KeyEqual it may slow things down.</p>
<p>StoreHash can only be set if the GrowthPolicy is set to tsl::power_of_two_growth_policy.</p>
<p>GrowthPolicy defines how the set grows and consequently how a hash value is mapped to a bucket. By default the set uses tsl::power_of_two_growth_policy. This policy keeps the number of buckets to a power of two and uses a mask to set the hash to a bucket instead of the slow modulo. You may define your own growth policy, check tsl::power_of_two_growth_policy for the interface.</p>
<p>If the destructor of Key throws an exception, behaviour of the class is undefined.</p>
<p>Iterators invalidation:</p><ul>
<li>clear, operator=, reserve, rehash: always invalidate the iterators.</li>
<li>insert, emplace, emplace_hint, operator[]: if there is an effective insert, invalidate the iterators if a displacement is needed to resolve a collision (which mean that most of the time, insert will invalidate the iterators). Or if there is a rehash.</li>
<li>erase: iterator on the erased element is the only one which become invalid.    </li>
</ul>
</div><a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Member Typedef Documentation</h2>
<a id="a593ea7b428b2a98d45b61ddb7d4412f0" name="a593ea7b428b2a98d45b61ddb7d4412f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a593ea7b428b2a98d45b61ddb7d4412f0">&#9670;&#160;</a></span>allocator_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::allocator_type = typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#a8af583783f638a3faac62c52b876aa67">ht::allocator_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acca0be5d2184d2a03d6bbe3ab2c349e4" name="acca0be5d2184d2a03d6bbe3ab2c349e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acca0be5d2184d2a03d6bbe3ab2c349e4">&#9670;&#160;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::const_iterator = typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#a2af6f88c2b254b2c9ff83c70eea7c952">ht::const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad67a0eb0af2eedf49270953f7455e629" name="ad67a0eb0af2eedf49270953f7455e629"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad67a0eb0af2eedf49270953f7455e629">&#9670;&#160;</a></span>const_pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::const_pointer = typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#a85e8fb0e24e28aef2c0ec4ce9e3f9d01">ht::const_pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a907e7c159415b1f368c8ed177844d511" name="a907e7c159415b1f368c8ed177844d511"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a907e7c159415b1f368c8ed177844d511">&#9670;&#160;</a></span>const_reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::const_reference = typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#ae45966f2a709f1d7f03d42cd19fb29ea">ht::const_reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8d6578a6c3bdd268f66b657950f8f6e9" name="a8d6578a6c3bdd268f66b657950f8f6e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d6578a6c3bdd268f66b657950f8f6e9">&#9670;&#160;</a></span>difference_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::difference_type = typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#a3a8a8e910088e7bdbfe63be530d31956">ht::difference_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5e1654919c2609c7501081a2749ac1c5" name="a5e1654919c2609c7501081a2749ac1c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e1654919c2609c7501081a2749ac1c5">&#9670;&#160;</a></span>has_is_transparent</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::has_is_transparent = <a class="el" href="structtsl_1_1detail__hopscotch__hash_1_1has__is__transparent.html">tsl::detail_hopscotch_hash::has_is_transparent</a>&lt;U&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9abb25ad29802ea7f4b5739cf9d57c9f" name="a9abb25ad29802ea7f4b5739cf9d57c9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9abb25ad29802ea7f4b5739cf9d57c9f">&#9670;&#160;</a></span>hasher</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::hasher = typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#a0ffe6a6aaa0794dcf4979fc23e583462">ht::hasher</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa79eeeb4f32c31085422caa2023999c6" name="aa79eeeb4f32c31085422caa2023999c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa79eeeb4f32c31085422caa2023999c6">&#9670;&#160;</a></span>ht</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::ht</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> <a class="code hl_class" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html">tsl::detail_hopscotch_hash::hopscotch_hash</a>&lt;Key, <a class="code hl_class" href="classtsl_1_1bhopscotch__map_1_1KeySelect.html">KeySelect</a>, void, Hash, KeyEqual,</div>
<div class="line">                                                          Allocator, NeighborhoodSize, StoreHash,</div>
<div class="line">                                                          GrowthPolicy, <a class="code hl_typedef" href="classtsl_1_1bhopscotch__map.html#aff58a60c5e700602737ad0f2c5401631">overflow_container_type</a>&gt;</div>
<div class="ttc" id="aclasstsl_1_1bhopscotch__map_1_1KeySelect_html"><div class="ttname"><a href="classtsl_1_1bhopscotch__map_1_1KeySelect.html">tsl::bhopscotch_map::KeySelect</a></div><div class="ttdef"><b>Definition</b> bhopscotch_map.h:67</div></div>
<div class="ttc" id="aclasstsl_1_1bhopscotch__map_html_aff58a60c5e700602737ad0f2c5401631"><div class="ttname"><a href="classtsl_1_1bhopscotch__map.html#aff58a60c5e700602737ad0f2c5401631">tsl::bhopscotch_map::overflow_container_type</a></div><div class="ttdeci">std::map&lt; Key, T, Compare, Allocator &gt; overflow_container_type</div><div class="ttdef"><b>Definition</b> bhopscotch_map.h:95</div></div>
<div class="ttc" id="aclasstsl_1_1detail__hopscotch__hash_1_1hopscotch__hash_html"><div class="ttname"><a href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html">tsl::detail_hopscotch_hash::hopscotch_hash</a></div><div class="ttdef"><b>Definition</b> hopscotch_hash.h:431</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aabc10d644f92fc6b16707b8da6d250a9" name="aabc10d644f92fc6b16707b8da6d250a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabc10d644f92fc6b16707b8da6d250a9">&#9670;&#160;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::iterator = typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#ab697c644e6dec536d6ab028ba085b591">ht::iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aac0fb26ecfc1e0bac31698e489d987f0" name="aac0fb26ecfc1e0bac31698e489d987f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac0fb26ecfc1e0bac31698e489d987f0">&#9670;&#160;</a></span>key_compare</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::key_compare = Compare</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af8f59d8436d8bd927950a2875f61853b" name="af8f59d8436d8bd927950a2875f61853b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8f59d8436d8bd927950a2875f61853b">&#9670;&#160;</a></span>key_equal</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::key_equal = typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#a69a00efe0c98e7d89d3eeb8ef5e43190">ht::key_equal</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a42dce508be37a6f7b694f8a18ee5554d" name="a42dce508be37a6f7b694f8a18ee5554d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42dce508be37a6f7b694f8a18ee5554d">&#9670;&#160;</a></span>key_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::key_type = typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#ac2da7bb97307e334553fe9cba15d0689">ht::key_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a585def3f40eabb0b15b7a3ef6f004620" name="a585def3f40eabb0b15b7a3ef6f004620"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a585def3f40eabb0b15b7a3ef6f004620">&#9670;&#160;</a></span>overflow_container_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::overflow_container_type = std::set&lt;Key, Compare, Allocator&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a51909220f65b79bbe625c4cf7349044f" name="a51909220f65b79bbe625c4cf7349044f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51909220f65b79bbe625c4cf7349044f">&#9670;&#160;</a></span>pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::pointer = typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#a31276a8ba5b00732857fd0267a5b6fdd">ht::pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1030ac167086de9041220f2f6dd1d3c8" name="a1030ac167086de9041220f2f6dd1d3c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1030ac167086de9041220f2f6dd1d3c8">&#9670;&#160;</a></span>reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::reference = typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#a257bb0ff019c2756bc2c192e76f31ce5">ht::reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adfe28f55c3c51048b90c94f95e70b254" name="adfe28f55c3c51048b90c94f95e70b254"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfe28f55c3c51048b90c94f95e70b254">&#9670;&#160;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::size_type = typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#a0f2a8dda76d11a1531be2c2e7fb82061">ht::size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5dba07d4206217a586ec8b10674d0788" name="a5dba07d4206217a586ec8b10674d0788"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dba07d4206217a586ec8b10674d0788">&#9670;&#160;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::value_type = typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#afed3e1f425ac47050c9d8b96c2c5e319">ht::value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a7acfc31d931c6734560ce98eb0ceb020" name="a7acfc31d931c6734560ce98eb0ceb020"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7acfc31d931c6734560ce98eb0ceb020">&#9670;&#160;</a></span>bhopscotch_set() <span class="overload">[1/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::bhopscotch_set </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5d4ee2b86bca361d3ecf68a379e9b605" name="a5d4ee2b86bca361d3ecf68a379e9b605"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d4ee2b86bca361d3ecf68a379e9b605">&#9670;&#160;</a></span>bhopscotch_set() <span class="overload">[2/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::bhopscotch_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#adfe28f55c3c51048b90c94f95e70b254">size_type</a></td>          <td class="paramname"><span class="paramname"><em>bucket_count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Hash &amp;</td>          <td class="paramname"><span class="paramname"><em>hash</em></span><span class="paramdefsep"> = </span><span class="paramdefval">Hash()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyEqual &amp;</td>          <td class="paramname"><span class="paramname"><em>equal</em></span><span class="paramdefsep"> = </span><span class="paramdefval">KeyEqual()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span><span class="paramdefsep"> = </span><span class="paramdefval">Allocator()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Compare &amp;</td>          <td class="paramname"><span class="paramname"><em>comp</em></span><span class="paramdefsep"> = </span><span class="paramdefval">Compare()</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a574c7d0e981cbb9a08f24ab857dc312a" name="a574c7d0e981cbb9a08f24ab857dc312a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a574c7d0e981cbb9a08f24ab857dc312a">&#9670;&#160;</a></span>bhopscotch_set() <span class="overload">[3/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::bhopscotch_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#adfe28f55c3c51048b90c94f95e70b254">size_type</a></td>          <td class="paramname"><span class="paramname"><em>bucket_count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af77904a0a6b0162bb6ba9ff97b695d28" name="af77904a0a6b0162bb6ba9ff97b695d28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af77904a0a6b0162bb6ba9ff97b695d28">&#9670;&#160;</a></span>bhopscotch_set() <span class="overload">[4/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::bhopscotch_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#adfe28f55c3c51048b90c94f95e70b254">size_type</a></td>          <td class="paramname"><span class="paramname"><em>bucket_count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Hash &amp;</td>          <td class="paramname"><span class="paramname"><em>hash</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a950059296854a10a45595e9adeb45eed" name="a950059296854a10a45595e9adeb45eed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a950059296854a10a45595e9adeb45eed">&#9670;&#160;</a></span>bhopscotch_set() <span class="overload">[5/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::bhopscotch_set </td>
          <td>(</td>
          <td class="paramtype">const Allocator &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a82b9231383d44c81acd80284dcc07fea" name="a82b9231383d44c81acd80284dcc07fea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82b9231383d44c81acd80284dcc07fea">&#9670;&#160;</a></span>bhopscotch_set() <span class="overload">[6/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::bhopscotch_set </td>
          <td>(</td>
          <td class="paramtype">InputIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#adfe28f55c3c51048b90c94f95e70b254">size_type</a></td>          <td class="paramname"><span class="paramname"><em>bucket_count</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#a3b4d20d3ff76dd7e703bb18368332368">ht::DEFAULT_INIT_BUCKETS_SIZE</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Hash &amp;</td>          <td class="paramname"><span class="paramname"><em>hash</em></span><span class="paramdefsep"> = </span><span class="paramdefval">Hash()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyEqual &amp;</td>          <td class="paramname"><span class="paramname"><em>equal</em></span><span class="paramdefsep"> = </span><span class="paramdefval">KeyEqual()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span><span class="paramdefsep"> = </span><span class="paramdefval">Allocator()</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a090cd853b3222206338b823476ef258b" name="a090cd853b3222206338b823476ef258b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a090cd853b3222206338b823476ef258b">&#9670;&#160;</a></span>bhopscotch_set() <span class="overload">[7/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::bhopscotch_set </td>
          <td>(</td>
          <td class="paramtype">InputIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#adfe28f55c3c51048b90c94f95e70b254">size_type</a></td>          <td class="paramname"><span class="paramname"><em>bucket_count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa240c3bf9bbc2e4426faabae830651fd" name="aa240c3bf9bbc2e4426faabae830651fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa240c3bf9bbc2e4426faabae830651fd">&#9670;&#160;</a></span>bhopscotch_set() <span class="overload">[8/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::bhopscotch_set </td>
          <td>(</td>
          <td class="paramtype">InputIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#adfe28f55c3c51048b90c94f95e70b254">size_type</a></td>          <td class="paramname"><span class="paramname"><em>bucket_count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Hash &amp;</td>          <td class="paramname"><span class="paramname"><em>hash</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab1b7077d7a0ab6ad36ecb38ab9bff26e" name="ab1b7077d7a0ab6ad36ecb38ab9bff26e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1b7077d7a0ab6ad36ecb38ab9bff26e">&#9670;&#160;</a></span>bhopscotch_set() <span class="overload">[9/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::bhopscotch_set </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="#a5dba07d4206217a586ec8b10674d0788">value_type</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>init</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#adfe28f55c3c51048b90c94f95e70b254">size_type</a></td>          <td class="paramname"><span class="paramname"><em>bucket_count</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#a3b4d20d3ff76dd7e703bb18368332368">ht::DEFAULT_INIT_BUCKETS_SIZE</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Hash &amp;</td>          <td class="paramname"><span class="paramname"><em>hash</em></span><span class="paramdefsep"> = </span><span class="paramdefval">Hash()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyEqual &amp;</td>          <td class="paramname"><span class="paramname"><em>equal</em></span><span class="paramdefsep"> = </span><span class="paramdefval">KeyEqual()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span><span class="paramdefsep"> = </span><span class="paramdefval">Allocator()</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aaa84c4d8419c0b22f5d7fbdd482e14f2" name="aaa84c4d8419c0b22f5d7fbdd482e14f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa84c4d8419c0b22f5d7fbdd482e14f2">&#9670;&#160;</a></span>bhopscotch_set() <span class="overload">[10/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::bhopscotch_set </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="#a5dba07d4206217a586ec8b10674d0788">value_type</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>init</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#adfe28f55c3c51048b90c94f95e70b254">size_type</a></td>          <td class="paramname"><span class="paramname"><em>bucket_count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0ac5998651c113d85cb329bfc182b2a0" name="a0ac5998651c113d85cb329bfc182b2a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ac5998651c113d85cb329bfc182b2a0">&#9670;&#160;</a></span>bhopscotch_set() <span class="overload">[11/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::bhopscotch_set </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="#a5dba07d4206217a586ec8b10674d0788">value_type</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>init</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#adfe28f55c3c51048b90c94f95e70b254">size_type</a></td>          <td class="paramname"><span class="paramname"><em>bucket_count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Hash &amp;</td>          <td class="paramname"><span class="paramname"><em>hash</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="a6371fa450b064e2854889cbcecc7b51f" name="a6371fa450b064e2854889cbcecc7b51f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6371fa450b064e2854889cbcecc7b51f">&#9670;&#160;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#acca0be5d2184d2a03d6bbe3ab2c349e4">const_iterator</a> <a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::begin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6cb58244769bc1bf969c8b836fa3a1d9" name="a6cb58244769bc1bf969c8b836fa3a1d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cb58244769bc1bf969c8b836fa3a1d9">&#9670;&#160;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#aabc10d644f92fc6b16707b8da6d250a9">iterator</a> <a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::begin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a48f085051bacbb4f8a713207ce750a2e" name="a48f085051bacbb4f8a713207ce750a2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48f085051bacbb4f8a713207ce750a2e">&#9670;&#160;</a></span>bucket_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#adfe28f55c3c51048b90c94f95e70b254">size_type</a> <a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::bucket_count </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6c65031364d0eacfc7676c05a467bb16" name="a6c65031364d0eacfc7676c05a467bb16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c65031364d0eacfc7676c05a467bb16">&#9670;&#160;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#acca0be5d2184d2a03d6bbe3ab2c349e4">const_iterator</a> <a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3f015877d2d4806cbf77ffbcc4dfe415" name="a3f015877d2d4806cbf77ffbcc4dfe415"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f015877d2d4806cbf77ffbcc4dfe415">&#9670;&#160;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#acca0be5d2184d2a03d6bbe3ab2c349e4">const_iterator</a> <a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::cend </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afbf2da17736f2f821c793f471a7e42b1" name="afbf2da17736f2f821c793f471a7e42b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbf2da17736f2f821c793f471a7e42b1">&#9670;&#160;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::clear </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af05774a8f798a1e678d9ce0cb265378a" name="af05774a8f798a1e678d9ce0cb265378a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af05774a8f798a1e678d9ce0cb265378a">&#9670;&#160;</a></span>contains() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class K, class KE = KeyEqual, typename std::enable_if&lt; <a class="el" href="#a5e1654919c2609c7501081a2749ac1c5">has_is_transparent</a>&lt; KE &gt;::value &gt;::type * = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const K &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. If so, K must be hashable and comparable to Key. </p>

</div>
</div>
<a id="a68d1447d74c1059b4b2cf586567db401" name="a68d1447d74c1059b4b2cf586567db401"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68d1447d74c1059b4b2cf586567db401">&#9670;&#160;</a></span>contains() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class K, class KE = KeyEqual, typename std::enable_if&lt; <a class="el" href="#a5e1654919c2609c7501081a2749ac1c5">has_is_transparent</a>&lt; KE &gt;::value &gt;::type * = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const K &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>precalculated_hash</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. If so, K must be hashable and comparable to Key.   </p>
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="#a72cfd16bbab23d7cc42585d7e1d7e32a">hash_function()</a>(key). Useful to speed-up the lookup if you already have the hash. </p>

</div>
</div>
<a id="a0c9d13caa0cd0f0fd05c4d5d25eb256e" name="a0c9d13caa0cd0f0fd05c4d5d25eb256e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c9d13caa0cd0f0fd05c4d5d25eb256e">&#9670;&#160;</a></span>contains() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afea5c514821124b77ff62571a3921502" name="afea5c514821124b77ff62571a3921502"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afea5c514821124b77ff62571a3921502">&#9670;&#160;</a></span>contains() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>precalculated_hash</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="#a72cfd16bbab23d7cc42585d7e1d7e32a">hash_function()</a>(key). Useful to speed-up the lookup if you already have the hash. </p>

</div>
</div>
<a id="a0c525cd0d5d5d5df8206129d801335ae" name="a0c525cd0d5d5d5df8206129d801335ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c525cd0d5d5d5df8206129d801335ae">&#9670;&#160;</a></span>count() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class K, class KE = KeyEqual, class CP = Compare, typename std::enable_if&lt; <a class="el" href="#a5e1654919c2609c7501081a2749ac1c5">has_is_transparent</a>&lt; KE &gt;::value &amp;&amp;<a class="el" href="#a5e1654919c2609c7501081a2749ac1c5">has_is_transparent</a>&lt; CP &gt;::value &gt;::type * = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#adfe28f55c3c51048b90c94f95e70b254">size_type</a> <a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const K &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent and Compare::is_transparent exist. If so, K must be hashable and comparable to Key. </p>

</div>
</div>
<a id="a6fc3b54f32756523f84e476e8e613dc3" name="a6fc3b54f32756523f84e476e8e613dc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fc3b54f32756523f84e476e8e613dc3">&#9670;&#160;</a></span>count() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class K, class KE = KeyEqual, class CP = Compare, typename std::enable_if&lt; <a class="el" href="#a5e1654919c2609c7501081a2749ac1c5">has_is_transparent</a>&lt; KE &gt;::value &amp;&amp;<a class="el" href="#a5e1654919c2609c7501081a2749ac1c5">has_is_transparent</a>&lt; CP &gt;::value &gt;::type * = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#adfe28f55c3c51048b90c94f95e70b254">size_type</a> <a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const K &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>precalculated_hash</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent and Compare::is_transparent exist. If so, K must be hashable and comparable to Key.   </p>
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="#a72cfd16bbab23d7cc42585d7e1d7e32a">hash_function()</a>(key). Useful to speed-up the lookup if you already have the hash. </p>

</div>
</div>
<a id="a089e2f4437d910b3ef0a2b526c5c7886" name="a089e2f4437d910b3ef0a2b526c5c7886"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a089e2f4437d910b3ef0a2b526c5c7886">&#9670;&#160;</a></span>count() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#adfe28f55c3c51048b90c94f95e70b254">size_type</a> <a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a692d5e11d474d8bfaf77ceae652bd1f8" name="a692d5e11d474d8bfaf77ceae652bd1f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a692d5e11d474d8bfaf77ceae652bd1f8">&#9670;&#160;</a></span>count() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#adfe28f55c3c51048b90c94f95e70b254">size_type</a> <a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>precalculated_hash</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="#a72cfd16bbab23d7cc42585d7e1d7e32a">hash_function()</a>(key). Useful to speed-up the lookup if you already have the hash. </p>

</div>
</div>
<a id="aa3672ffc92587dfd78809da10bc84159" name="aa3672ffc92587dfd78809da10bc84159"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3672ffc92587dfd78809da10bc84159">&#9670;&#160;</a></span>emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="#aabc10d644f92fc6b16707b8da6d250a9">iterator</a>, bool &gt; <a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Due to the way elements are stored, emplace will need to move or copy the key-value once. The method is equivalent to insert(<a class="el" href="#a5dba07d4206217a586ec8b10674d0788">value_type(std::forward&lt;Args&gt;(args)...)</a>);</p>
<p>Mainly here for compatibility with the std::unordered_map interface. </p>

</div>
</div>
<a id="a6ccd3deac1c065d6736ea059b43e8944" name="a6ccd3deac1c065d6736ea059b43e8944"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ccd3deac1c065d6736ea059b43e8944">&#9670;&#160;</a></span>emplace_hint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#aabc10d644f92fc6b16707b8da6d250a9">iterator</a> <a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::emplace_hint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#acca0be5d2184d2a03d6bbe3ab2c349e4">const_iterator</a></td>          <td class="paramname"><span class="paramname"><em>hint</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Due to the way elements are stored, emplace_hint will need to move or copy the key-value once. The method is equivalent to insert(hint, <a class="el" href="#a5dba07d4206217a586ec8b10674d0788">value_type(std::forward&lt;Args&gt;(args)...)</a>);</p>
<p>Mainly here for compatibility with the std::unordered_map interface. </p>

</div>
</div>
<a id="ad626f87d13e2f9894c6066c1f7726bac" name="ad626f87d13e2f9894c6066c1f7726bac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad626f87d13e2f9894c6066c1f7726bac">&#9670;&#160;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::empty </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aaf559ad9976188b9afc376e9412441b3" name="aaf559ad9976188b9afc376e9412441b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf559ad9976188b9afc376e9412441b3">&#9670;&#160;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#acca0be5d2184d2a03d6bbe3ab2c349e4">const_iterator</a> <a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::end </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac8ae42547785e9acbd445dc6a236fc85" name="ac8ae42547785e9acbd445dc6a236fc85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8ae42547785e9acbd445dc6a236fc85">&#9670;&#160;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#aabc10d644f92fc6b16707b8da6d250a9">iterator</a> <a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::end </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a860951a8d60de66991484e60e3188a6e" name="a860951a8d60de66991484e60e3188a6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a860951a8d60de66991484e60e3188a6e">&#9670;&#160;</a></span>equal_range() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class K, class KE = KeyEqual, class CP = Compare, typename std::enable_if&lt; <a class="el" href="#a5e1654919c2609c7501081a2749ac1c5">has_is_transparent</a>&lt; KE &gt;::value &amp;&amp;<a class="el" href="#a5e1654919c2609c7501081a2749ac1c5">has_is_transparent</a>&lt; CP &gt;::value &gt;::type * = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="#aabc10d644f92fc6b16707b8da6d250a9">iterator</a>, <a class="el" href="#aabc10d644f92fc6b16707b8da6d250a9">iterator</a> &gt; <a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const K &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent and Compare::is_transparent exist. If so, K must be hashable and comparable to Key. </p>

</div>
</div>
<a id="a37874de45adbd5bd3a3f4853c0881dbc" name="a37874de45adbd5bd3a3f4853c0881dbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37874de45adbd5bd3a3f4853c0881dbc">&#9670;&#160;</a></span>equal_range() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class K, class KE = KeyEqual, class CP = Compare, typename std::enable_if&lt; <a class="el" href="#a5e1654919c2609c7501081a2749ac1c5">has_is_transparent</a>&lt; KE &gt;::value &amp;&amp;<a class="el" href="#a5e1654919c2609c7501081a2749ac1c5">has_is_transparent</a>&lt; CP &gt;::value &gt;::type * = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="#acca0be5d2184d2a03d6bbe3ab2c349e4">const_iterator</a>, <a class="el" href="#acca0be5d2184d2a03d6bbe3ab2c349e4">const_iterator</a> &gt; <a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const K &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent and Compare::is_transparent exist. If so, K must be hashable and comparable to Key.    </p>

</div>
</div>
<a id="ab2d09cb4aa700bc3f60db84a1a0ce345" name="ab2d09cb4aa700bc3f60db84a1a0ce345"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2d09cb4aa700bc3f60db84a1a0ce345">&#9670;&#160;</a></span>equal_range() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class K, class KE = KeyEqual, class CP = Compare, typename std::enable_if&lt; <a class="el" href="#a5e1654919c2609c7501081a2749ac1c5">has_is_transparent</a>&lt; KE &gt;::value &amp;&amp;<a class="el" href="#a5e1654919c2609c7501081a2749ac1c5">has_is_transparent</a>&lt; CP &gt;::value &gt;::type * = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="#aabc10d644f92fc6b16707b8da6d250a9">iterator</a>, <a class="el" href="#aabc10d644f92fc6b16707b8da6d250a9">iterator</a> &gt; <a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const K &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>precalculated_hash</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent and Compare::is_transparent exist. If so, K must be hashable and comparable to Key.   </p>
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="#a72cfd16bbab23d7cc42585d7e1d7e32a">hash_function()</a>(key). Useful to speed-up the lookup if you already have the hash. </p>

</div>
</div>
<a id="afb65abd98e17d7d4cb38f212ae65d280" name="afb65abd98e17d7d4cb38f212ae65d280"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb65abd98e17d7d4cb38f212ae65d280">&#9670;&#160;</a></span>equal_range() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class K, class KE = KeyEqual, class CP = Compare, typename std::enable_if&lt; <a class="el" href="#a5e1654919c2609c7501081a2749ac1c5">has_is_transparent</a>&lt; KE &gt;::value &amp;&amp;<a class="el" href="#a5e1654919c2609c7501081a2749ac1c5">has_is_transparent</a>&lt; CP &gt;::value &gt;::type * = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="#acca0be5d2184d2a03d6bbe3ab2c349e4">const_iterator</a>, <a class="el" href="#acca0be5d2184d2a03d6bbe3ab2c349e4">const_iterator</a> &gt; <a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const K &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>precalculated_hash</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent and Compare::is_transparent exist. If so, K must be hashable and comparable to Key.   </p>
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="#a72cfd16bbab23d7cc42585d7e1d7e32a">hash_function()</a>(key). Useful to speed-up the lookup if you already have the hash.    </p>

</div>
</div>
<a id="a426d3f59a083fa4a42d9be8552ddc6c3" name="a426d3f59a083fa4a42d9be8552ddc6c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a426d3f59a083fa4a42d9be8552ddc6c3">&#9670;&#160;</a></span>equal_range() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="#aabc10d644f92fc6b16707b8da6d250a9">iterator</a>, <a class="el" href="#aabc10d644f92fc6b16707b8da6d250a9">iterator</a> &gt; <a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4c8c453741e0c78e3bc755076d9c2ba0" name="a4c8c453741e0c78e3bc755076d9c2ba0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c8c453741e0c78e3bc755076d9c2ba0">&#9670;&#160;</a></span>equal_range() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="#acca0be5d2184d2a03d6bbe3ab2c349e4">const_iterator</a>, <a class="el" href="#acca0be5d2184d2a03d6bbe3ab2c349e4">const_iterator</a> &gt; <a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a74e0f5b38221fc99a20f3e461bc2e048" name="a74e0f5b38221fc99a20f3e461bc2e048"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74e0f5b38221fc99a20f3e461bc2e048">&#9670;&#160;</a></span>equal_range() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="#aabc10d644f92fc6b16707b8da6d250a9">iterator</a>, <a class="el" href="#aabc10d644f92fc6b16707b8da6d250a9">iterator</a> &gt; <a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>precalculated_hash</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="#a72cfd16bbab23d7cc42585d7e1d7e32a">hash_function()</a>(key). Useful to speed-up the lookup if you already have the hash. </p>

</div>
</div>
<a id="a37d5822b859c49a58c2d5b5ec6889e28" name="a37d5822b859c49a58c2d5b5ec6889e28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37d5822b859c49a58c2d5b5ec6889e28">&#9670;&#160;</a></span>equal_range() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="#acca0be5d2184d2a03d6bbe3ab2c349e4">const_iterator</a>, <a class="el" href="#acca0be5d2184d2a03d6bbe3ab2c349e4">const_iterator</a> &gt; <a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>precalculated_hash</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="#a72cfd16bbab23d7cc42585d7e1d7e32a">hash_function()</a>(key). Useful to speed-up the lookup if you already have the hash.    </p>

</div>
</div>
<a id="a3bcf1322a7cca63005e3813c131e6f02" name="a3bcf1322a7cca63005e3813c131e6f02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bcf1322a7cca63005e3813c131e6f02">&#9670;&#160;</a></span>erase() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class K, class KE = KeyEqual, class CP = Compare, typename std::enable_if&lt; <a class="el" href="#a5e1654919c2609c7501081a2749ac1c5">has_is_transparent</a>&lt; KE &gt;::value &amp;&amp;<a class="el" href="#a5e1654919c2609c7501081a2749ac1c5">has_is_transparent</a>&lt; CP &gt;::value &gt;::type * = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#adfe28f55c3c51048b90c94f95e70b254">size_type</a> <a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const K &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent and Compare::is_transparent exist. If so, K must be hashable and comparable to Key. </p>

</div>
</div>
<a id="a39b9600bf6e08dc0dfb530d7e9cfd369" name="a39b9600bf6e08dc0dfb530d7e9cfd369"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39b9600bf6e08dc0dfb530d7e9cfd369">&#9670;&#160;</a></span>erase() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class K, class KE = KeyEqual, class CP = Compare, typename std::enable_if&lt; <a class="el" href="#a5e1654919c2609c7501081a2749ac1c5">has_is_transparent</a>&lt; KE &gt;::value &amp;&amp;<a class="el" href="#a5e1654919c2609c7501081a2749ac1c5">has_is_transparent</a>&lt; CP &gt;::value &gt;::type * = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#adfe28f55c3c51048b90c94f95e70b254">size_type</a> <a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const K &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>precalculated_hash</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent and Compare::is_transparent exist. If so, K must be hashable and comparable to Key.   </p>
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="#a72cfd16bbab23d7cc42585d7e1d7e32a">hash_function()</a>(key). Useful to speed-up the lookup to the value if you already have the hash. </p>

</div>
</div>
<a id="ab049877cdfbe936177841d35a864a05f" name="ab049877cdfbe936177841d35a864a05f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab049877cdfbe936177841d35a864a05f">&#9670;&#160;</a></span>erase() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#adfe28f55c3c51048b90c94f95e70b254">size_type</a> <a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a42dce508be37a6f7b694f8a18ee5554d">key_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a64a116b5e03bd75b3416444191f6894c" name="a64a116b5e03bd75b3416444191f6894c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64a116b5e03bd75b3416444191f6894c">&#9670;&#160;</a></span>erase() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#adfe28f55c3c51048b90c94f95e70b254">size_type</a> <a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a42dce508be37a6f7b694f8a18ee5554d">key_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>precalculated_hash</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="#a72cfd16bbab23d7cc42585d7e1d7e32a">hash_function()</a>(key). Useful to speed-up the lookup to the value if you already have the hash. </p>

</div>
</div>
<a id="a1f553a3ede0d4419f4d880c10fedf604" name="a1f553a3ede0d4419f4d880c10fedf604"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f553a3ede0d4419f4d880c10fedf604">&#9670;&#160;</a></span>erase() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#aabc10d644f92fc6b16707b8da6d250a9">iterator</a> <a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#acca0be5d2184d2a03d6bbe3ab2c349e4">const_iterator</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#acca0be5d2184d2a03d6bbe3ab2c349e4">const_iterator</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae1fb06cf0ef8e1b4834a088c12d168e9" name="ae1fb06cf0ef8e1b4834a088c12d168e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1fb06cf0ef8e1b4834a088c12d168e9">&#9670;&#160;</a></span>erase() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#aabc10d644f92fc6b16707b8da6d250a9">iterator</a> <a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#acca0be5d2184d2a03d6bbe3ab2c349e4">const_iterator</a></td>          <td class="paramname"><span class="paramname"><em>pos</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acbe3e5a929ed649cca1cadb314b676d7" name="acbe3e5a929ed649cca1cadb314b676d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbe3e5a929ed649cca1cadb314b676d7">&#9670;&#160;</a></span>erase() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#aabc10d644f92fc6b16707b8da6d250a9">iterator</a> <a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#aabc10d644f92fc6b16707b8da6d250a9">iterator</a></td>          <td class="paramname"><span class="paramname"><em>pos</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ace4907fe666af1d6a3bbb3172497938f" name="ace4907fe666af1d6a3bbb3172497938f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace4907fe666af1d6a3bbb3172497938f">&#9670;&#160;</a></span>find() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class K, class KE = KeyEqual, class CP = Compare, typename std::enable_if&lt; <a class="el" href="#a5e1654919c2609c7501081a2749ac1c5">has_is_transparent</a>&lt; KE &gt;::value &amp;&amp;<a class="el" href="#a5e1654919c2609c7501081a2749ac1c5">has_is_transparent</a>&lt; CP &gt;::value &gt;::type * = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#aabc10d644f92fc6b16707b8da6d250a9">iterator</a> <a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const K &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent and Compare::is_transparent exist. If so, K must be hashable and comparable to Key. </p>

</div>
</div>
<a id="abcf726c4ad38747d13222cadbd7ee8ea" name="abcf726c4ad38747d13222cadbd7ee8ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcf726c4ad38747d13222cadbd7ee8ea">&#9670;&#160;</a></span>find() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class K, class KE = KeyEqual, class CP = Compare, typename std::enable_if&lt; <a class="el" href="#a5e1654919c2609c7501081a2749ac1c5">has_is_transparent</a>&lt; KE &gt;::value &amp;&amp;<a class="el" href="#a5e1654919c2609c7501081a2749ac1c5">has_is_transparent</a>&lt; CP &gt;::value &gt;::type * = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#acca0be5d2184d2a03d6bbe3ab2c349e4">const_iterator</a> <a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const K &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent and Compare::is_transparent exist. If so, K must be hashable and comparable to Key.    </p>

</div>
</div>
<a id="a4335d819addfe1b41c6b6f8d84bc8a5b" name="a4335d819addfe1b41c6b6f8d84bc8a5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4335d819addfe1b41c6b6f8d84bc8a5b">&#9670;&#160;</a></span>find() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class K, class KE = KeyEqual, class CP = Compare, typename std::enable_if&lt; <a class="el" href="#a5e1654919c2609c7501081a2749ac1c5">has_is_transparent</a>&lt; KE &gt;::value &amp;&amp;<a class="el" href="#a5e1654919c2609c7501081a2749ac1c5">has_is_transparent</a>&lt; CP &gt;::value &gt;::type * = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#aabc10d644f92fc6b16707b8da6d250a9">iterator</a> <a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const K &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>precalculated_hash</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent and Compare::is_transparent exist. If so, K must be hashable and comparable to Key.   </p>
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="#a72cfd16bbab23d7cc42585d7e1d7e32a">hash_function()</a>(key). Useful to speed-up the lookup if you already have the hash. </p>

</div>
</div>
<a id="a069de0d06bbc53fff3932254bfa72885" name="a069de0d06bbc53fff3932254bfa72885"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a069de0d06bbc53fff3932254bfa72885">&#9670;&#160;</a></span>find() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class K, class KE = KeyEqual, class CP = Compare, typename std::enable_if&lt; <a class="el" href="#a5e1654919c2609c7501081a2749ac1c5">has_is_transparent</a>&lt; KE &gt;::value &amp;&amp;<a class="el" href="#a5e1654919c2609c7501081a2749ac1c5">has_is_transparent</a>&lt; CP &gt;::value &gt;::type * = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#acca0be5d2184d2a03d6bbe3ab2c349e4">const_iterator</a> <a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const K &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>precalculated_hash</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent and Compare::is_transparent exist. If so, K must be hashable and comparable to Key.   </p>
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="#a72cfd16bbab23d7cc42585d7e1d7e32a">hash_function()</a>(key). Useful to speed-up the lookup if you already have the hash. </p>

</div>
</div>
<a id="a11f93a2f37653ca1a4992cf1b4c7f56a" name="a11f93a2f37653ca1a4992cf1b4c7f56a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11f93a2f37653ca1a4992cf1b4c7f56a">&#9670;&#160;</a></span>find() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#aabc10d644f92fc6b16707b8da6d250a9">iterator</a> <a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aca6d1de8e18672205787a41e072cf302" name="aca6d1de8e18672205787a41e072cf302"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca6d1de8e18672205787a41e072cf302">&#9670;&#160;</a></span>find() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#acca0be5d2184d2a03d6bbe3ab2c349e4">const_iterator</a> <a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adf9c72c01f33dc5e5c1febb3d7850596" name="adf9c72c01f33dc5e5c1febb3d7850596"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf9c72c01f33dc5e5c1febb3d7850596">&#9670;&#160;</a></span>find() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#aabc10d644f92fc6b16707b8da6d250a9">iterator</a> <a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>precalculated_hash</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="#a72cfd16bbab23d7cc42585d7e1d7e32a">hash_function()</a>(key). Useful to speed-up the lookup if you already have the hash. </p>

</div>
</div>
<a id="a90b9f52662f5160301ea2b33f21ef5a8" name="a90b9f52662f5160301ea2b33f21ef5a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90b9f52662f5160301ea2b33f21ef5a8">&#9670;&#160;</a></span>find() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#acca0be5d2184d2a03d6bbe3ab2c349e4">const_iterator</a> <a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>precalculated_hash</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="#a72cfd16bbab23d7cc42585d7e1d7e32a">hash_function()</a>(key). Useful to speed-up the lookup if you already have the hash.    </p>

</div>
</div>
<a id="a5387ca6d803a7d5459034b719004e286" name="a5387ca6d803a7d5459034b719004e286"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5387ca6d803a7d5459034b719004e286">&#9670;&#160;</a></span>get_allocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a593ea7b428b2a98d45b61ddb7d4412f0">allocator_type</a> <a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a72cfd16bbab23d7cc42585d7e1d7e32a" name="a72cfd16bbab23d7cc42585d7e1d7e32a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72cfd16bbab23d7cc42585d7e1d7e32a">&#9670;&#160;</a></span>hash_function()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a9abb25ad29802ea7f4b5739cf9d57c9f">hasher</a> <a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::hash_function </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a134e3ae1657332312404bd1210758a18" name="a134e3ae1657332312404bd1210758a18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a134e3ae1657332312404bd1210758a18">&#9670;&#160;</a></span>insert() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="#aabc10d644f92fc6b16707b8da6d250a9">iterator</a>, bool &gt; <a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a5dba07d4206217a586ec8b10674d0788">value_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa1c6e8b61239a029bbec5795c8ef98e1" name="aa1c6e8b61239a029bbec5795c8ef98e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1c6e8b61239a029bbec5795c8ef98e1">&#9670;&#160;</a></span>insert() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#aabc10d644f92fc6b16707b8da6d250a9">iterator</a> <a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#acca0be5d2184d2a03d6bbe3ab2c349e4">const_iterator</a></td>          <td class="paramname"><span class="paramname"><em>hint</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a5dba07d4206217a586ec8b10674d0788">value_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ada344d4394e3c2c61b447daed144fdec" name="ada344d4394e3c2c61b447daed144fdec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada344d4394e3c2c61b447daed144fdec">&#9670;&#160;</a></span>insert() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#aabc10d644f92fc6b16707b8da6d250a9">iterator</a> <a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#acca0be5d2184d2a03d6bbe3ab2c349e4">const_iterator</a></td>          <td class="paramname"><span class="paramname"><em>hint</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a5dba07d4206217a586ec8b10674d0788">value_type</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abbf3ef37d1b6c341b03ddc6446f6971d" name="abbf3ef37d1b6c341b03ddc6446f6971d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbf3ef37d1b6c341b03ddc6446f6971d">&#9670;&#160;</a></span>insert() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">InputIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a921bcb9a4da2eb3caa6dcb03b8654b4e" name="a921bcb9a4da2eb3caa6dcb03b8654b4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a921bcb9a4da2eb3caa6dcb03b8654b4e">&#9670;&#160;</a></span>insert() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="#a5dba07d4206217a586ec8b10674d0788">value_type</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>ilist</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3957015e5955fc553003bbfe225836a0" name="a3957015e5955fc553003bbfe225836a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3957015e5955fc553003bbfe225836a0">&#9670;&#160;</a></span>insert() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="#aabc10d644f92fc6b16707b8da6d250a9">iterator</a>, bool &gt; <a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a5dba07d4206217a586ec8b10674d0788">value_type</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af9d235af8175c7b14f712ada0aa71443" name="af9d235af8175c7b14f712ada0aa71443"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9d235af8175c7b14f712ada0aa71443">&#9670;&#160;</a></span>key_comp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#aac0fb26ecfc1e0bac31698e489d987f0">key_compare</a> <a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::key_comp </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aadf2cd4a08305f6ccdd2d1de362ee9ee" name="aadf2cd4a08305f6ccdd2d1de362ee9ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadf2cd4a08305f6ccdd2d1de362ee9ee">&#9670;&#160;</a></span>key_eq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#af8f59d8436d8bd927950a2875f61853b">key_equal</a> <a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::key_eq </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab8d6cf41b390f562d4af528a45e7e2d4" name="ab8d6cf41b390f562d4af528a45e7e2d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8d6cf41b390f562d4af528a45e7e2d4">&#9670;&#160;</a></span>load_factor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::load_factor </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a33ab8fed34703417ab024c664dfe4ccc" name="a33ab8fed34703417ab024c664dfe4ccc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33ab8fed34703417ab024c664dfe4ccc">&#9670;&#160;</a></span>max_bucket_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#adfe28f55c3c51048b90c94f95e70b254">size_type</a> <a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::max_bucket_count </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa8dc6419d907972a53b1f8dc68d2e4c8" name="aa8dc6419d907972a53b1f8dc68d2e4c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8dc6419d907972a53b1f8dc68d2e4c8">&#9670;&#160;</a></span>max_load_factor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::max_load_factor </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af7b4c99c39b415127636ffd46815b32f" name="af7b4c99c39b415127636ffd46815b32f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7b4c99c39b415127636ffd46815b32f">&#9670;&#160;</a></span>max_load_factor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::max_load_factor </td>
          <td>(</td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>ml</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1f4017a11298fe2940f0162b1164173b" name="a1f4017a11298fe2940f0162b1164173b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f4017a11298fe2940f0162b1164173b">&#9670;&#160;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#adfe28f55c3c51048b90c94f95e70b254">size_type</a> <a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a019521464241af361a3709fe67269618" name="a019521464241af361a3709fe67269618"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a019521464241af361a3709fe67269618">&#9670;&#160;</a></span>mutable_iterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#aabc10d644f92fc6b16707b8da6d250a9">iterator</a> <a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::mutable_iterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#acca0be5d2184d2a03d6bbe3ab2c349e4">const_iterator</a></td>          <td class="paramname"><span class="paramname"><em>pos</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert a <a class="el" href="#acca0be5d2184d2a03d6bbe3ab2c349e4">const_iterator</a> to an iterator. </p>

</div>
</div>
<a id="a4d66683b0a2a7552ef4805735c8e8a30" name="a4d66683b0a2a7552ef4805735c8e8a30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d66683b0a2a7552ef4805735c8e8a30">&#9670;&#160;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1bhopscotch__set.html">bhopscotch_set</a> &amp; <a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="#a5dba07d4206217a586ec8b10674d0788">value_type</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>ilist</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a20b28747795deb75cfb6c8bfadeede56" name="a20b28747795deb75cfb6c8bfadeede56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20b28747795deb75cfb6c8bfadeede56">&#9670;&#160;</a></span>overflow_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#adfe28f55c3c51048b90c94f95e70b254">size_type</a> <a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::overflow_size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0efe9b0121ec9c8cb18a40663c0ddf71" name="a0efe9b0121ec9c8cb18a40663c0ddf71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0efe9b0121ec9c8cb18a40663c0ddf71">&#9670;&#160;</a></span>rehash()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::rehash </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#adfe28f55c3c51048b90c94f95e70b254">size_type</a></td>          <td class="paramname"><span class="paramname"><em>count_</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acaba32a2f9c6a8161dd64bffff0f783d" name="acaba32a2f9c6a8161dd64bffff0f783d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaba32a2f9c6a8161dd64bffff0f783d">&#9670;&#160;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#adfe28f55c3c51048b90c94f95e70b254">size_type</a></td>          <td class="paramname"><span class="paramname"><em>count_</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9604059a0f2cf4b950e4199e9d2d9192" name="a9604059a0f2cf4b950e4199e9d2d9192"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9604059a0f2cf4b950e4199e9d2d9192">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#adfe28f55c3c51048b90c94f95e70b254">size_type</a> <a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a566b0e12433024c3daa2fffefb030ce3" name="a566b0e12433024c3daa2fffefb030ce3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a566b0e12433024c3daa2fffefb030ce3">&#9670;&#160;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1bhopscotch__set.html">bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a name="doc-related-members" id="doc-related-members"></a><h2 id="header-doc-related-members" class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="a881b4c14f4b87d7566c05b752420e82f" name="a881b4c14f4b87d7566c05b752420e82f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a881b4c14f4b87d7566c05b752420e82f">&#9670;&#160;</a></span>operator!=</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtsl_1_1bhopscotch__set.html">bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtsl_1_1bhopscotch__set.html">bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel friend">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5874b4eefd2b1cd9f135e7a5b38daabd" name="a5874b4eefd2b1cd9f135e7a5b38daabd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5874b4eefd2b1cd9f135e7a5b38daabd">&#9670;&#160;</a></span>operator==</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtsl_1_1bhopscotch__set.html">bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtsl_1_1bhopscotch__set.html">bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel friend">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa7824d6ebb5065faea439641d2b59bd5" name="aa7824d6ebb5065faea439641d2b59bd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7824d6ebb5065faea439641d2b59bd5">&#9670;&#160;</a></span>swap</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1bhopscotch__set.html">bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtsl_1_1bhopscotch__set.html">bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel friend">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a name="doc-variable-members" id="doc-variable-members"></a><h2 id="header-doc-variable-members" class="groupheader">Member Data Documentation</h2>
<a id="a251f7c9cf2c158e26c4a81886cd8be22" name="a251f7c9cf2c158e26c4a81886cd8be22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a251f7c9cf2c158e26c4a81886cd8be22">&#9670;&#160;</a></span>m_ht</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#aa79eeeb4f32c31085422caa2023999c6">ht</a> <a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a>&lt; Key, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::m_ht</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/<a class="el" href="bhopscotch__set_8h_source.html">bhopscotch_set.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="namespacetsl.html">tsl</a></li><li class="navelem"><a href="classtsl_1_1bhopscotch__set.html">bhopscotch_set</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
