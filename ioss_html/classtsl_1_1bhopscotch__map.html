<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>IOSS: tsl::bhopscotch_map&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="CustomDoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">IOSS<span id="projectnumber">&#160;2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classtsl_1_1bhopscotch__map.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classtsl_1_1bhopscotch__map-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">tsl::bhopscotch_map&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="bhopscotch__map_8h_source.html">bhopscotch_map.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for tsl::bhopscotch_map&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="classtsl_1_1bhopscotch__map__coll__graph.svg" width="100%" height="521"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map_1_1KeySelect.html">KeySelect</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map_1_1ValueSelect.html">ValueSelect</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a37f4050e3fd3b6cff23b19f0ce484ee6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#a37f4050e3fd3b6cff23b19f0ce484ee6">key_type</a> = typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#ac2da7bb97307e334553fe9cba15d0689">ht::key_type</a></td></tr>
<tr class="separator:a37f4050e3fd3b6cff23b19f0ce484ee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7abce739cfeb17ff39fb1e55824babce"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#a7abce739cfeb17ff39fb1e55824babce">mapped_type</a> = T</td></tr>
<tr class="separator:a7abce739cfeb17ff39fb1e55824babce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bf237363f1ad38d96bcd496db330f3d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#a1bf237363f1ad38d96bcd496db330f3d">value_type</a> = typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#afed3e1f425ac47050c9d8b96c2c5e319">ht::value_type</a></td></tr>
<tr class="separator:a1bf237363f1ad38d96bcd496db330f3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95e38a2030bd61c1466a667daa74753f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#a95e38a2030bd61c1466a667daa74753f">size_type</a> = typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#a0f2a8dda76d11a1531be2c2e7fb82061">ht::size_type</a></td></tr>
<tr class="separator:a95e38a2030bd61c1466a667daa74753f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2564ea14d7b8b2f63e14946eff00107"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#ac2564ea14d7b8b2f63e14946eff00107">difference_type</a> = typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#a3a8a8e910088e7bdbfe63be530d31956">ht::difference_type</a></td></tr>
<tr class="separator:ac2564ea14d7b8b2f63e14946eff00107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab42531c264442155c69f6caf7ddd0f0d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#ab42531c264442155c69f6caf7ddd0f0d">hasher</a> = typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#a0ffe6a6aaa0794dcf4979fc23e583462">ht::hasher</a></td></tr>
<tr class="separator:ab42531c264442155c69f6caf7ddd0f0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad16fff74a2b4cfefbd97750f2207a668"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#ad16fff74a2b4cfefbd97750f2207a668">key_equal</a> = typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#a69a00efe0c98e7d89d3eeb8ef5e43190">ht::key_equal</a></td></tr>
<tr class="separator:ad16fff74a2b4cfefbd97750f2207a668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f1515ae04d28e8f21e0533b3723d10e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#a4f1515ae04d28e8f21e0533b3723d10e">key_compare</a> = Compare</td></tr>
<tr class="separator:a4f1515ae04d28e8f21e0533b3723d10e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73abd33b2c870e5400f7b22984f8fdac"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#a73abd33b2c870e5400f7b22984f8fdac">allocator_type</a> = typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#a8af583783f638a3faac62c52b876aa67">ht::allocator_type</a></td></tr>
<tr class="separator:a73abd33b2c870e5400f7b22984f8fdac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84aedb63b4be39af2078ca72e072214c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#a84aedb63b4be39af2078ca72e072214c">reference</a> = typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#a257bb0ff019c2756bc2c192e76f31ce5">ht::reference</a></td></tr>
<tr class="separator:a84aedb63b4be39af2078ca72e072214c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28138c0ee5419fa252b0296fb47ccacb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#a28138c0ee5419fa252b0296fb47ccacb">const_reference</a> = typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#ae45966f2a709f1d7f03d42cd19fb29ea">ht::const_reference</a></td></tr>
<tr class="separator:a28138c0ee5419fa252b0296fb47ccacb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eebdd0b0efe137c6f7737b56867e99a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#a7eebdd0b0efe137c6f7737b56867e99a">pointer</a> = typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#a31276a8ba5b00732857fd0267a5b6fdd">ht::pointer</a></td></tr>
<tr class="separator:a7eebdd0b0efe137c6f7737b56867e99a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d11911b0dca500c38d2a4d3eca7c963"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#a2d11911b0dca500c38d2a4d3eca7c963">const_pointer</a> = typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#a85e8fb0e24e28aef2c0ec4ce9e3f9d01">ht::const_pointer</a></td></tr>
<tr class="separator:a2d11911b0dca500c38d2a4d3eca7c963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a966956276ea45c7c32d1bc6bd97b1b79"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#a966956276ea45c7c32d1bc6bd97b1b79">iterator</a> = typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#ab697c644e6dec536d6ab028ba085b591">ht::iterator</a></td></tr>
<tr class="separator:a966956276ea45c7c32d1bc6bd97b1b79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e21f04e9276cdeceb1087131db03fcc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#a3e21f04e9276cdeceb1087131db03fcc">const_iterator</a> = typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#a2af6f88c2b254b2c9ff83c70eea7c952">ht::const_iterator</a></td></tr>
<tr class="separator:a3e21f04e9276cdeceb1087131db03fcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4d1d208a0593483278443719b2ce94b9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#a4d1d208a0593483278443719b2ce94b9">bhopscotch_map</a> ()</td></tr>
<tr class="separator:a4d1d208a0593483278443719b2ce94b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a63cf9630c0b389b98691a48c077b4f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#a3a63cf9630c0b389b98691a48c077b4f">bhopscotch_map</a> (<a class="el" href="classtsl_1_1bhopscotch__map.html#a95e38a2030bd61c1466a667daa74753f">size_type</a> <a class="el" href="classtsl_1_1bhopscotch__map.html#ac387158a5710ce3d84a7b8bd2daa152e">bucket_count</a>, const Hash &amp;hash=Hash(), const KeyEqual &amp;equal=KeyEqual(), const Allocator &amp;alloc=Allocator(), const Compare &amp;comp=Compare())</td></tr>
<tr class="separator:a3a63cf9630c0b389b98691a48c077b4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a475b583d6c8e5119b9a3edc468215977"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#a475b583d6c8e5119b9a3edc468215977">bhopscotch_map</a> (<a class="el" href="classtsl_1_1bhopscotch__map.html#a95e38a2030bd61c1466a667daa74753f">size_type</a> <a class="el" href="classtsl_1_1bhopscotch__map.html#ac387158a5710ce3d84a7b8bd2daa152e">bucket_count</a>, const Allocator &amp;alloc)</td></tr>
<tr class="separator:a475b583d6c8e5119b9a3edc468215977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a380263a1e51e97d49722c9155be77a3f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#a380263a1e51e97d49722c9155be77a3f">bhopscotch_map</a> (<a class="el" href="classtsl_1_1bhopscotch__map.html#a95e38a2030bd61c1466a667daa74753f">size_type</a> <a class="el" href="classtsl_1_1bhopscotch__map.html#ac387158a5710ce3d84a7b8bd2daa152e">bucket_count</a>, const Hash &amp;hash, const Allocator &amp;alloc)</td></tr>
<tr class="separator:a380263a1e51e97d49722c9155be77a3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae63777c4ffd509ffe3a6f5c79280ac35"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#ae63777c4ffd509ffe3a6f5c79280ac35">bhopscotch_map</a> (const Allocator &amp;alloc)</td></tr>
<tr class="separator:ae63777c4ffd509ffe3a6f5c79280ac35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedc0c3217377afed0017998c5078438d"><td class="memTemplParams" colspan="2">template&lt;class InputIt &gt; </td></tr>
<tr class="memitem:aedc0c3217377afed0017998c5078438d"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#aedc0c3217377afed0017998c5078438d">bhopscotch_map</a> (InputIt first, InputIt last, <a class="el" href="classtsl_1_1bhopscotch__map.html#a95e38a2030bd61c1466a667daa74753f">size_type</a> <a class="el" href="classtsl_1_1bhopscotch__map.html#ac387158a5710ce3d84a7b8bd2daa152e">bucket_count</a>=<a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#a3b4d20d3ff76dd7e703bb18368332368">ht::DEFAULT_INIT_BUCKETS_SIZE</a>, const Hash &amp;hash=Hash(), const KeyEqual &amp;equal=KeyEqual(), const Allocator &amp;alloc=Allocator())</td></tr>
<tr class="separator:aedc0c3217377afed0017998c5078438d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd0eb57e7dfb1656fc70fa2584e6b904"><td class="memTemplParams" colspan="2">template&lt;class InputIt &gt; </td></tr>
<tr class="memitem:abd0eb57e7dfb1656fc70fa2584e6b904"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#abd0eb57e7dfb1656fc70fa2584e6b904">bhopscotch_map</a> (InputIt first, InputIt last, <a class="el" href="classtsl_1_1bhopscotch__map.html#a95e38a2030bd61c1466a667daa74753f">size_type</a> <a class="el" href="classtsl_1_1bhopscotch__map.html#ac387158a5710ce3d84a7b8bd2daa152e">bucket_count</a>, const Allocator &amp;alloc)</td></tr>
<tr class="separator:abd0eb57e7dfb1656fc70fa2584e6b904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99b6d51ca94e657654f5606546b01fb2"><td class="memTemplParams" colspan="2">template&lt;class InputIt &gt; </td></tr>
<tr class="memitem:a99b6d51ca94e657654f5606546b01fb2"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#a99b6d51ca94e657654f5606546b01fb2">bhopscotch_map</a> (InputIt first, InputIt last, <a class="el" href="classtsl_1_1bhopscotch__map.html#a95e38a2030bd61c1466a667daa74753f">size_type</a> <a class="el" href="classtsl_1_1bhopscotch__map.html#ac387158a5710ce3d84a7b8bd2daa152e">bucket_count</a>, const Hash &amp;hash, const Allocator &amp;alloc)</td></tr>
<tr class="separator:a99b6d51ca94e657654f5606546b01fb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac92a8e0ad2ec4e3acae3672373809ff6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#ac92a8e0ad2ec4e3acae3672373809ff6">bhopscotch_map</a> (std::initializer_list&lt; <a class="el" href="classtsl_1_1bhopscotch__map.html#a1bf237363f1ad38d96bcd496db330f3d">value_type</a> &gt; init, <a class="el" href="classtsl_1_1bhopscotch__map.html#a95e38a2030bd61c1466a667daa74753f">size_type</a> <a class="el" href="classtsl_1_1bhopscotch__map.html#ac387158a5710ce3d84a7b8bd2daa152e">bucket_count</a>=<a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#a3b4d20d3ff76dd7e703bb18368332368">ht::DEFAULT_INIT_BUCKETS_SIZE</a>, const Hash &amp;hash=Hash(), const KeyEqual &amp;equal=KeyEqual(), const Allocator &amp;alloc=Allocator())</td></tr>
<tr class="separator:ac92a8e0ad2ec4e3acae3672373809ff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eb73368b571503e6ad0f4972798c2b0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#a1eb73368b571503e6ad0f4972798c2b0">bhopscotch_map</a> (std::initializer_list&lt; <a class="el" href="classtsl_1_1bhopscotch__map.html#a1bf237363f1ad38d96bcd496db330f3d">value_type</a> &gt; init, <a class="el" href="classtsl_1_1bhopscotch__map.html#a95e38a2030bd61c1466a667daa74753f">size_type</a> <a class="el" href="classtsl_1_1bhopscotch__map.html#ac387158a5710ce3d84a7b8bd2daa152e">bucket_count</a>, const Allocator &amp;alloc)</td></tr>
<tr class="separator:a1eb73368b571503e6ad0f4972798c2b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77070809c6d80e07b426ea9f688d24a5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#a77070809c6d80e07b426ea9f688d24a5">bhopscotch_map</a> (std::initializer_list&lt; <a class="el" href="classtsl_1_1bhopscotch__map.html#a1bf237363f1ad38d96bcd496db330f3d">value_type</a> &gt; init, <a class="el" href="classtsl_1_1bhopscotch__map.html#a95e38a2030bd61c1466a667daa74753f">size_type</a> <a class="el" href="classtsl_1_1bhopscotch__map.html#ac387158a5710ce3d84a7b8bd2daa152e">bucket_count</a>, const Hash &amp;hash, const Allocator &amp;alloc)</td></tr>
<tr class="separator:a77070809c6d80e07b426ea9f688d24a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60ecb47e3223af63d15e664a6cce62ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1bhopscotch__map.html">bhopscotch_map</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#a60ecb47e3223af63d15e664a6cce62ed">operator=</a> (std::initializer_list&lt; <a class="el" href="classtsl_1_1bhopscotch__map.html#a1bf237363f1ad38d96bcd496db330f3d">value_type</a> &gt; ilist)</td></tr>
<tr class="separator:a60ecb47e3223af63d15e664a6cce62ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ad6c8106301e5f81e8f60ae1bd65e72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1bhopscotch__map.html#a73abd33b2c870e5400f7b22984f8fdac">allocator_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#a3ad6c8106301e5f81e8f60ae1bd65e72">get_allocator</a> () const</td></tr>
<tr class="separator:a3ad6c8106301e5f81e8f60ae1bd65e72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2920c5c7a84e213ac71864efae65c780"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1bhopscotch__map.html#a966956276ea45c7c32d1bc6bd97b1b79">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#a2920c5c7a84e213ac71864efae65c780">begin</a> () noexcept</td></tr>
<tr class="separator:a2920c5c7a84e213ac71864efae65c780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54f23345d910a98264355f83b3949eaa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1bhopscotch__map.html#a3e21f04e9276cdeceb1087131db03fcc">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#a54f23345d910a98264355f83b3949eaa">begin</a> () const noexcept</td></tr>
<tr class="separator:a54f23345d910a98264355f83b3949eaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77a1cfefe845d6a88db3fbb940bb442b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1bhopscotch__map.html#a3e21f04e9276cdeceb1087131db03fcc">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#a77a1cfefe845d6a88db3fbb940bb442b">cbegin</a> () const noexcept</td></tr>
<tr class="separator:a77a1cfefe845d6a88db3fbb940bb442b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a191d70224ca93946a06b86c7ed9dff71"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1bhopscotch__map.html#a966956276ea45c7c32d1bc6bd97b1b79">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#a191d70224ca93946a06b86c7ed9dff71">end</a> () noexcept</td></tr>
<tr class="separator:a191d70224ca93946a06b86c7ed9dff71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0375376cfa6f4d5ee2ed34ceb4ef6d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1bhopscotch__map.html#a3e21f04e9276cdeceb1087131db03fcc">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#ac0375376cfa6f4d5ee2ed34ceb4ef6d6">end</a> () const noexcept</td></tr>
<tr class="separator:ac0375376cfa6f4d5ee2ed34ceb4ef6d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad393eeb03469ac26d71561262da2fdd1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1bhopscotch__map.html#a3e21f04e9276cdeceb1087131db03fcc">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#ad393eeb03469ac26d71561262da2fdd1">cend</a> () const noexcept</td></tr>
<tr class="separator:ad393eeb03469ac26d71561262da2fdd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3954202be241086244999ba1d848445"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#ab3954202be241086244999ba1d848445">empty</a> () const noexcept</td></tr>
<tr class="separator:ab3954202be241086244999ba1d848445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a464a64a6c1be84e21b9147a170cdecbd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1bhopscotch__map.html#a95e38a2030bd61c1466a667daa74753f">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#a464a64a6c1be84e21b9147a170cdecbd">size</a> () const noexcept</td></tr>
<tr class="separator:a464a64a6c1be84e21b9147a170cdecbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16d3f0ecb64b15d13312022caa2d8692"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1bhopscotch__map.html#a95e38a2030bd61c1466a667daa74753f">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#a16d3f0ecb64b15d13312022caa2d8692">max_size</a> () const noexcept</td></tr>
<tr class="separator:a16d3f0ecb64b15d13312022caa2d8692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d1aecfc9203ab4f493ca6359a08cafa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#a5d1aecfc9203ab4f493ca6359a08cafa">clear</a> () noexcept</td></tr>
<tr class="separator:a5d1aecfc9203ab4f493ca6359a08cafa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abada02b355efe65206475041f140fa3d"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtsl_1_1bhopscotch__map.html#a966956276ea45c7c32d1bc6bd97b1b79">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#abada02b355efe65206475041f140fa3d">insert</a> (const <a class="el" href="classtsl_1_1bhopscotch__map.html#a1bf237363f1ad38d96bcd496db330f3d">value_type</a> &amp;value)</td></tr>
<tr class="separator:abada02b355efe65206475041f140fa3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3169572b83705c895446b03d65ead6bb"><td class="memTemplParams" colspan="2">template&lt;class P , typename std::enable_if&lt; std::is_constructible&lt; <a class="el" href="classtsl_1_1bhopscotch__map.html#a1bf237363f1ad38d96bcd496db330f3d">value_type</a>, P &amp;&amp; &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a3169572b83705c895446b03d65ead6bb"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtsl_1_1bhopscotch__map.html#a966956276ea45c7c32d1bc6bd97b1b79">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#a3169572b83705c895446b03d65ead6bb">insert</a> (P &amp;&amp;value)</td></tr>
<tr class="separator:a3169572b83705c895446b03d65ead6bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ba539fd94b46b876a39fba97aa1d12a"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtsl_1_1bhopscotch__map.html#a966956276ea45c7c32d1bc6bd97b1b79">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#a9ba539fd94b46b876a39fba97aa1d12a">insert</a> (<a class="el" href="classtsl_1_1bhopscotch__map.html#a1bf237363f1ad38d96bcd496db330f3d">value_type</a> &amp;&amp;value)</td></tr>
<tr class="separator:a9ba539fd94b46b876a39fba97aa1d12a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7060149d80fce367f33847a67b250316"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1bhopscotch__map.html#a966956276ea45c7c32d1bc6bd97b1b79">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#a7060149d80fce367f33847a67b250316">insert</a> (<a class="el" href="classtsl_1_1bhopscotch__map.html#a3e21f04e9276cdeceb1087131db03fcc">const_iterator</a> hint, const <a class="el" href="classtsl_1_1bhopscotch__map.html#a1bf237363f1ad38d96bcd496db330f3d">value_type</a> &amp;value)</td></tr>
<tr class="separator:a7060149d80fce367f33847a67b250316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c14bbaa59f7f9d8401388fac40f4893"><td class="memTemplParams" colspan="2">template&lt;class P , typename std::enable_if&lt; std::is_constructible&lt; <a class="el" href="classtsl_1_1bhopscotch__map.html#a1bf237363f1ad38d96bcd496db330f3d">value_type</a>, P &amp;&amp; &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a3c14bbaa59f7f9d8401388fac40f4893"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1bhopscotch__map.html#a966956276ea45c7c32d1bc6bd97b1b79">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#a3c14bbaa59f7f9d8401388fac40f4893">insert</a> (<a class="el" href="classtsl_1_1bhopscotch__map.html#a3e21f04e9276cdeceb1087131db03fcc">const_iterator</a> hint, P &amp;&amp;value)</td></tr>
<tr class="separator:a3c14bbaa59f7f9d8401388fac40f4893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5acb9e0360c62edc7095ce4bf74e48f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1bhopscotch__map.html#a966956276ea45c7c32d1bc6bd97b1b79">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#a5acb9e0360c62edc7095ce4bf74e48f5">insert</a> (<a class="el" href="classtsl_1_1bhopscotch__map.html#a3e21f04e9276cdeceb1087131db03fcc">const_iterator</a> hint, <a class="el" href="classtsl_1_1bhopscotch__map.html#a1bf237363f1ad38d96bcd496db330f3d">value_type</a> &amp;&amp;value)</td></tr>
<tr class="separator:a5acb9e0360c62edc7095ce4bf74e48f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf31932fdd34612150858fb8e968d70a"><td class="memTemplParams" colspan="2">template&lt;class InputIt &gt; </td></tr>
<tr class="memitem:acf31932fdd34612150858fb8e968d70a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#acf31932fdd34612150858fb8e968d70a">insert</a> (InputIt first, InputIt last)</td></tr>
<tr class="separator:acf31932fdd34612150858fb8e968d70a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab349856e33964291b82b5d020f4dabb0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#ab349856e33964291b82b5d020f4dabb0">insert</a> (std::initializer_list&lt; <a class="el" href="classtsl_1_1bhopscotch__map.html#a1bf237363f1ad38d96bcd496db330f3d">value_type</a> &gt; ilist)</td></tr>
<tr class="separator:ab349856e33964291b82b5d020f4dabb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb3c031a916848d3d8ebe096f9ece8c7"><td class="memTemplParams" colspan="2">template&lt;class M &gt; </td></tr>
<tr class="memitem:aeb3c031a916848d3d8ebe096f9ece8c7"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtsl_1_1bhopscotch__map.html#a966956276ea45c7c32d1bc6bd97b1b79">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#aeb3c031a916848d3d8ebe096f9ece8c7">insert_or_assign</a> (const <a class="el" href="classtsl_1_1bhopscotch__map.html#a37f4050e3fd3b6cff23b19f0ce484ee6">key_type</a> &amp;k, M &amp;&amp;obj)</td></tr>
<tr class="separator:aeb3c031a916848d3d8ebe096f9ece8c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9faab294df205ea0aadafb5a8a3519f3"><td class="memTemplParams" colspan="2">template&lt;class M &gt; </td></tr>
<tr class="memitem:a9faab294df205ea0aadafb5a8a3519f3"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtsl_1_1bhopscotch__map.html#a966956276ea45c7c32d1bc6bd97b1b79">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#a9faab294df205ea0aadafb5a8a3519f3">insert_or_assign</a> (<a class="el" href="classtsl_1_1bhopscotch__map.html#a37f4050e3fd3b6cff23b19f0ce484ee6">key_type</a> &amp;&amp;k, M &amp;&amp;obj)</td></tr>
<tr class="separator:a9faab294df205ea0aadafb5a8a3519f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ec35d7a79578bc8fab4aba840a50ae0"><td class="memTemplParams" colspan="2">template&lt;class M &gt; </td></tr>
<tr class="memitem:a4ec35d7a79578bc8fab4aba840a50ae0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1bhopscotch__map.html#a966956276ea45c7c32d1bc6bd97b1b79">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#a4ec35d7a79578bc8fab4aba840a50ae0">insert_or_assign</a> (<a class="el" href="classtsl_1_1bhopscotch__map.html#a3e21f04e9276cdeceb1087131db03fcc">const_iterator</a> hint, const <a class="el" href="classtsl_1_1bhopscotch__map.html#a37f4050e3fd3b6cff23b19f0ce484ee6">key_type</a> &amp;k, M &amp;&amp;obj)</td></tr>
<tr class="separator:a4ec35d7a79578bc8fab4aba840a50ae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a874a510023d13bdb98a11ead4c784c36"><td class="memTemplParams" colspan="2">template&lt;class M &gt; </td></tr>
<tr class="memitem:a874a510023d13bdb98a11ead4c784c36"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1bhopscotch__map.html#a966956276ea45c7c32d1bc6bd97b1b79">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#a874a510023d13bdb98a11ead4c784c36">insert_or_assign</a> (<a class="el" href="classtsl_1_1bhopscotch__map.html#a3e21f04e9276cdeceb1087131db03fcc">const_iterator</a> hint, <a class="el" href="classtsl_1_1bhopscotch__map.html#a37f4050e3fd3b6cff23b19f0ce484ee6">key_type</a> &amp;&amp;k, M &amp;&amp;obj)</td></tr>
<tr class="separator:a874a510023d13bdb98a11ead4c784c36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd25bb0731760f61d9d24640153f3802"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:acd25bb0731760f61d9d24640153f3802"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtsl_1_1bhopscotch__map.html#a966956276ea45c7c32d1bc6bd97b1b79">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#acd25bb0731760f61d9d24640153f3802">emplace</a> (Args &amp;&amp;...args)</td></tr>
<tr class="separator:acd25bb0731760f61d9d24640153f3802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a588be89fce26e4b82c222352e2b834f2"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a588be89fce26e4b82c222352e2b834f2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1bhopscotch__map.html#a966956276ea45c7c32d1bc6bd97b1b79">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#a588be89fce26e4b82c222352e2b834f2">emplace_hint</a> (<a class="el" href="classtsl_1_1bhopscotch__map.html#a3e21f04e9276cdeceb1087131db03fcc">const_iterator</a> hint, Args &amp;&amp;...args)</td></tr>
<tr class="separator:a588be89fce26e4b82c222352e2b834f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5387121f7ddeade189bdafa6fbc6155"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:aa5387121f7ddeade189bdafa6fbc6155"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtsl_1_1bhopscotch__map.html#a966956276ea45c7c32d1bc6bd97b1b79">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#aa5387121f7ddeade189bdafa6fbc6155">try_emplace</a> (const <a class="el" href="classtsl_1_1bhopscotch__map.html#a37f4050e3fd3b6cff23b19f0ce484ee6">key_type</a> &amp;k, Args &amp;&amp;...args)</td></tr>
<tr class="separator:aa5387121f7ddeade189bdafa6fbc6155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5b272b60b342066f71fe95e69ce8618"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:af5b272b60b342066f71fe95e69ce8618"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtsl_1_1bhopscotch__map.html#a966956276ea45c7c32d1bc6bd97b1b79">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#af5b272b60b342066f71fe95e69ce8618">try_emplace</a> (<a class="el" href="classtsl_1_1bhopscotch__map.html#a37f4050e3fd3b6cff23b19f0ce484ee6">key_type</a> &amp;&amp;k, Args &amp;&amp;...args)</td></tr>
<tr class="separator:af5b272b60b342066f71fe95e69ce8618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a144d9d36457b81936262929b3e0b1092"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a144d9d36457b81936262929b3e0b1092"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1bhopscotch__map.html#a966956276ea45c7c32d1bc6bd97b1b79">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#a144d9d36457b81936262929b3e0b1092">try_emplace</a> (<a class="el" href="classtsl_1_1bhopscotch__map.html#a3e21f04e9276cdeceb1087131db03fcc">const_iterator</a> hint, const <a class="el" href="classtsl_1_1bhopscotch__map.html#a37f4050e3fd3b6cff23b19f0ce484ee6">key_type</a> &amp;k, Args &amp;&amp;...args)</td></tr>
<tr class="separator:a144d9d36457b81936262929b3e0b1092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a186600c4f48a148225fc537a30e38aa3"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a186600c4f48a148225fc537a30e38aa3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1bhopscotch__map.html#a966956276ea45c7c32d1bc6bd97b1b79">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#a186600c4f48a148225fc537a30e38aa3">try_emplace</a> (<a class="el" href="classtsl_1_1bhopscotch__map.html#a3e21f04e9276cdeceb1087131db03fcc">const_iterator</a> hint, <a class="el" href="classtsl_1_1bhopscotch__map.html#a37f4050e3fd3b6cff23b19f0ce484ee6">key_type</a> &amp;&amp;k, Args &amp;&amp;...args)</td></tr>
<tr class="separator:a186600c4f48a148225fc537a30e38aa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a807d0d1c559348909b4ad90829c2a10a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1bhopscotch__map.html#a966956276ea45c7c32d1bc6bd97b1b79">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#a807d0d1c559348909b4ad90829c2a10a">erase</a> (<a class="el" href="classtsl_1_1bhopscotch__map.html#a966956276ea45c7c32d1bc6bd97b1b79">iterator</a> pos)</td></tr>
<tr class="separator:a807d0d1c559348909b4ad90829c2a10a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a723ea636975667bf8e916e315263f81c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1bhopscotch__map.html#a966956276ea45c7c32d1bc6bd97b1b79">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#a723ea636975667bf8e916e315263f81c">erase</a> (<a class="el" href="classtsl_1_1bhopscotch__map.html#a3e21f04e9276cdeceb1087131db03fcc">const_iterator</a> pos)</td></tr>
<tr class="separator:a723ea636975667bf8e916e315263f81c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef20287837433776ce2bcc76710c430e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1bhopscotch__map.html#a966956276ea45c7c32d1bc6bd97b1b79">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#aef20287837433776ce2bcc76710c430e">erase</a> (<a class="el" href="classtsl_1_1bhopscotch__map.html#a3e21f04e9276cdeceb1087131db03fcc">const_iterator</a> first, <a class="el" href="classtsl_1_1bhopscotch__map.html#a3e21f04e9276cdeceb1087131db03fcc">const_iterator</a> last)</td></tr>
<tr class="separator:aef20287837433776ce2bcc76710c430e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49562257e584d512bcb61ae0955ca5c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1bhopscotch__map.html#a95e38a2030bd61c1466a667daa74753f">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#a49562257e584d512bcb61ae0955ca5c3">erase</a> (const <a class="el" href="classtsl_1_1bhopscotch__map.html#a37f4050e3fd3b6cff23b19f0ce484ee6">key_type</a> &amp;key)</td></tr>
<tr class="separator:a49562257e584d512bcb61ae0955ca5c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2839fb38a941d484281332c2c14532aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1bhopscotch__map.html#a95e38a2030bd61c1466a667daa74753f">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#a2839fb38a941d484281332c2c14532aa">erase</a> (const <a class="el" href="classtsl_1_1bhopscotch__map.html#a37f4050e3fd3b6cff23b19f0ce484ee6">key_type</a> &amp;key, <a class="el" href="namespacestd.html#aa30247b5e1a6e192c486364692e37832">std::size_t</a> precalculated_hash)</td></tr>
<tr class="separator:a2839fb38a941d484281332c2c14532aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2fdbd0c173d0bcffe20d8590255cb1a"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, class CP  = Compare, typename std::enable_if&lt; <a class="el" href="classtsl_1_1bhopscotch__map.html#afe54106a1c0379005aca41a7ca47478a">has_is_transparent</a>&lt; KE &gt;::value &amp;&amp;<a class="el" href="classtsl_1_1bhopscotch__map.html#afe54106a1c0379005aca41a7ca47478a">has_is_transparent</a>&lt; CP &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ae2fdbd0c173d0bcffe20d8590255cb1a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1bhopscotch__map.html#a95e38a2030bd61c1466a667daa74753f">size_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#ae2fdbd0c173d0bcffe20d8590255cb1a">erase</a> (const K &amp;key)</td></tr>
<tr class="separator:ae2fdbd0c173d0bcffe20d8590255cb1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eaac48530be5fe69d6d6a03716bcb4f"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, class CP  = Compare, typename std::enable_if&lt; <a class="el" href="classtsl_1_1bhopscotch__map.html#afe54106a1c0379005aca41a7ca47478a">has_is_transparent</a>&lt; KE &gt;::value &amp;&amp;<a class="el" href="classtsl_1_1bhopscotch__map.html#afe54106a1c0379005aca41a7ca47478a">has_is_transparent</a>&lt; CP &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a9eaac48530be5fe69d6d6a03716bcb4f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1bhopscotch__map.html#a95e38a2030bd61c1466a667daa74753f">size_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#a9eaac48530be5fe69d6d6a03716bcb4f">erase</a> (const K &amp;key, <a class="el" href="namespacestd.html#aa30247b5e1a6e192c486364692e37832">std::size_t</a> precalculated_hash)</td></tr>
<tr class="separator:a9eaac48530be5fe69d6d6a03716bcb4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4af554c429a8167b52ba0d5074fdbc83"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#a4af554c429a8167b52ba0d5074fdbc83">swap</a> (<a class="el" href="classtsl_1_1bhopscotch__map.html">bhopscotch_map</a> &amp;other)</td></tr>
<tr class="separator:a4af554c429a8167b52ba0d5074fdbc83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c5ed58b57be3166d1d568cf2b1c9d42"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#a2c5ed58b57be3166d1d568cf2b1c9d42">at</a> (const Key &amp;key)</td></tr>
<tr class="separator:a2c5ed58b57be3166d1d568cf2b1c9d42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a961413c46ab73e25694f09ce171fe6b9"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#a961413c46ab73e25694f09ce171fe6b9">at</a> (const Key &amp;key, <a class="el" href="namespacestd.html#aa30247b5e1a6e192c486364692e37832">std::size_t</a> precalculated_hash)</td></tr>
<tr class="separator:a961413c46ab73e25694f09ce171fe6b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8885ca3e150665eeeb5de68ae0125da"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#af8885ca3e150665eeeb5de68ae0125da">at</a> (const Key &amp;key) const</td></tr>
<tr class="separator:af8885ca3e150665eeeb5de68ae0125da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a011baceef2dc6dcb5119bd1af2df38"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#a9a011baceef2dc6dcb5119bd1af2df38">at</a> (const Key &amp;key, <a class="el" href="namespacestd.html#aa30247b5e1a6e192c486364692e37832">std::size_t</a> precalculated_hash) const</td></tr>
<tr class="separator:a9a011baceef2dc6dcb5119bd1af2df38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1fe698668905b5144f1dc5852d6e689"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, class CP  = Compare, typename std::enable_if&lt; <a class="el" href="classtsl_1_1bhopscotch__map.html#afe54106a1c0379005aca41a7ca47478a">has_is_transparent</a>&lt; KE &gt;::value &amp;&amp;<a class="el" href="classtsl_1_1bhopscotch__map.html#afe54106a1c0379005aca41a7ca47478a">has_is_transparent</a>&lt; CP &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:af1fe698668905b5144f1dc5852d6e689"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#af1fe698668905b5144f1dc5852d6e689">at</a> (const K &amp;key)</td></tr>
<tr class="separator:af1fe698668905b5144f1dc5852d6e689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7afabc7f550d3550185aa0399e375443"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, class CP  = Compare, typename std::enable_if&lt; <a class="el" href="classtsl_1_1bhopscotch__map.html#afe54106a1c0379005aca41a7ca47478a">has_is_transparent</a>&lt; KE &gt;::value &amp;&amp;<a class="el" href="classtsl_1_1bhopscotch__map.html#afe54106a1c0379005aca41a7ca47478a">has_is_transparent</a>&lt; CP &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a7afabc7f550d3550185aa0399e375443"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#a7afabc7f550d3550185aa0399e375443">at</a> (const K &amp;key, <a class="el" href="namespacestd.html#aa30247b5e1a6e192c486364692e37832">std::size_t</a> precalculated_hash)</td></tr>
<tr class="separator:a7afabc7f550d3550185aa0399e375443"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c2ff9cfeecd1cf02485c97d806c4f38"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, class CP  = Compare, typename std::enable_if&lt; <a class="el" href="classtsl_1_1bhopscotch__map.html#afe54106a1c0379005aca41a7ca47478a">has_is_transparent</a>&lt; KE &gt;::value &amp;&amp;<a class="el" href="classtsl_1_1bhopscotch__map.html#afe54106a1c0379005aca41a7ca47478a">has_is_transparent</a>&lt; CP &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a3c2ff9cfeecd1cf02485c97d806c4f38"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#a3c2ff9cfeecd1cf02485c97d806c4f38">at</a> (const K &amp;key) const</td></tr>
<tr class="separator:a3c2ff9cfeecd1cf02485c97d806c4f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ec05e5365e823fd14e5c08e14b8bb0d"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, class CP  = Compare, typename std::enable_if&lt; <a class="el" href="classtsl_1_1bhopscotch__map.html#afe54106a1c0379005aca41a7ca47478a">has_is_transparent</a>&lt; KE &gt;::value &amp;&amp;<a class="el" href="classtsl_1_1bhopscotch__map.html#afe54106a1c0379005aca41a7ca47478a">has_is_transparent</a>&lt; CP &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a1ec05e5365e823fd14e5c08e14b8bb0d"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#a1ec05e5365e823fd14e5c08e14b8bb0d">at</a> (const K &amp;key, <a class="el" href="namespacestd.html#aa30247b5e1a6e192c486364692e37832">std::size_t</a> precalculated_hash) const</td></tr>
<tr class="separator:a1ec05e5365e823fd14e5c08e14b8bb0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a858f044e6b42f71df7b4bc253148a8f1"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#a858f044e6b42f71df7b4bc253148a8f1">operator[]</a> (const Key &amp;key)</td></tr>
<tr class="separator:a858f044e6b42f71df7b4bc253148a8f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e82aa2389f0e50809dc1ff00fd4649e"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#a1e82aa2389f0e50809dc1ff00fd4649e">operator[]</a> (Key &amp;&amp;key)</td></tr>
<tr class="separator:a1e82aa2389f0e50809dc1ff00fd4649e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c3254d704e4d0005b0db13258d3e699"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1bhopscotch__map.html#a95e38a2030bd61c1466a667daa74753f">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#a3c3254d704e4d0005b0db13258d3e699">count</a> (const Key &amp;key) const</td></tr>
<tr class="separator:a3c3254d704e4d0005b0db13258d3e699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad032e476d2b28d6c102f8c9b1a1aa058"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1bhopscotch__map.html#a95e38a2030bd61c1466a667daa74753f">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#ad032e476d2b28d6c102f8c9b1a1aa058">count</a> (const Key &amp;key, <a class="el" href="namespacestd.html#aa30247b5e1a6e192c486364692e37832">std::size_t</a> precalculated_hash) const</td></tr>
<tr class="separator:ad032e476d2b28d6c102f8c9b1a1aa058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7819f010c5e45046f167e5c11060899"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, class CP  = Compare, typename std::enable_if&lt; <a class="el" href="classtsl_1_1bhopscotch__map.html#afe54106a1c0379005aca41a7ca47478a">has_is_transparent</a>&lt; KE &gt;::value &amp;&amp;<a class="el" href="classtsl_1_1bhopscotch__map.html#afe54106a1c0379005aca41a7ca47478a">has_is_transparent</a>&lt; CP &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ae7819f010c5e45046f167e5c11060899"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1bhopscotch__map.html#a95e38a2030bd61c1466a667daa74753f">size_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#ae7819f010c5e45046f167e5c11060899">count</a> (const K &amp;key) const</td></tr>
<tr class="separator:ae7819f010c5e45046f167e5c11060899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa90016c38572f2023c8b6848a884cff7"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, class CP  = Compare, typename std::enable_if&lt; <a class="el" href="classtsl_1_1bhopscotch__map.html#afe54106a1c0379005aca41a7ca47478a">has_is_transparent</a>&lt; KE &gt;::value &amp;&amp;<a class="el" href="classtsl_1_1bhopscotch__map.html#afe54106a1c0379005aca41a7ca47478a">has_is_transparent</a>&lt; CP &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:aa90016c38572f2023c8b6848a884cff7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1bhopscotch__map.html#a95e38a2030bd61c1466a667daa74753f">size_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#aa90016c38572f2023c8b6848a884cff7">count</a> (const K &amp;key, <a class="el" href="namespacestd.html#aa30247b5e1a6e192c486364692e37832">std::size_t</a> precalculated_hash) const</td></tr>
<tr class="separator:aa90016c38572f2023c8b6848a884cff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dad311085e5f135d1cb85999e953215"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1bhopscotch__map.html#a966956276ea45c7c32d1bc6bd97b1b79">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#a2dad311085e5f135d1cb85999e953215">find</a> (const Key &amp;key)</td></tr>
<tr class="separator:a2dad311085e5f135d1cb85999e953215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd832ef66a21c5852d63586294801812"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1bhopscotch__map.html#a966956276ea45c7c32d1bc6bd97b1b79">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#abd832ef66a21c5852d63586294801812">find</a> (const Key &amp;key, <a class="el" href="namespacestd.html#aa30247b5e1a6e192c486364692e37832">std::size_t</a> precalculated_hash)</td></tr>
<tr class="separator:abd832ef66a21c5852d63586294801812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab83f5d7371fe3f50126ee162c0a7aad7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1bhopscotch__map.html#a3e21f04e9276cdeceb1087131db03fcc">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#ab83f5d7371fe3f50126ee162c0a7aad7">find</a> (const Key &amp;key) const</td></tr>
<tr class="separator:ab83f5d7371fe3f50126ee162c0a7aad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad64b7927efcf0389b419a8072fb3bdfa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1bhopscotch__map.html#a3e21f04e9276cdeceb1087131db03fcc">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#ad64b7927efcf0389b419a8072fb3bdfa">find</a> (const Key &amp;key, <a class="el" href="namespacestd.html#aa30247b5e1a6e192c486364692e37832">std::size_t</a> precalculated_hash) const</td></tr>
<tr class="separator:ad64b7927efcf0389b419a8072fb3bdfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a216a0c1d731e8fb50da4712bc11408da"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, class CP  = Compare, typename std::enable_if&lt; <a class="el" href="classtsl_1_1bhopscotch__map.html#afe54106a1c0379005aca41a7ca47478a">has_is_transparent</a>&lt; KE &gt;::value &amp;&amp;<a class="el" href="classtsl_1_1bhopscotch__map.html#afe54106a1c0379005aca41a7ca47478a">has_is_transparent</a>&lt; CP &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a216a0c1d731e8fb50da4712bc11408da"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1bhopscotch__map.html#a966956276ea45c7c32d1bc6bd97b1b79">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#a216a0c1d731e8fb50da4712bc11408da">find</a> (const K &amp;key)</td></tr>
<tr class="separator:a216a0c1d731e8fb50da4712bc11408da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad09dc0c4313d33eacf0f79ccbd825535"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, class CP  = Compare, typename std::enable_if&lt; <a class="el" href="classtsl_1_1bhopscotch__map.html#afe54106a1c0379005aca41a7ca47478a">has_is_transparent</a>&lt; KE &gt;::value &amp;&amp;<a class="el" href="classtsl_1_1bhopscotch__map.html#afe54106a1c0379005aca41a7ca47478a">has_is_transparent</a>&lt; CP &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ad09dc0c4313d33eacf0f79ccbd825535"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1bhopscotch__map.html#a966956276ea45c7c32d1bc6bd97b1b79">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#ad09dc0c4313d33eacf0f79ccbd825535">find</a> (const K &amp;key, <a class="el" href="namespacestd.html#aa30247b5e1a6e192c486364692e37832">std::size_t</a> precalculated_hash)</td></tr>
<tr class="separator:ad09dc0c4313d33eacf0f79ccbd825535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82dab7bc58be071ff4b7588fece36352"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, class CP  = Compare, typename std::enable_if&lt; <a class="el" href="classtsl_1_1bhopscotch__map.html#afe54106a1c0379005aca41a7ca47478a">has_is_transparent</a>&lt; KE &gt;::value &amp;&amp;<a class="el" href="classtsl_1_1bhopscotch__map.html#afe54106a1c0379005aca41a7ca47478a">has_is_transparent</a>&lt; CP &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a82dab7bc58be071ff4b7588fece36352"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1bhopscotch__map.html#a3e21f04e9276cdeceb1087131db03fcc">const_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#a82dab7bc58be071ff4b7588fece36352">find</a> (const K &amp;key) const</td></tr>
<tr class="separator:a82dab7bc58be071ff4b7588fece36352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f90c27dcc2c227ced0777e8a52f6b8d"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, class CP  = Compare, typename std::enable_if&lt; <a class="el" href="classtsl_1_1bhopscotch__map.html#afe54106a1c0379005aca41a7ca47478a">has_is_transparent</a>&lt; KE &gt;::value &amp;&amp;<a class="el" href="classtsl_1_1bhopscotch__map.html#afe54106a1c0379005aca41a7ca47478a">has_is_transparent</a>&lt; CP &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a2f90c27dcc2c227ced0777e8a52f6b8d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1bhopscotch__map.html#a3e21f04e9276cdeceb1087131db03fcc">const_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#a2f90c27dcc2c227ced0777e8a52f6b8d">find</a> (const K &amp;key, <a class="el" href="namespacestd.html#aa30247b5e1a6e192c486364692e37832">std::size_t</a> precalculated_hash) const</td></tr>
<tr class="separator:a2f90c27dcc2c227ced0777e8a52f6b8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ba60e1f900861b4384f7e18d553b25a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#a4ba60e1f900861b4384f7e18d553b25a">contains</a> (const Key &amp;key) const</td></tr>
<tr class="separator:a4ba60e1f900861b4384f7e18d553b25a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23e18961ad6f09032c4eef6404f5e428"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#a23e18961ad6f09032c4eef6404f5e428">contains</a> (const Key &amp;key, <a class="el" href="namespacestd.html#aa30247b5e1a6e192c486364692e37832">std::size_t</a> precalculated_hash) const</td></tr>
<tr class="separator:a23e18961ad6f09032c4eef6404f5e428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ab5fdbf4bebfc467f5433d8219d0eff"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; <a class="el" href="classtsl_1_1bhopscotch__map.html#afe54106a1c0379005aca41a7ca47478a">has_is_transparent</a>&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a9ab5fdbf4bebfc467f5433d8219d0eff"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#a9ab5fdbf4bebfc467f5433d8219d0eff">contains</a> (const K &amp;key) const</td></tr>
<tr class="separator:a9ab5fdbf4bebfc467f5433d8219d0eff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a894c28b429352193609c63a9d21ca0ac"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; <a class="el" href="classtsl_1_1bhopscotch__map.html#afe54106a1c0379005aca41a7ca47478a">has_is_transparent</a>&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a894c28b429352193609c63a9d21ca0ac"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#a894c28b429352193609c63a9d21ca0ac">contains</a> (const K &amp;key, <a class="el" href="namespacestd.html#aa30247b5e1a6e192c486364692e37832">std::size_t</a> precalculated_hash) const</td></tr>
<tr class="separator:a894c28b429352193609c63a9d21ca0ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa750e05d90eb49831ef93f7fc8bbca96"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtsl_1_1bhopscotch__map.html#a966956276ea45c7c32d1bc6bd97b1b79">iterator</a>, <a class="el" href="classtsl_1_1bhopscotch__map.html#a966956276ea45c7c32d1bc6bd97b1b79">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#aa750e05d90eb49831ef93f7fc8bbca96">equal_range</a> (const Key &amp;key)</td></tr>
<tr class="separator:aa750e05d90eb49831ef93f7fc8bbca96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2fb12e0129b505a893306595254e603"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtsl_1_1bhopscotch__map.html#a966956276ea45c7c32d1bc6bd97b1b79">iterator</a>, <a class="el" href="classtsl_1_1bhopscotch__map.html#a966956276ea45c7c32d1bc6bd97b1b79">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#ab2fb12e0129b505a893306595254e603">equal_range</a> (const Key &amp;key, <a class="el" href="namespacestd.html#aa30247b5e1a6e192c486364692e37832">std::size_t</a> precalculated_hash)</td></tr>
<tr class="separator:ab2fb12e0129b505a893306595254e603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68bb7024cb59dec1c0479f9cb67e3983"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtsl_1_1bhopscotch__map.html#a3e21f04e9276cdeceb1087131db03fcc">const_iterator</a>, <a class="el" href="classtsl_1_1bhopscotch__map.html#a3e21f04e9276cdeceb1087131db03fcc">const_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#a68bb7024cb59dec1c0479f9cb67e3983">equal_range</a> (const Key &amp;key) const</td></tr>
<tr class="separator:a68bb7024cb59dec1c0479f9cb67e3983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f1f10e1390f2582caef5b0be9f01b7f"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtsl_1_1bhopscotch__map.html#a3e21f04e9276cdeceb1087131db03fcc">const_iterator</a>, <a class="el" href="classtsl_1_1bhopscotch__map.html#a3e21f04e9276cdeceb1087131db03fcc">const_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#a2f1f10e1390f2582caef5b0be9f01b7f">equal_range</a> (const Key &amp;key, <a class="el" href="namespacestd.html#aa30247b5e1a6e192c486364692e37832">std::size_t</a> precalculated_hash) const</td></tr>
<tr class="separator:a2f1f10e1390f2582caef5b0be9f01b7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec46520b5e65ba05fab5f9c3504bf703"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, class CP  = Compare, typename std::enable_if&lt; <a class="el" href="classtsl_1_1bhopscotch__map.html#afe54106a1c0379005aca41a7ca47478a">has_is_transparent</a>&lt; KE &gt;::value &amp;&amp;<a class="el" href="classtsl_1_1bhopscotch__map.html#afe54106a1c0379005aca41a7ca47478a">has_is_transparent</a>&lt; CP &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:aec46520b5e65ba05fab5f9c3504bf703"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtsl_1_1bhopscotch__map.html#a966956276ea45c7c32d1bc6bd97b1b79">iterator</a>, <a class="el" href="classtsl_1_1bhopscotch__map.html#a966956276ea45c7c32d1bc6bd97b1b79">iterator</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#aec46520b5e65ba05fab5f9c3504bf703">equal_range</a> (const K &amp;key)</td></tr>
<tr class="separator:aec46520b5e65ba05fab5f9c3504bf703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c5622532e940b647b350113d7055db8"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, class CP  = Compare, typename std::enable_if&lt; <a class="el" href="classtsl_1_1bhopscotch__map.html#afe54106a1c0379005aca41a7ca47478a">has_is_transparent</a>&lt; KE &gt;::value &amp;&amp;<a class="el" href="classtsl_1_1bhopscotch__map.html#afe54106a1c0379005aca41a7ca47478a">has_is_transparent</a>&lt; CP &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a8c5622532e940b647b350113d7055db8"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtsl_1_1bhopscotch__map.html#a966956276ea45c7c32d1bc6bd97b1b79">iterator</a>, <a class="el" href="classtsl_1_1bhopscotch__map.html#a966956276ea45c7c32d1bc6bd97b1b79">iterator</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#a8c5622532e940b647b350113d7055db8">equal_range</a> (const K &amp;key, <a class="el" href="namespacestd.html#aa30247b5e1a6e192c486364692e37832">std::size_t</a> precalculated_hash)</td></tr>
<tr class="separator:a8c5622532e940b647b350113d7055db8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41d61831e913f6684bcc25025da49076"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, class CP  = Compare, typename std::enable_if&lt; <a class="el" href="classtsl_1_1bhopscotch__map.html#afe54106a1c0379005aca41a7ca47478a">has_is_transparent</a>&lt; KE &gt;::value &amp;&amp;<a class="el" href="classtsl_1_1bhopscotch__map.html#afe54106a1c0379005aca41a7ca47478a">has_is_transparent</a>&lt; CP &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a41d61831e913f6684bcc25025da49076"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtsl_1_1bhopscotch__map.html#a3e21f04e9276cdeceb1087131db03fcc">const_iterator</a>, <a class="el" href="classtsl_1_1bhopscotch__map.html#a3e21f04e9276cdeceb1087131db03fcc">const_iterator</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#a41d61831e913f6684bcc25025da49076">equal_range</a> (const K &amp;key) const</td></tr>
<tr class="separator:a41d61831e913f6684bcc25025da49076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ee0bd5c35c7ceb5821b0b7f2359ab50"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, class CP  = Compare, typename std::enable_if&lt; <a class="el" href="classtsl_1_1bhopscotch__map.html#afe54106a1c0379005aca41a7ca47478a">has_is_transparent</a>&lt; KE &gt;::value &amp;&amp;<a class="el" href="classtsl_1_1bhopscotch__map.html#afe54106a1c0379005aca41a7ca47478a">has_is_transparent</a>&lt; CP &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a5ee0bd5c35c7ceb5821b0b7f2359ab50"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtsl_1_1bhopscotch__map.html#a3e21f04e9276cdeceb1087131db03fcc">const_iterator</a>, <a class="el" href="classtsl_1_1bhopscotch__map.html#a3e21f04e9276cdeceb1087131db03fcc">const_iterator</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#a5ee0bd5c35c7ceb5821b0b7f2359ab50">equal_range</a> (const K &amp;key, <a class="el" href="namespacestd.html#aa30247b5e1a6e192c486364692e37832">std::size_t</a> precalculated_hash) const</td></tr>
<tr class="separator:a5ee0bd5c35c7ceb5821b0b7f2359ab50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac387158a5710ce3d84a7b8bd2daa152e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1bhopscotch__map.html#a95e38a2030bd61c1466a667daa74753f">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#ac387158a5710ce3d84a7b8bd2daa152e">bucket_count</a> () const</td></tr>
<tr class="separator:ac387158a5710ce3d84a7b8bd2daa152e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c13a40a6497ee39c65086591868b931"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1bhopscotch__map.html#a95e38a2030bd61c1466a667daa74753f">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#a9c13a40a6497ee39c65086591868b931">max_bucket_count</a> () const</td></tr>
<tr class="separator:a9c13a40a6497ee39c65086591868b931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d5a69af11abce38d47da46a314fb6c2"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#a9d5a69af11abce38d47da46a314fb6c2">load_factor</a> () const</td></tr>
<tr class="separator:a9d5a69af11abce38d47da46a314fb6c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeac654fc816e563ea05d50811d118a00"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#aeac654fc816e563ea05d50811d118a00">max_load_factor</a> () const</td></tr>
<tr class="separator:aeac654fc816e563ea05d50811d118a00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9929ec2d2b3d4eb14b8d701038c5c65"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#ac9929ec2d2b3d4eb14b8d701038c5c65">max_load_factor</a> (float ml)</td></tr>
<tr class="separator:ac9929ec2d2b3d4eb14b8d701038c5c65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa523e2ad7a589ada2315f4c6f112832"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#aaa523e2ad7a589ada2315f4c6f112832">rehash</a> (<a class="el" href="classtsl_1_1bhopscotch__map.html#a95e38a2030bd61c1466a667daa74753f">size_type</a> count_)</td></tr>
<tr class="separator:aaa523e2ad7a589ada2315f4c6f112832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81dc3cf243066e6de7e9d4813cd07b01"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#a81dc3cf243066e6de7e9d4813cd07b01">reserve</a> (<a class="el" href="classtsl_1_1bhopscotch__map.html#a95e38a2030bd61c1466a667daa74753f">size_type</a> count_)</td></tr>
<tr class="separator:a81dc3cf243066e6de7e9d4813cd07b01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b8e1e6778d60554f4abf33071965245"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1bhopscotch__map.html#ab42531c264442155c69f6caf7ddd0f0d">hasher</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#a9b8e1e6778d60554f4abf33071965245">hash_function</a> () const</td></tr>
<tr class="separator:a9b8e1e6778d60554f4abf33071965245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36324da3bbad68403d51a880a38e6178"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1bhopscotch__map.html#ad16fff74a2b4cfefbd97750f2207a668">key_equal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#a36324da3bbad68403d51a880a38e6178">key_eq</a> () const</td></tr>
<tr class="separator:a36324da3bbad68403d51a880a38e6178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5459ee998ed49f3581c29b6338e195fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1bhopscotch__map.html#a4f1515ae04d28e8f21e0533b3723d10e">key_compare</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#a5459ee998ed49f3581c29b6338e195fb">key_comp</a> () const</td></tr>
<tr class="separator:a5459ee998ed49f3581c29b6338e195fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6eef4d6fb5c328ff3923bcde606d404"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1bhopscotch__map.html#a966956276ea45c7c32d1bc6bd97b1b79">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#ae6eef4d6fb5c328ff3923bcde606d404">mutable_iterator</a> (<a class="el" href="classtsl_1_1bhopscotch__map.html#a3e21f04e9276cdeceb1087131db03fcc">const_iterator</a> pos)</td></tr>
<tr class="separator:ae6eef4d6fb5c328ff3923bcde606d404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2287e06589351a903e74b0687da40e7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1bhopscotch__map.html#a95e38a2030bd61c1466a667daa74753f">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#a2287e06589351a903e74b0687da40e7d">overflow_size</a> () const noexcept</td></tr>
<tr class="separator:a2287e06589351a903e74b0687da40e7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-types" name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:afe54106a1c0379005aca41a7ca47478a"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:afe54106a1c0379005aca41a7ca47478a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#afe54106a1c0379005aca41a7ca47478a">has_is_transparent</a> = <a class="el" href="structtsl_1_1detail__hopscotch__hash_1_1has__is__transparent.html">tsl::detail_hopscotch_hash::has_is_transparent</a>&lt; U &gt;</td></tr>
<tr class="separator:afe54106a1c0379005aca41a7ca47478a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff58a60c5e700602737ad0f2c5401631"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#aff58a60c5e700602737ad0f2c5401631">overflow_container_type</a> = std::map&lt; Key, T, Compare, Allocator &gt;</td></tr>
<tr class="separator:aff58a60c5e700602737ad0f2c5401631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a506849d576c2306d65487969df20fb6e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#a506849d576c2306d65487969df20fb6e">ht</a> = <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html">detail_hopscotch_hash::hopscotch_hash</a>&lt; std::pair&lt; const Key, T &gt;, <a class="el" href="classtsl_1_1bhopscotch__map_1_1KeySelect.html">KeySelect</a>, <a class="el" href="classtsl_1_1bhopscotch__map_1_1ValueSelect.html">ValueSelect</a>, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy, <a class="el" href="classtsl_1_1bhopscotch__map.html#aff58a60c5e700602737ad0f2c5401631">overflow_container_type</a> &gt;</td></tr>
<tr class="separator:a506849d576c2306d65487969df20fb6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a62e185c160404720d3abcd857826318f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1bhopscotch__map.html#a506849d576c2306d65487969df20fb6e">ht</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#a62e185c160404720d3abcd857826318f">m_ht</a></td></tr>
<tr class="separator:a62e185c160404720d3abcd857826318f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a6a26a03b4defceeb287620cc62c4275c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#a6a26a03b4defceeb287620cc62c4275c">operator==</a> (const <a class="el" href="classtsl_1_1bhopscotch__map.html">bhopscotch_map</a> &amp;lhs, const <a class="el" href="classtsl_1_1bhopscotch__map.html">bhopscotch_map</a> &amp;rhs)</td></tr>
<tr class="separator:a6a26a03b4defceeb287620cc62c4275c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b2bd6b393ffe15ec6ef1ee0a1e15c3d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#a6b2bd6b393ffe15ec6ef1ee0a1e15c3d">operator!=</a> (const <a class="el" href="classtsl_1_1bhopscotch__map.html">bhopscotch_map</a> &amp;lhs, const <a class="el" href="classtsl_1_1bhopscotch__map.html">bhopscotch_map</a> &amp;rhs)</td></tr>
<tr class="separator:a6b2bd6b393ffe15ec6ef1ee0a1e15c3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a075de73ae307816baaf5267ba3b895e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1bhopscotch__map.html#a075de73ae307816baaf5267ba3b895e6">swap</a> (<a class="el" href="classtsl_1_1bhopscotch__map.html">bhopscotch_map</a> &amp;lhs, <a class="el" href="classtsl_1_1bhopscotch__map.html">bhopscotch_map</a> &amp;rhs)</td></tr>
<tr class="separator:a075de73ae307816baaf5267ba3b895e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt;<br />
class tsl::bhopscotch_map&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;</div><p>Similar to <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a> but instead of using a list for overflowing elements it uses a binary search tree. It thus needs an additional template parameter Compare. Compare should be arithmetically coherent with KeyEqual.</p>
<p>The binary search tree allows the map to have a worst-case scenario of O(log
n) for search and delete, even if the hash function maps all the elements to the same bucket. For insert, the amortized worst case is O(log n), but the worst case is O(n) in case of rehash.</p>
<p>This makes the map resistant to DoS attacks (but doesn't preclude you to have a good hash function, as an element in the bucket array is faster to retrieve than in the tree). </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a73abd33b2c870e5400f7b22984f8fdac" name="a73abd33b2c870e5400f7b22984f8fdac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73abd33b2c870e5400f7b22984f8fdac">&#9670;&#160;</a></span>allocator_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::allocator_type =  typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#a8af583783f638a3faac62c52b876aa67">ht::allocator_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3e21f04e9276cdeceb1087131db03fcc" name="a3e21f04e9276cdeceb1087131db03fcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e21f04e9276cdeceb1087131db03fcc">&#9670;&#160;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::const_iterator =  typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#a2af6f88c2b254b2c9ff83c70eea7c952">ht::const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2d11911b0dca500c38d2a4d3eca7c963" name="a2d11911b0dca500c38d2a4d3eca7c963"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d11911b0dca500c38d2a4d3eca7c963">&#9670;&#160;</a></span>const_pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::const_pointer =  typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#a85e8fb0e24e28aef2c0ec4ce9e3f9d01">ht::const_pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a28138c0ee5419fa252b0296fb47ccacb" name="a28138c0ee5419fa252b0296fb47ccacb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28138c0ee5419fa252b0296fb47ccacb">&#9670;&#160;</a></span>const_reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::const_reference =  typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#ae45966f2a709f1d7f03d42cd19fb29ea">ht::const_reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac2564ea14d7b8b2f63e14946eff00107" name="ac2564ea14d7b8b2f63e14946eff00107"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2564ea14d7b8b2f63e14946eff00107">&#9670;&#160;</a></span>difference_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::difference_type =  typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#a3a8a8e910088e7bdbfe63be530d31956">ht::difference_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afe54106a1c0379005aca41a7ca47478a" name="afe54106a1c0379005aca41a7ca47478a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe54106a1c0379005aca41a7ca47478a">&#9670;&#160;</a></span>has_is_transparent</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::has_is_transparent =  <a class="el" href="structtsl_1_1detail__hopscotch__hash_1_1has__is__transparent.html">tsl::detail_hopscotch_hash::has_is_transparent</a>&lt;U&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab42531c264442155c69f6caf7ddd0f0d" name="ab42531c264442155c69f6caf7ddd0f0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab42531c264442155c69f6caf7ddd0f0d">&#9670;&#160;</a></span>hasher</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::hasher =  typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#a0ffe6a6aaa0794dcf4979fc23e583462">ht::hasher</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a506849d576c2306d65487969df20fb6e" name="a506849d576c2306d65487969df20fb6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a506849d576c2306d65487969df20fb6e">&#9670;&#160;</a></span>ht</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::ht =  <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html">detail_hopscotch_hash::hopscotch_hash</a>&lt;std::pair&lt;const Key, T&gt;, <a class="el" href="classtsl_1_1bhopscotch__map_1_1KeySelect.html">KeySelect</a>, <a class="el" href="classtsl_1_1bhopscotch__map_1_1ValueSelect.html">ValueSelect</a>, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy, <a class="el" href="classtsl_1_1bhopscotch__map.html#aff58a60c5e700602737ad0f2c5401631">overflow_container_type</a>&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a966956276ea45c7c32d1bc6bd97b1b79" name="a966956276ea45c7c32d1bc6bd97b1b79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a966956276ea45c7c32d1bc6bd97b1b79">&#9670;&#160;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::iterator =  typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#ab697c644e6dec536d6ab028ba085b591">ht::iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4f1515ae04d28e8f21e0533b3723d10e" name="a4f1515ae04d28e8f21e0533b3723d10e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f1515ae04d28e8f21e0533b3723d10e">&#9670;&#160;</a></span>key_compare</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::key_compare =  Compare</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad16fff74a2b4cfefbd97750f2207a668" name="ad16fff74a2b4cfefbd97750f2207a668"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad16fff74a2b4cfefbd97750f2207a668">&#9670;&#160;</a></span>key_equal</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::key_equal =  typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#a69a00efe0c98e7d89d3eeb8ef5e43190">ht::key_equal</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a37f4050e3fd3b6cff23b19f0ce484ee6" name="a37f4050e3fd3b6cff23b19f0ce484ee6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37f4050e3fd3b6cff23b19f0ce484ee6">&#9670;&#160;</a></span>key_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::key_type =  typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#ac2da7bb97307e334553fe9cba15d0689">ht::key_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7abce739cfeb17ff39fb1e55824babce" name="a7abce739cfeb17ff39fb1e55824babce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7abce739cfeb17ff39fb1e55824babce">&#9670;&#160;</a></span>mapped_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::mapped_type =  T</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aff58a60c5e700602737ad0f2c5401631" name="aff58a60c5e700602737ad0f2c5401631"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff58a60c5e700602737ad0f2c5401631">&#9670;&#160;</a></span>overflow_container_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::overflow_container_type =  std::map&lt;Key, T, Compare, Allocator&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7eebdd0b0efe137c6f7737b56867e99a" name="a7eebdd0b0efe137c6f7737b56867e99a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eebdd0b0efe137c6f7737b56867e99a">&#9670;&#160;</a></span>pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::pointer =  typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#a31276a8ba5b00732857fd0267a5b6fdd">ht::pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a84aedb63b4be39af2078ca72e072214c" name="a84aedb63b4be39af2078ca72e072214c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84aedb63b4be39af2078ca72e072214c">&#9670;&#160;</a></span>reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::reference =  typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#a257bb0ff019c2756bc2c192e76f31ce5">ht::reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a95e38a2030bd61c1466a667daa74753f" name="a95e38a2030bd61c1466a667daa74753f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95e38a2030bd61c1466a667daa74753f">&#9670;&#160;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::size_type =  typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#a0f2a8dda76d11a1531be2c2e7fb82061">ht::size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1bf237363f1ad38d96bcd496db330f3d" name="a1bf237363f1ad38d96bcd496db330f3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bf237363f1ad38d96bcd496db330f3d">&#9670;&#160;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::value_type =  typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#afed3e1f425ac47050c9d8b96c2c5e319">ht::value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a4d1d208a0593483278443719b2ce94b9" name="a4d1d208a0593483278443719b2ce94b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d1d208a0593483278443719b2ce94b9">&#9670;&#160;</a></span>bhopscotch_map() <span class="overload">[1/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::bhopscotch_map </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3a63cf9630c0b389b98691a48c077b4f" name="a3a63cf9630c0b389b98691a48c077b4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a63cf9630c0b389b98691a48c077b4f">&#9670;&#160;</a></span>bhopscotch_map() <span class="overload">[2/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::bhopscotch_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1bhopscotch__map.html#a95e38a2030bd61c1466a667daa74753f">size_type</a>&#160;</td>
          <td class="paramname"><em>bucket_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Hash &amp;&#160;</td>
          <td class="paramname"><em>hash</em> = <code>Hash()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyEqual &amp;&#160;</td>
          <td class="paramname"><em>equal</em> = <code>KeyEqual()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>Allocator()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Compare &amp;&#160;</td>
          <td class="paramname"><em>comp</em> = <code>Compare()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a475b583d6c8e5119b9a3edc468215977" name="a475b583d6c8e5119b9a3edc468215977"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a475b583d6c8e5119b9a3edc468215977">&#9670;&#160;</a></span>bhopscotch_map() <span class="overload">[3/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::bhopscotch_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1bhopscotch__map.html#a95e38a2030bd61c1466a667daa74753f">size_type</a>&#160;</td>
          <td class="paramname"><em>bucket_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a380263a1e51e97d49722c9155be77a3f" name="a380263a1e51e97d49722c9155be77a3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a380263a1e51e97d49722c9155be77a3f">&#9670;&#160;</a></span>bhopscotch_map() <span class="overload">[4/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::bhopscotch_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1bhopscotch__map.html#a95e38a2030bd61c1466a667daa74753f">size_type</a>&#160;</td>
          <td class="paramname"><em>bucket_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Hash &amp;&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae63777c4ffd509ffe3a6f5c79280ac35" name="ae63777c4ffd509ffe3a6f5c79280ac35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae63777c4ffd509ffe3a6f5c79280ac35">&#9670;&#160;</a></span>bhopscotch_map() <span class="overload">[5/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::bhopscotch_map </td>
          <td>(</td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aedc0c3217377afed0017998c5078438d" name="aedc0c3217377afed0017998c5078438d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedc0c3217377afed0017998c5078438d">&#9670;&#160;</a></span>bhopscotch_map() <span class="overload">[6/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::bhopscotch_map </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtsl_1_1bhopscotch__map.html#a95e38a2030bd61c1466a667daa74753f">size_type</a>&#160;</td>
          <td class="paramname"><em>bucket_count</em> = <code><a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#a3b4d20d3ff76dd7e703bb18368332368">ht::DEFAULT_INIT_BUCKETS_SIZE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Hash &amp;&#160;</td>
          <td class="paramname"><em>hash</em> = <code>Hash()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyEqual &amp;&#160;</td>
          <td class="paramname"><em>equal</em> = <code>KeyEqual()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abd0eb57e7dfb1656fc70fa2584e6b904" name="abd0eb57e7dfb1656fc70fa2584e6b904"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd0eb57e7dfb1656fc70fa2584e6b904">&#9670;&#160;</a></span>bhopscotch_map() <span class="overload">[7/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::bhopscotch_map </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtsl_1_1bhopscotch__map.html#a95e38a2030bd61c1466a667daa74753f">size_type</a>&#160;</td>
          <td class="paramname"><em>bucket_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a99b6d51ca94e657654f5606546b01fb2" name="a99b6d51ca94e657654f5606546b01fb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99b6d51ca94e657654f5606546b01fb2">&#9670;&#160;</a></span>bhopscotch_map() <span class="overload">[8/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::bhopscotch_map </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtsl_1_1bhopscotch__map.html#a95e38a2030bd61c1466a667daa74753f">size_type</a>&#160;</td>
          <td class="paramname"><em>bucket_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Hash &amp;&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac92a8e0ad2ec4e3acae3672373809ff6" name="ac92a8e0ad2ec4e3acae3672373809ff6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac92a8e0ad2ec4e3acae3672373809ff6">&#9670;&#160;</a></span>bhopscotch_map() <span class="overload">[9/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::bhopscotch_map </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classtsl_1_1bhopscotch__map.html#a1bf237363f1ad38d96bcd496db330f3d">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtsl_1_1bhopscotch__map.html#a95e38a2030bd61c1466a667daa74753f">size_type</a>&#160;</td>
          <td class="paramname"><em>bucket_count</em> = <code><a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#a3b4d20d3ff76dd7e703bb18368332368">ht::DEFAULT_INIT_BUCKETS_SIZE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Hash &amp;&#160;</td>
          <td class="paramname"><em>hash</em> = <code>Hash()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyEqual &amp;&#160;</td>
          <td class="paramname"><em>equal</em> = <code>KeyEqual()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1eb73368b571503e6ad0f4972798c2b0" name="a1eb73368b571503e6ad0f4972798c2b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eb73368b571503e6ad0f4972798c2b0">&#9670;&#160;</a></span>bhopscotch_map() <span class="overload">[10/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::bhopscotch_map </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classtsl_1_1bhopscotch__map.html#a1bf237363f1ad38d96bcd496db330f3d">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtsl_1_1bhopscotch__map.html#a95e38a2030bd61c1466a667daa74753f">size_type</a>&#160;</td>
          <td class="paramname"><em>bucket_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a77070809c6d80e07b426ea9f688d24a5" name="a77070809c6d80e07b426ea9f688d24a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77070809c6d80e07b426ea9f688d24a5">&#9670;&#160;</a></span>bhopscotch_map() <span class="overload">[11/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::bhopscotch_map </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classtsl_1_1bhopscotch__map.html#a1bf237363f1ad38d96bcd496db330f3d">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtsl_1_1bhopscotch__map.html#a95e38a2030bd61c1466a667daa74753f">size_type</a>&#160;</td>
          <td class="paramname"><em>bucket_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Hash &amp;&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af1fe698668905b5144f1dc5852d6e689" name="af1fe698668905b5144f1dc5852d6e689"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1fe698668905b5144f1dc5852d6e689">&#9670;&#160;</a></span>at() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, class CP  = Compare, typename std::enable_if&lt; <a class="el" href="classtsl_1_1bhopscotch__map.html#afe54106a1c0379005aca41a7ca47478a">has_is_transparent</a>&lt; KE &gt;::value &amp;&amp;<a class="el" href="classtsl_1_1bhopscotch__map.html#afe54106a1c0379005aca41a7ca47478a">has_is_transparent</a>&lt; CP &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent and Compare::is_transparent exist. If so, K must be hashable and comparable to Key. </p>

</div>
</div>
<a id="a3c2ff9cfeecd1cf02485c97d806c4f38" name="a3c2ff9cfeecd1cf02485c97d806c4f38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c2ff9cfeecd1cf02485c97d806c4f38">&#9670;&#160;</a></span>at() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, class CP  = Compare, typename std::enable_if&lt; <a class="el" href="classtsl_1_1bhopscotch__map.html#afe54106a1c0379005aca41a7ca47478a">has_is_transparent</a>&lt; KE &gt;::value &amp;&amp;<a class="el" href="classtsl_1_1bhopscotch__map.html#afe54106a1c0379005aca41a7ca47478a">has_is_transparent</a>&lt; CP &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7afabc7f550d3550185aa0399e375443" name="a7afabc7f550d3550185aa0399e375443"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7afabc7f550d3550185aa0399e375443">&#9670;&#160;</a></span>at() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, class CP  = Compare, typename std::enable_if&lt; <a class="el" href="classtsl_1_1bhopscotch__map.html#afe54106a1c0379005aca41a7ca47478a">has_is_transparent</a>&lt; KE &gt;::value &amp;&amp;<a class="el" href="classtsl_1_1bhopscotch__map.html#afe54106a1c0379005aca41a7ca47478a">has_is_transparent</a>&lt; CP &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacestd.html#aa30247b5e1a6e192c486364692e37832">std::size_t</a>&#160;</td>
          <td class="paramname"><em>precalculated_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="classtsl_1_1bhopscotch__map.html#a9b8e1e6778d60554f4abf33071965245">hash_function()</a>(key). Useful to speed-up the lookup if you already have the hash. </p>

</div>
</div>
<a id="a1ec05e5365e823fd14e5c08e14b8bb0d" name="a1ec05e5365e823fd14e5c08e14b8bb0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ec05e5365e823fd14e5c08e14b8bb0d">&#9670;&#160;</a></span>at() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, class CP  = Compare, typename std::enable_if&lt; <a class="el" href="classtsl_1_1bhopscotch__map.html#afe54106a1c0379005aca41a7ca47478a">has_is_transparent</a>&lt; KE &gt;::value &amp;&amp;<a class="el" href="classtsl_1_1bhopscotch__map.html#afe54106a1c0379005aca41a7ca47478a">has_is_transparent</a>&lt; CP &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacestd.html#aa30247b5e1a6e192c486364692e37832">std::size_t</a>&#160;</td>
          <td class="paramname"><em>precalculated_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2c5ed58b57be3166d1d568cf2b1c9d42" name="a2c5ed58b57be3166d1d568cf2b1c9d42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c5ed58b57be3166d1d568cf2b1c9d42">&#9670;&#160;</a></span>at() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af8885ca3e150665eeeb5de68ae0125da" name="af8885ca3e150665eeeb5de68ae0125da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8885ca3e150665eeeb5de68ae0125da">&#9670;&#160;</a></span>at() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a961413c46ab73e25694f09ce171fe6b9" name="a961413c46ab73e25694f09ce171fe6b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a961413c46ab73e25694f09ce171fe6b9">&#9670;&#160;</a></span>at() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacestd.html#aa30247b5e1a6e192c486364692e37832">std::size_t</a>&#160;</td>
          <td class="paramname"><em>precalculated_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="classtsl_1_1bhopscotch__map.html#a9b8e1e6778d60554f4abf33071965245">hash_function()</a>(key). Useful to speed-up the lookup if you already have the hash. </p>

</div>
</div>
<a id="a9a011baceef2dc6dcb5119bd1af2df38" name="a9a011baceef2dc6dcb5119bd1af2df38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a011baceef2dc6dcb5119bd1af2df38">&#9670;&#160;</a></span>at() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacestd.html#aa30247b5e1a6e192c486364692e37832">std::size_t</a>&#160;</td>
          <td class="paramname"><em>precalculated_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a54f23345d910a98264355f83b3949eaa" name="a54f23345d910a98264355f83b3949eaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54f23345d910a98264355f83b3949eaa">&#9670;&#160;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1bhopscotch__map.html#a3e21f04e9276cdeceb1087131db03fcc">const_iterator</a> <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2920c5c7a84e213ac71864efae65c780" name="a2920c5c7a84e213ac71864efae65c780"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2920c5c7a84e213ac71864efae65c780">&#9670;&#160;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1bhopscotch__map.html#a966956276ea45c7c32d1bc6bd97b1b79">iterator</a> <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac387158a5710ce3d84a7b8bd2daa152e" name="ac387158a5710ce3d84a7b8bd2daa152e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac387158a5710ce3d84a7b8bd2daa152e">&#9670;&#160;</a></span>bucket_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1bhopscotch__map.html#a95e38a2030bd61c1466a667daa74753f">size_type</a> <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::bucket_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a77a1cfefe845d6a88db3fbb940bb442b" name="a77a1cfefe845d6a88db3fbb940bb442b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77a1cfefe845d6a88db3fbb940bb442b">&#9670;&#160;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1bhopscotch__map.html#a3e21f04e9276cdeceb1087131db03fcc">const_iterator</a> <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad393eeb03469ac26d71561262da2fdd1" name="ad393eeb03469ac26d71561262da2fdd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad393eeb03469ac26d71561262da2fdd1">&#9670;&#160;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1bhopscotch__map.html#a3e21f04e9276cdeceb1087131db03fcc">const_iterator</a> <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5d1aecfc9203ab4f493ca6359a08cafa" name="a5d1aecfc9203ab4f493ca6359a08cafa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d1aecfc9203ab4f493ca6359a08cafa">&#9670;&#160;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9ab5fdbf4bebfc467f5433d8219d0eff" name="a9ab5fdbf4bebfc467f5433d8219d0eff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ab5fdbf4bebfc467f5433d8219d0eff">&#9670;&#160;</a></span>contains() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; <a class="el" href="classtsl_1_1bhopscotch__map.html#afe54106a1c0379005aca41a7ca47478a">has_is_transparent</a>&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. If so, K must be hashable and comparable to Key. </p>

</div>
</div>
<a id="a894c28b429352193609c63a9d21ca0ac" name="a894c28b429352193609c63a9d21ca0ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a894c28b429352193609c63a9d21ca0ac">&#9670;&#160;</a></span>contains() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; <a class="el" href="classtsl_1_1bhopscotch__map.html#afe54106a1c0379005aca41a7ca47478a">has_is_transparent</a>&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacestd.html#aa30247b5e1a6e192c486364692e37832">std::size_t</a>&#160;</td>
          <td class="paramname"><em>precalculated_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="classtsl_1_1bhopscotch__map.html#a9b8e1e6778d60554f4abf33071965245">hash_function()</a>(key). Useful to speed-up the lookup if you already have the hash. </p>

</div>
</div>
<a id="a4ba60e1f900861b4384f7e18d553b25a" name="a4ba60e1f900861b4384f7e18d553b25a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ba60e1f900861b4384f7e18d553b25a">&#9670;&#160;</a></span>contains() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a23e18961ad6f09032c4eef6404f5e428" name="a23e18961ad6f09032c4eef6404f5e428"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23e18961ad6f09032c4eef6404f5e428">&#9670;&#160;</a></span>contains() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacestd.html#aa30247b5e1a6e192c486364692e37832">std::size_t</a>&#160;</td>
          <td class="paramname"><em>precalculated_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="classtsl_1_1bhopscotch__map.html#a9b8e1e6778d60554f4abf33071965245">hash_function()</a>(key). Useful to speed-up the lookup if you already have the hash. </p>

</div>
</div>
<a id="ae7819f010c5e45046f167e5c11060899" name="ae7819f010c5e45046f167e5c11060899"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7819f010c5e45046f167e5c11060899">&#9670;&#160;</a></span>count() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, class CP  = Compare, typename std::enable_if&lt; <a class="el" href="classtsl_1_1bhopscotch__map.html#afe54106a1c0379005aca41a7ca47478a">has_is_transparent</a>&lt; KE &gt;::value &amp;&amp;<a class="el" href="classtsl_1_1bhopscotch__map.html#afe54106a1c0379005aca41a7ca47478a">has_is_transparent</a>&lt; CP &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1bhopscotch__map.html#a95e38a2030bd61c1466a667daa74753f">size_type</a> <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent and Compare::is_transparent exist. If so, K must be hashable and comparable to Key. </p>

</div>
</div>
<a id="aa90016c38572f2023c8b6848a884cff7" name="aa90016c38572f2023c8b6848a884cff7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa90016c38572f2023c8b6848a884cff7">&#9670;&#160;</a></span>count() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, class CP  = Compare, typename std::enable_if&lt; <a class="el" href="classtsl_1_1bhopscotch__map.html#afe54106a1c0379005aca41a7ca47478a">has_is_transparent</a>&lt; KE &gt;::value &amp;&amp;<a class="el" href="classtsl_1_1bhopscotch__map.html#afe54106a1c0379005aca41a7ca47478a">has_is_transparent</a>&lt; CP &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1bhopscotch__map.html#a95e38a2030bd61c1466a667daa74753f">size_type</a> <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacestd.html#aa30247b5e1a6e192c486364692e37832">std::size_t</a>&#160;</td>
          <td class="paramname"><em>precalculated_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="classtsl_1_1bhopscotch__map.html#a9b8e1e6778d60554f4abf33071965245">hash_function()</a>(key). Useful to speed-up the lookup if you already have the hash. </p>

</div>
</div>
<a id="a3c3254d704e4d0005b0db13258d3e699" name="a3c3254d704e4d0005b0db13258d3e699"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c3254d704e4d0005b0db13258d3e699">&#9670;&#160;</a></span>count() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1bhopscotch__map.html#a95e38a2030bd61c1466a667daa74753f">size_type</a> <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad032e476d2b28d6c102f8c9b1a1aa058" name="ad032e476d2b28d6c102f8c9b1a1aa058"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad032e476d2b28d6c102f8c9b1a1aa058">&#9670;&#160;</a></span>count() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1bhopscotch__map.html#a95e38a2030bd61c1466a667daa74753f">size_type</a> <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacestd.html#aa30247b5e1a6e192c486364692e37832">std::size_t</a>&#160;</td>
          <td class="paramname"><em>precalculated_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="classtsl_1_1bhopscotch__map.html#a9b8e1e6778d60554f4abf33071965245">hash_function()</a>(key). Useful to speed-up the lookup if you already have the hash. </p>

</div>
</div>
<a id="acd25bb0731760f61d9d24640153f3802" name="acd25bb0731760f61d9d24640153f3802"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd25bb0731760f61d9d24640153f3802">&#9670;&#160;</a></span>emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classtsl_1_1bhopscotch__map.html#a966956276ea45c7c32d1bc6bd97b1b79">iterator</a>, bool &gt; <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Due to the way elements are stored, emplace will need to move or copy the key-value once. The method is equivalent to insert(<a class="el" href="classtsl_1_1bhopscotch__map.html#a1bf237363f1ad38d96bcd496db330f3d">value_type(std::forward&lt;Args&gt;(args)...)</a>);</p>
<p>Mainly here for compatibility with the std::unordered_map interface. </p>

</div>
</div>
<a id="a588be89fce26e4b82c222352e2b834f2" name="a588be89fce26e4b82c222352e2b834f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a588be89fce26e4b82c222352e2b834f2">&#9670;&#160;</a></span>emplace_hint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1bhopscotch__map.html#a966956276ea45c7c32d1bc6bd97b1b79">iterator</a> <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::emplace_hint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1bhopscotch__map.html#a3e21f04e9276cdeceb1087131db03fcc">const_iterator</a>&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Due to the way elements are stored, emplace_hint will need to move or copy the key-value once. The method is equivalent to insert(hint, <a class="el" href="classtsl_1_1bhopscotch__map.html#a1bf237363f1ad38d96bcd496db330f3d">value_type(std::forward&lt;Args&gt;(args)...)</a>);</p>
<p>Mainly here for compatibility with the std::unordered_map interface. </p>

</div>
</div>
<a id="ab3954202be241086244999ba1d848445" name="ab3954202be241086244999ba1d848445"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3954202be241086244999ba1d848445">&#9670;&#160;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac0375376cfa6f4d5ee2ed34ceb4ef6d6" name="ac0375376cfa6f4d5ee2ed34ceb4ef6d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0375376cfa6f4d5ee2ed34ceb4ef6d6">&#9670;&#160;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1bhopscotch__map.html#a3e21f04e9276cdeceb1087131db03fcc">const_iterator</a> <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a191d70224ca93946a06b86c7ed9dff71" name="a191d70224ca93946a06b86c7ed9dff71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a191d70224ca93946a06b86c7ed9dff71">&#9670;&#160;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1bhopscotch__map.html#a966956276ea45c7c32d1bc6bd97b1b79">iterator</a> <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aec46520b5e65ba05fab5f9c3504bf703" name="aec46520b5e65ba05fab5f9c3504bf703"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec46520b5e65ba05fab5f9c3504bf703">&#9670;&#160;</a></span>equal_range() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, class CP  = Compare, typename std::enable_if&lt; <a class="el" href="classtsl_1_1bhopscotch__map.html#afe54106a1c0379005aca41a7ca47478a">has_is_transparent</a>&lt; KE &gt;::value &amp;&amp;<a class="el" href="classtsl_1_1bhopscotch__map.html#afe54106a1c0379005aca41a7ca47478a">has_is_transparent</a>&lt; CP &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classtsl_1_1bhopscotch__map.html#a966956276ea45c7c32d1bc6bd97b1b79">iterator</a>, <a class="el" href="classtsl_1_1bhopscotch__map.html#a966956276ea45c7c32d1bc6bd97b1b79">iterator</a> &gt; <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent and Compare::is_transparent exist. If so, K must be hashable and comparable to Key. </p>

</div>
</div>
<a id="a41d61831e913f6684bcc25025da49076" name="a41d61831e913f6684bcc25025da49076"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41d61831e913f6684bcc25025da49076">&#9670;&#160;</a></span>equal_range() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, class CP  = Compare, typename std::enable_if&lt; <a class="el" href="classtsl_1_1bhopscotch__map.html#afe54106a1c0379005aca41a7ca47478a">has_is_transparent</a>&lt; KE &gt;::value &amp;&amp;<a class="el" href="classtsl_1_1bhopscotch__map.html#afe54106a1c0379005aca41a7ca47478a">has_is_transparent</a>&lt; CP &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classtsl_1_1bhopscotch__map.html#a3e21f04e9276cdeceb1087131db03fcc">const_iterator</a>, <a class="el" href="classtsl_1_1bhopscotch__map.html#a3e21f04e9276cdeceb1087131db03fcc">const_iterator</a> &gt; <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8c5622532e940b647b350113d7055db8" name="a8c5622532e940b647b350113d7055db8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c5622532e940b647b350113d7055db8">&#9670;&#160;</a></span>equal_range() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, class CP  = Compare, typename std::enable_if&lt; <a class="el" href="classtsl_1_1bhopscotch__map.html#afe54106a1c0379005aca41a7ca47478a">has_is_transparent</a>&lt; KE &gt;::value &amp;&amp;<a class="el" href="classtsl_1_1bhopscotch__map.html#afe54106a1c0379005aca41a7ca47478a">has_is_transparent</a>&lt; CP &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classtsl_1_1bhopscotch__map.html#a966956276ea45c7c32d1bc6bd97b1b79">iterator</a>, <a class="el" href="classtsl_1_1bhopscotch__map.html#a966956276ea45c7c32d1bc6bd97b1b79">iterator</a> &gt; <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacestd.html#aa30247b5e1a6e192c486364692e37832">std::size_t</a>&#160;</td>
          <td class="paramname"><em>precalculated_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="classtsl_1_1bhopscotch__map.html#a9b8e1e6778d60554f4abf33071965245">hash_function()</a>(key). Useful to speed-up the lookup if you already have the hash. </p>

</div>
</div>
<a id="a5ee0bd5c35c7ceb5821b0b7f2359ab50" name="a5ee0bd5c35c7ceb5821b0b7f2359ab50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ee0bd5c35c7ceb5821b0b7f2359ab50">&#9670;&#160;</a></span>equal_range() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, class CP  = Compare, typename std::enable_if&lt; <a class="el" href="classtsl_1_1bhopscotch__map.html#afe54106a1c0379005aca41a7ca47478a">has_is_transparent</a>&lt; KE &gt;::value &amp;&amp;<a class="el" href="classtsl_1_1bhopscotch__map.html#afe54106a1c0379005aca41a7ca47478a">has_is_transparent</a>&lt; CP &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classtsl_1_1bhopscotch__map.html#a3e21f04e9276cdeceb1087131db03fcc">const_iterator</a>, <a class="el" href="classtsl_1_1bhopscotch__map.html#a3e21f04e9276cdeceb1087131db03fcc">const_iterator</a> &gt; <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacestd.html#aa30247b5e1a6e192c486364692e37832">std::size_t</a>&#160;</td>
          <td class="paramname"><em>precalculated_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa750e05d90eb49831ef93f7fc8bbca96" name="aa750e05d90eb49831ef93f7fc8bbca96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa750e05d90eb49831ef93f7fc8bbca96">&#9670;&#160;</a></span>equal_range() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classtsl_1_1bhopscotch__map.html#a966956276ea45c7c32d1bc6bd97b1b79">iterator</a>, <a class="el" href="classtsl_1_1bhopscotch__map.html#a966956276ea45c7c32d1bc6bd97b1b79">iterator</a> &gt; <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a68bb7024cb59dec1c0479f9cb67e3983" name="a68bb7024cb59dec1c0479f9cb67e3983"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68bb7024cb59dec1c0479f9cb67e3983">&#9670;&#160;</a></span>equal_range() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classtsl_1_1bhopscotch__map.html#a3e21f04e9276cdeceb1087131db03fcc">const_iterator</a>, <a class="el" href="classtsl_1_1bhopscotch__map.html#a3e21f04e9276cdeceb1087131db03fcc">const_iterator</a> &gt; <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab2fb12e0129b505a893306595254e603" name="ab2fb12e0129b505a893306595254e603"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2fb12e0129b505a893306595254e603">&#9670;&#160;</a></span>equal_range() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classtsl_1_1bhopscotch__map.html#a966956276ea45c7c32d1bc6bd97b1b79">iterator</a>, <a class="el" href="classtsl_1_1bhopscotch__map.html#a966956276ea45c7c32d1bc6bd97b1b79">iterator</a> &gt; <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacestd.html#aa30247b5e1a6e192c486364692e37832">std::size_t</a>&#160;</td>
          <td class="paramname"><em>precalculated_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="classtsl_1_1bhopscotch__map.html#a9b8e1e6778d60554f4abf33071965245">hash_function()</a>(key). Useful to speed-up the lookup if you already have the hash. </p>

</div>
</div>
<a id="a2f1f10e1390f2582caef5b0be9f01b7f" name="a2f1f10e1390f2582caef5b0be9f01b7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f1f10e1390f2582caef5b0be9f01b7f">&#9670;&#160;</a></span>equal_range() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classtsl_1_1bhopscotch__map.html#a3e21f04e9276cdeceb1087131db03fcc">const_iterator</a>, <a class="el" href="classtsl_1_1bhopscotch__map.html#a3e21f04e9276cdeceb1087131db03fcc">const_iterator</a> &gt; <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacestd.html#aa30247b5e1a6e192c486364692e37832">std::size_t</a>&#160;</td>
          <td class="paramname"><em>precalculated_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae2fdbd0c173d0bcffe20d8590255cb1a" name="ae2fdbd0c173d0bcffe20d8590255cb1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2fdbd0c173d0bcffe20d8590255cb1a">&#9670;&#160;</a></span>erase() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, class CP  = Compare, typename std::enable_if&lt; <a class="el" href="classtsl_1_1bhopscotch__map.html#afe54106a1c0379005aca41a7ca47478a">has_is_transparent</a>&lt; KE &gt;::value &amp;&amp;<a class="el" href="classtsl_1_1bhopscotch__map.html#afe54106a1c0379005aca41a7ca47478a">has_is_transparent</a>&lt; CP &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1bhopscotch__map.html#a95e38a2030bd61c1466a667daa74753f">size_type</a> <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent and Compare::is_transparent exist. If so, K must be hashable and comparable to Key. </p>

</div>
</div>
<a id="a9eaac48530be5fe69d6d6a03716bcb4f" name="a9eaac48530be5fe69d6d6a03716bcb4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9eaac48530be5fe69d6d6a03716bcb4f">&#9670;&#160;</a></span>erase() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, class CP  = Compare, typename std::enable_if&lt; <a class="el" href="classtsl_1_1bhopscotch__map.html#afe54106a1c0379005aca41a7ca47478a">has_is_transparent</a>&lt; KE &gt;::value &amp;&amp;<a class="el" href="classtsl_1_1bhopscotch__map.html#afe54106a1c0379005aca41a7ca47478a">has_is_transparent</a>&lt; CP &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1bhopscotch__map.html#a95e38a2030bd61c1466a667daa74753f">size_type</a> <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacestd.html#aa30247b5e1a6e192c486364692e37832">std::size_t</a>&#160;</td>
          <td class="paramname"><em>precalculated_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="classtsl_1_1bhopscotch__map.html#a9b8e1e6778d60554f4abf33071965245">hash_function()</a>(key). Useful to speed-up the lookup to the value if you already have the hash. </p>

</div>
</div>
<a id="a49562257e584d512bcb61ae0955ca5c3" name="a49562257e584d512bcb61ae0955ca5c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49562257e584d512bcb61ae0955ca5c3">&#9670;&#160;</a></span>erase() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1bhopscotch__map.html#a95e38a2030bd61c1466a667daa74753f">size_type</a> <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtsl_1_1bhopscotch__map.html#a37f4050e3fd3b6cff23b19f0ce484ee6">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2839fb38a941d484281332c2c14532aa" name="a2839fb38a941d484281332c2c14532aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2839fb38a941d484281332c2c14532aa">&#9670;&#160;</a></span>erase() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1bhopscotch__map.html#a95e38a2030bd61c1466a667daa74753f">size_type</a> <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtsl_1_1bhopscotch__map.html#a37f4050e3fd3b6cff23b19f0ce484ee6">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacestd.html#aa30247b5e1a6e192c486364692e37832">std::size_t</a>&#160;</td>
          <td class="paramname"><em>precalculated_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="classtsl_1_1bhopscotch__map.html#a9b8e1e6778d60554f4abf33071965245">hash_function()</a>(key). Useful to speed-up the lookup to the value if you already have the hash. </p>

</div>
</div>
<a id="aef20287837433776ce2bcc76710c430e" name="aef20287837433776ce2bcc76710c430e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef20287837433776ce2bcc76710c430e">&#9670;&#160;</a></span>erase() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1bhopscotch__map.html#a966956276ea45c7c32d1bc6bd97b1b79">iterator</a> <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1bhopscotch__map.html#a3e21f04e9276cdeceb1087131db03fcc">const_iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtsl_1_1bhopscotch__map.html#a3e21f04e9276cdeceb1087131db03fcc">const_iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a723ea636975667bf8e916e315263f81c" name="a723ea636975667bf8e916e315263f81c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a723ea636975667bf8e916e315263f81c">&#9670;&#160;</a></span>erase() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1bhopscotch__map.html#a966956276ea45c7c32d1bc6bd97b1b79">iterator</a> <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1bhopscotch__map.html#a3e21f04e9276cdeceb1087131db03fcc">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a807d0d1c559348909b4ad90829c2a10a" name="a807d0d1c559348909b4ad90829c2a10a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a807d0d1c559348909b4ad90829c2a10a">&#9670;&#160;</a></span>erase() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1bhopscotch__map.html#a966956276ea45c7c32d1bc6bd97b1b79">iterator</a> <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1bhopscotch__map.html#a966956276ea45c7c32d1bc6bd97b1b79">iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a216a0c1d731e8fb50da4712bc11408da" name="a216a0c1d731e8fb50da4712bc11408da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a216a0c1d731e8fb50da4712bc11408da">&#9670;&#160;</a></span>find() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, class CP  = Compare, typename std::enable_if&lt; <a class="el" href="classtsl_1_1bhopscotch__map.html#afe54106a1c0379005aca41a7ca47478a">has_is_transparent</a>&lt; KE &gt;::value &amp;&amp;<a class="el" href="classtsl_1_1bhopscotch__map.html#afe54106a1c0379005aca41a7ca47478a">has_is_transparent</a>&lt; CP &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1bhopscotch__map.html#a966956276ea45c7c32d1bc6bd97b1b79">iterator</a> <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent and Compare::is_transparent exist. If so, K must be hashable and comparable to Key. </p>

</div>
</div>
<a id="a82dab7bc58be071ff4b7588fece36352" name="a82dab7bc58be071ff4b7588fece36352"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82dab7bc58be071ff4b7588fece36352">&#9670;&#160;</a></span>find() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, class CP  = Compare, typename std::enable_if&lt; <a class="el" href="classtsl_1_1bhopscotch__map.html#afe54106a1c0379005aca41a7ca47478a">has_is_transparent</a>&lt; KE &gt;::value &amp;&amp;<a class="el" href="classtsl_1_1bhopscotch__map.html#afe54106a1c0379005aca41a7ca47478a">has_is_transparent</a>&lt; CP &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1bhopscotch__map.html#a3e21f04e9276cdeceb1087131db03fcc">const_iterator</a> <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad09dc0c4313d33eacf0f79ccbd825535" name="ad09dc0c4313d33eacf0f79ccbd825535"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad09dc0c4313d33eacf0f79ccbd825535">&#9670;&#160;</a></span>find() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, class CP  = Compare, typename std::enable_if&lt; <a class="el" href="classtsl_1_1bhopscotch__map.html#afe54106a1c0379005aca41a7ca47478a">has_is_transparent</a>&lt; KE &gt;::value &amp;&amp;<a class="el" href="classtsl_1_1bhopscotch__map.html#afe54106a1c0379005aca41a7ca47478a">has_is_transparent</a>&lt; CP &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1bhopscotch__map.html#a966956276ea45c7c32d1bc6bd97b1b79">iterator</a> <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacestd.html#aa30247b5e1a6e192c486364692e37832">std::size_t</a>&#160;</td>
          <td class="paramname"><em>precalculated_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="classtsl_1_1bhopscotch__map.html#a9b8e1e6778d60554f4abf33071965245">hash_function()</a>(key). Useful to speed-up the lookup if you already have the hash. </p>

</div>
</div>
<a id="a2f90c27dcc2c227ced0777e8a52f6b8d" name="a2f90c27dcc2c227ced0777e8a52f6b8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f90c27dcc2c227ced0777e8a52f6b8d">&#9670;&#160;</a></span>find() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, class CP  = Compare, typename std::enable_if&lt; <a class="el" href="classtsl_1_1bhopscotch__map.html#afe54106a1c0379005aca41a7ca47478a">has_is_transparent</a>&lt; KE &gt;::value &amp;&amp;<a class="el" href="classtsl_1_1bhopscotch__map.html#afe54106a1c0379005aca41a7ca47478a">has_is_transparent</a>&lt; CP &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1bhopscotch__map.html#a3e21f04e9276cdeceb1087131db03fcc">const_iterator</a> <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacestd.html#aa30247b5e1a6e192c486364692e37832">std::size_t</a>&#160;</td>
          <td class="paramname"><em>precalculated_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2dad311085e5f135d1cb85999e953215" name="a2dad311085e5f135d1cb85999e953215"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dad311085e5f135d1cb85999e953215">&#9670;&#160;</a></span>find() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1bhopscotch__map.html#a966956276ea45c7c32d1bc6bd97b1b79">iterator</a> <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab83f5d7371fe3f50126ee162c0a7aad7" name="ab83f5d7371fe3f50126ee162c0a7aad7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab83f5d7371fe3f50126ee162c0a7aad7">&#9670;&#160;</a></span>find() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1bhopscotch__map.html#a3e21f04e9276cdeceb1087131db03fcc">const_iterator</a> <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abd832ef66a21c5852d63586294801812" name="abd832ef66a21c5852d63586294801812"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd832ef66a21c5852d63586294801812">&#9670;&#160;</a></span>find() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1bhopscotch__map.html#a966956276ea45c7c32d1bc6bd97b1b79">iterator</a> <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacestd.html#aa30247b5e1a6e192c486364692e37832">std::size_t</a>&#160;</td>
          <td class="paramname"><em>precalculated_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="classtsl_1_1bhopscotch__map.html#a9b8e1e6778d60554f4abf33071965245">hash_function()</a>(key). Useful to speed-up the lookup if you already have the hash. </p>

</div>
</div>
<a id="ad64b7927efcf0389b419a8072fb3bdfa" name="ad64b7927efcf0389b419a8072fb3bdfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad64b7927efcf0389b419a8072fb3bdfa">&#9670;&#160;</a></span>find() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1bhopscotch__map.html#a3e21f04e9276cdeceb1087131db03fcc">const_iterator</a> <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacestd.html#aa30247b5e1a6e192c486364692e37832">std::size_t</a>&#160;</td>
          <td class="paramname"><em>precalculated_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3ad6c8106301e5f81e8f60ae1bd65e72" name="a3ad6c8106301e5f81e8f60ae1bd65e72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ad6c8106301e5f81e8f60ae1bd65e72">&#9670;&#160;</a></span>get_allocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1bhopscotch__map.html#a73abd33b2c870e5400f7b22984f8fdac">allocator_type</a> <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9b8e1e6778d60554f4abf33071965245" name="a9b8e1e6778d60554f4abf33071965245"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b8e1e6778d60554f4abf33071965245">&#9670;&#160;</a></span>hash_function()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1bhopscotch__map.html#ab42531c264442155c69f6caf7ddd0f0d">hasher</a> <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::hash_function </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abada02b355efe65206475041f140fa3d" name="abada02b355efe65206475041f140fa3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abada02b355efe65206475041f140fa3d">&#9670;&#160;</a></span>insert() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classtsl_1_1bhopscotch__map.html#a966956276ea45c7c32d1bc6bd97b1b79">iterator</a>, bool &gt; <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtsl_1_1bhopscotch__map.html#a1bf237363f1ad38d96bcd496db330f3d">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7060149d80fce367f33847a67b250316" name="a7060149d80fce367f33847a67b250316"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7060149d80fce367f33847a67b250316">&#9670;&#160;</a></span>insert() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1bhopscotch__map.html#a966956276ea45c7c32d1bc6bd97b1b79">iterator</a> <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1bhopscotch__map.html#a3e21f04e9276cdeceb1087131db03fcc">const_iterator</a>&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtsl_1_1bhopscotch__map.html#a1bf237363f1ad38d96bcd496db330f3d">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3c14bbaa59f7f9d8401388fac40f4893" name="a3c14bbaa59f7f9d8401388fac40f4893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c14bbaa59f7f9d8401388fac40f4893">&#9670;&#160;</a></span>insert() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class P , typename std::enable_if&lt; std::is_constructible&lt; <a class="el" href="classtsl_1_1bhopscotch__map.html#a1bf237363f1ad38d96bcd496db330f3d">value_type</a>, P &amp;&amp; &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1bhopscotch__map.html#a966956276ea45c7c32d1bc6bd97b1b79">iterator</a> <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1bhopscotch__map.html#a3e21f04e9276cdeceb1087131db03fcc">const_iterator</a>&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5acb9e0360c62edc7095ce4bf74e48f5" name="a5acb9e0360c62edc7095ce4bf74e48f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5acb9e0360c62edc7095ce4bf74e48f5">&#9670;&#160;</a></span>insert() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1bhopscotch__map.html#a966956276ea45c7c32d1bc6bd97b1b79">iterator</a> <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1bhopscotch__map.html#a3e21f04e9276cdeceb1087131db03fcc">const_iterator</a>&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtsl_1_1bhopscotch__map.html#a1bf237363f1ad38d96bcd496db330f3d">value_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acf31932fdd34612150858fb8e968d70a" name="acf31932fdd34612150858fb8e968d70a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf31932fdd34612150858fb8e968d70a">&#9670;&#160;</a></span>insert() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3169572b83705c895446b03d65ead6bb" name="a3169572b83705c895446b03d65ead6bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3169572b83705c895446b03d65ead6bb">&#9670;&#160;</a></span>insert() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class P , typename std::enable_if&lt; std::is_constructible&lt; <a class="el" href="classtsl_1_1bhopscotch__map.html#a1bf237363f1ad38d96bcd496db330f3d">value_type</a>, P &amp;&amp; &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classtsl_1_1bhopscotch__map.html#a966956276ea45c7c32d1bc6bd97b1b79">iterator</a>, bool &gt; <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">P &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab349856e33964291b82b5d020f4dabb0" name="ab349856e33964291b82b5d020f4dabb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab349856e33964291b82b5d020f4dabb0">&#9670;&#160;</a></span>insert() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classtsl_1_1bhopscotch__map.html#a1bf237363f1ad38d96bcd496db330f3d">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>ilist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9ba539fd94b46b876a39fba97aa1d12a" name="a9ba539fd94b46b876a39fba97aa1d12a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ba539fd94b46b876a39fba97aa1d12a">&#9670;&#160;</a></span>insert() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classtsl_1_1bhopscotch__map.html#a966956276ea45c7c32d1bc6bd97b1b79">iterator</a>, bool &gt; <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1bhopscotch__map.html#a1bf237363f1ad38d96bcd496db330f3d">value_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aeb3c031a916848d3d8ebe096f9ece8c7" name="aeb3c031a916848d3d8ebe096f9ece8c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb3c031a916848d3d8ebe096f9ece8c7">&#9670;&#160;</a></span>insert_or_assign() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classtsl_1_1bhopscotch__map.html#a966956276ea45c7c32d1bc6bd97b1b79">iterator</a>, bool &gt; <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::insert_or_assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtsl_1_1bhopscotch__map.html#a37f4050e3fd3b6cff23b19f0ce484ee6">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M &amp;&amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4ec35d7a79578bc8fab4aba840a50ae0" name="a4ec35d7a79578bc8fab4aba840a50ae0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ec35d7a79578bc8fab4aba840a50ae0">&#9670;&#160;</a></span>insert_or_assign() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1bhopscotch__map.html#a966956276ea45c7c32d1bc6bd97b1b79">iterator</a> <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::insert_or_assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1bhopscotch__map.html#a3e21f04e9276cdeceb1087131db03fcc">const_iterator</a>&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtsl_1_1bhopscotch__map.html#a37f4050e3fd3b6cff23b19f0ce484ee6">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M &amp;&amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a874a510023d13bdb98a11ead4c784c36" name="a874a510023d13bdb98a11ead4c784c36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a874a510023d13bdb98a11ead4c784c36">&#9670;&#160;</a></span>insert_or_assign() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1bhopscotch__map.html#a966956276ea45c7c32d1bc6bd97b1b79">iterator</a> <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::insert_or_assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1bhopscotch__map.html#a3e21f04e9276cdeceb1087131db03fcc">const_iterator</a>&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtsl_1_1bhopscotch__map.html#a37f4050e3fd3b6cff23b19f0ce484ee6">key_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M &amp;&amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9faab294df205ea0aadafb5a8a3519f3" name="a9faab294df205ea0aadafb5a8a3519f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9faab294df205ea0aadafb5a8a3519f3">&#9670;&#160;</a></span>insert_or_assign() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classtsl_1_1bhopscotch__map.html#a966956276ea45c7c32d1bc6bd97b1b79">iterator</a>, bool &gt; <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::insert_or_assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1bhopscotch__map.html#a37f4050e3fd3b6cff23b19f0ce484ee6">key_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M &amp;&amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5459ee998ed49f3581c29b6338e195fb" name="a5459ee998ed49f3581c29b6338e195fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5459ee998ed49f3581c29b6338e195fb">&#9670;&#160;</a></span>key_comp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1bhopscotch__map.html#a4f1515ae04d28e8f21e0533b3723d10e">key_compare</a> <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::key_comp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a36324da3bbad68403d51a880a38e6178" name="a36324da3bbad68403d51a880a38e6178"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36324da3bbad68403d51a880a38e6178">&#9670;&#160;</a></span>key_eq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1bhopscotch__map.html#ad16fff74a2b4cfefbd97750f2207a668">key_equal</a> <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::key_eq </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9d5a69af11abce38d47da46a314fb6c2" name="a9d5a69af11abce38d47da46a314fb6c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d5a69af11abce38d47da46a314fb6c2">&#9670;&#160;</a></span>load_factor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::load_factor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9c13a40a6497ee39c65086591868b931" name="a9c13a40a6497ee39c65086591868b931"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c13a40a6497ee39c65086591868b931">&#9670;&#160;</a></span>max_bucket_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1bhopscotch__map.html#a95e38a2030bd61c1466a667daa74753f">size_type</a> <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::max_bucket_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aeac654fc816e563ea05d50811d118a00" name="aeac654fc816e563ea05d50811d118a00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeac654fc816e563ea05d50811d118a00">&#9670;&#160;</a></span>max_load_factor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::max_load_factor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac9929ec2d2b3d4eb14b8d701038c5c65" name="ac9929ec2d2b3d4eb14b8d701038c5c65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9929ec2d2b3d4eb14b8d701038c5c65">&#9670;&#160;</a></span>max_load_factor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::max_load_factor </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>ml</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a16d3f0ecb64b15d13312022caa2d8692" name="a16d3f0ecb64b15d13312022caa2d8692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16d3f0ecb64b15d13312022caa2d8692">&#9670;&#160;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1bhopscotch__map.html#a95e38a2030bd61c1466a667daa74753f">size_type</a> <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae6eef4d6fb5c328ff3923bcde606d404" name="ae6eef4d6fb5c328ff3923bcde606d404"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6eef4d6fb5c328ff3923bcde606d404">&#9670;&#160;</a></span>mutable_iterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1bhopscotch__map.html#a966956276ea45c7c32d1bc6bd97b1b79">iterator</a> <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::mutable_iterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1bhopscotch__map.html#a3e21f04e9276cdeceb1087131db03fcc">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert a const_iterator to an iterator. </p>

</div>
</div>
<a id="a60ecb47e3223af63d15e664a6cce62ed" name="a60ecb47e3223af63d15e664a6cce62ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60ecb47e3223af63d15e664a6cce62ed">&#9670;&#160;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1bhopscotch__map.html">bhopscotch_map</a> &amp; <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classtsl_1_1bhopscotch__map.html#a1bf237363f1ad38d96bcd496db330f3d">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>ilist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a858f044e6b42f71df7b4bc253148a8f1" name="a858f044e6b42f71df7b4bc253148a8f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a858f044e6b42f71df7b4bc253148a8f1">&#9670;&#160;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1e82aa2389f0e50809dc1ff00fd4649e" name="a1e82aa2389f0e50809dc1ff00fd4649e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e82aa2389f0e50809dc1ff00fd4649e">&#9670;&#160;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">Key &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2287e06589351a903e74b0687da40e7d" name="a2287e06589351a903e74b0687da40e7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2287e06589351a903e74b0687da40e7d">&#9670;&#160;</a></span>overflow_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1bhopscotch__map.html#a95e38a2030bd61c1466a667daa74753f">size_type</a> <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::overflow_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aaa523e2ad7a589ada2315f4c6f112832" name="aaa523e2ad7a589ada2315f4c6f112832"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa523e2ad7a589ada2315f4c6f112832">&#9670;&#160;</a></span>rehash()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::rehash </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1bhopscotch__map.html#a95e38a2030bd61c1466a667daa74753f">size_type</a>&#160;</td>
          <td class="paramname"><em>count_</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a81dc3cf243066e6de7e9d4813cd07b01" name="a81dc3cf243066e6de7e9d4813cd07b01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81dc3cf243066e6de7e9d4813cd07b01">&#9670;&#160;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1bhopscotch__map.html#a95e38a2030bd61c1466a667daa74753f">size_type</a>&#160;</td>
          <td class="paramname"><em>count_</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a464a64a6c1be84e21b9147a170cdecbd" name="a464a64a6c1be84e21b9147a170cdecbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a464a64a6c1be84e21b9147a170cdecbd">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1bhopscotch__map.html#a95e38a2030bd61c1466a667daa74753f">size_type</a> <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4af554c429a8167b52ba0d5074fdbc83" name="a4af554c429a8167b52ba0d5074fdbc83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4af554c429a8167b52ba0d5074fdbc83">&#9670;&#160;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1bhopscotch__map.html">bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa5387121f7ddeade189bdafa6fbc6155" name="aa5387121f7ddeade189bdafa6fbc6155"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5387121f7ddeade189bdafa6fbc6155">&#9670;&#160;</a></span>try_emplace() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classtsl_1_1bhopscotch__map.html#a966956276ea45c7c32d1bc6bd97b1b79">iterator</a>, bool &gt; <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::try_emplace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtsl_1_1bhopscotch__map.html#a37f4050e3fd3b6cff23b19f0ce484ee6">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a144d9d36457b81936262929b3e0b1092" name="a144d9d36457b81936262929b3e0b1092"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a144d9d36457b81936262929b3e0b1092">&#9670;&#160;</a></span>try_emplace() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1bhopscotch__map.html#a966956276ea45c7c32d1bc6bd97b1b79">iterator</a> <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::try_emplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1bhopscotch__map.html#a3e21f04e9276cdeceb1087131db03fcc">const_iterator</a>&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtsl_1_1bhopscotch__map.html#a37f4050e3fd3b6cff23b19f0ce484ee6">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a186600c4f48a148225fc537a30e38aa3" name="a186600c4f48a148225fc537a30e38aa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a186600c4f48a148225fc537a30e38aa3">&#9670;&#160;</a></span>try_emplace() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1bhopscotch__map.html#a966956276ea45c7c32d1bc6bd97b1b79">iterator</a> <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::try_emplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1bhopscotch__map.html#a3e21f04e9276cdeceb1087131db03fcc">const_iterator</a>&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtsl_1_1bhopscotch__map.html#a37f4050e3fd3b6cff23b19f0ce484ee6">key_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af5b272b60b342066f71fe95e69ce8618" name="af5b272b60b342066f71fe95e69ce8618"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5b272b60b342066f71fe95e69ce8618">&#9670;&#160;</a></span>try_emplace() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classtsl_1_1bhopscotch__map.html#a966956276ea45c7c32d1bc6bd97b1b79">iterator</a>, bool &gt; <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::try_emplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1bhopscotch__map.html#a37f4050e3fd3b6cff23b19f0ce484ee6">key_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="a6b2bd6b393ffe15ec6ef1ee0a1e15c3d" name="a6b2bd6b393ffe15ec6ef1ee0a1e15c3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b2bd6b393ffe15ec6ef1ee0a1e15c3d">&#9670;&#160;</a></span>operator!=</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtsl_1_1bhopscotch__map.html">bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtsl_1_1bhopscotch__map.html">bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6a26a03b4defceeb287620cc62c4275c" name="a6a26a03b4defceeb287620cc62c4275c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a26a03b4defceeb287620cc62c4275c">&#9670;&#160;</a></span>operator==</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtsl_1_1bhopscotch__map.html">bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtsl_1_1bhopscotch__map.html">bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a075de73ae307816baaf5267ba3b895e6" name="a075de73ae307816baaf5267ba3b895e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a075de73ae307816baaf5267ba3b895e6">&#9670;&#160;</a></span>swap</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1bhopscotch__map.html">bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtsl_1_1bhopscotch__map.html">bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a62e185c160404720d3abcd857826318f" name="a62e185c160404720d3abcd857826318f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62e185c160404720d3abcd857826318f">&#9670;&#160;</a></span>m_ht</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Compare  = std::less&lt;Key&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy  = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1bhopscotch__map.html#a506849d576c2306d65487969df20fb6e">ht</a> <a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Compare, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::m_ht</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/<a class="el" href="bhopscotch__map_8h_source.html">bhopscotch_map.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacetsl.html">tsl</a></li><li class="navelem"><a class="el" href="classtsl_1_1bhopscotch__map.html">bhopscotch_map</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7 </li>
  </ul>
</div>
</body>
</html>
