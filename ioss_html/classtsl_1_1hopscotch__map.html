<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>IOSS: tsl::hopscotch_map&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="CustomDoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">IOSS<span id="projectnumber">&#160;2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('classtsl_1_1hopscotch__map.html','','classtsl_1_1hopscotch__map-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">tsl::hopscotch_map&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="hopscotch__map_8h_source.html">hopscotch_map.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for tsl::hopscotch_map&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" loading="lazy" frameborder="0" src="classtsl_1_1hopscotch__map__coll__graph.svg" width="100%" height="516"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:KeySelect" id="r_KeySelect"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1hopscotch__map_1_1KeySelect.html">KeySelect</a></td></tr>
<tr class="memitem:ValueSelect" id="r_ValueSelect"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1hopscotch__map_1_1ValueSelect.html">ValueSelect</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-types" class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a2eae39b540085051068d2c94d3054dd9" id="r_a2eae39b540085051068d2c94d3054dd9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2eae39b540085051068d2c94d3054dd9">key_type</a> = typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#ac2da7bb97307e334553fe9cba15d0689">ht::key_type</a></td></tr>
<tr class="memitem:a115c1d91228c4e0f67571f449b323794" id="r_a115c1d91228c4e0f67571f449b323794"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a115c1d91228c4e0f67571f449b323794">mapped_type</a> = T</td></tr>
<tr class="memitem:aa8775b4f4ca37f0ba1226b6ac8cf37b4" id="r_aa8775b4f4ca37f0ba1226b6ac8cf37b4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa8775b4f4ca37f0ba1226b6ac8cf37b4">value_type</a> = typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#afed3e1f425ac47050c9d8b96c2c5e319">ht::value_type</a></td></tr>
<tr class="memitem:a2ac3b2278e6f731cdf4ac9b12ad62a71" id="r_a2ac3b2278e6f731cdf4ac9b12ad62a71"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2ac3b2278e6f731cdf4ac9b12ad62a71">size_type</a> = typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#a0f2a8dda76d11a1531be2c2e7fb82061">ht::size_type</a></td></tr>
<tr class="memitem:a746e99af4d2728c0284519b9d2beea88" id="r_a746e99af4d2728c0284519b9d2beea88"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a746e99af4d2728c0284519b9d2beea88">difference_type</a> = typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#a3a8a8e910088e7bdbfe63be530d31956">ht::difference_type</a></td></tr>
<tr class="memitem:a45612102bc640807c27d9111b6b84888" id="r_a45612102bc640807c27d9111b6b84888"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a45612102bc640807c27d9111b6b84888">hasher</a> = typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#a0ffe6a6aaa0794dcf4979fc23e583462">ht::hasher</a></td></tr>
<tr class="memitem:a71848c7a83bde13a664d81ab29cfe009" id="r_a71848c7a83bde13a664d81ab29cfe009"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a71848c7a83bde13a664d81ab29cfe009">key_equal</a> = typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#a69a00efe0c98e7d89d3eeb8ef5e43190">ht::key_equal</a></td></tr>
<tr class="memitem:aa1029454117f4dc02a2f8c565fd923ce" id="r_aa1029454117f4dc02a2f8c565fd923ce"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa1029454117f4dc02a2f8c565fd923ce">allocator_type</a> = typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#a8af583783f638a3faac62c52b876aa67">ht::allocator_type</a></td></tr>
<tr class="memitem:a148a927cbaa479eeb208e72f65a7cc6a" id="r_a148a927cbaa479eeb208e72f65a7cc6a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a148a927cbaa479eeb208e72f65a7cc6a">reference</a> = typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#a257bb0ff019c2756bc2c192e76f31ce5">ht::reference</a></td></tr>
<tr class="memitem:a5f8b308813e7b74a4dab48858e961110" id="r_a5f8b308813e7b74a4dab48858e961110"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5f8b308813e7b74a4dab48858e961110">const_reference</a> = typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#ae45966f2a709f1d7f03d42cd19fb29ea">ht::const_reference</a></td></tr>
<tr class="memitem:a10beb351b4ff9c9702a13b6e5df659f7" id="r_a10beb351b4ff9c9702a13b6e5df659f7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a10beb351b4ff9c9702a13b6e5df659f7">pointer</a> = typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#a31276a8ba5b00732857fd0267a5b6fdd">ht::pointer</a></td></tr>
<tr class="memitem:a6ce17bf22290aead159b36b3fc54e78b" id="r_a6ce17bf22290aead159b36b3fc54e78b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ce17bf22290aead159b36b3fc54e78b">const_pointer</a> = typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#a85e8fb0e24e28aef2c0ec4ce9e3f9d01">ht::const_pointer</a></td></tr>
<tr class="memitem:a60f52fac14aebb6fa6a86264d0973db2" id="r_a60f52fac14aebb6fa6a86264d0973db2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a60f52fac14aebb6fa6a86264d0973db2">iterator</a> = typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#ab697c644e6dec536d6ab028ba085b591">ht::iterator</a></td></tr>
<tr class="memitem:ab1f7dbb7b85f2d41b9bf81ab7d5b474f" id="r_ab1f7dbb7b85f2d41b9bf81ab7d5b474f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a> = typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#a2af6f88c2b254b2c9ff83c70eea7c952">ht::const_iterator</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a447530a7b92ad7ed2e902302e10e91b6" id="r_a447530a7b92ad7ed2e902302e10e91b6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a447530a7b92ad7ed2e902302e10e91b6">hopscotch_map</a> ()</td></tr>
<tr class="memitem:a5b3b5f0e68b9f92d2732c3fa74cdcd22" id="r_a5b3b5f0e68b9f92d2732c3fa74cdcd22"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5b3b5f0e68b9f92d2732c3fa74cdcd22">hopscotch_map</a> (<a class="el" href="#a2ac3b2278e6f731cdf4ac9b12ad62a71">size_type</a> <a class="el" href="#aebd0daab184ba503b801be16d5077eb7">bucket_count</a>, const Hash &amp;hash=Hash(), const KeyEqual &amp;equal=KeyEqual(), const Allocator &amp;alloc=Allocator())</td></tr>
<tr class="memitem:a7a370299f055b767aa8bd2e884f6f78a" id="r_a7a370299f055b767aa8bd2e884f6f78a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7a370299f055b767aa8bd2e884f6f78a">hopscotch_map</a> (<a class="el" href="#a2ac3b2278e6f731cdf4ac9b12ad62a71">size_type</a> <a class="el" href="#aebd0daab184ba503b801be16d5077eb7">bucket_count</a>, const Allocator &amp;alloc)</td></tr>
<tr class="memitem:ac49f9a4593db3799f30691547f12569c" id="r_ac49f9a4593db3799f30691547f12569c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac49f9a4593db3799f30691547f12569c">hopscotch_map</a> (<a class="el" href="#a2ac3b2278e6f731cdf4ac9b12ad62a71">size_type</a> <a class="el" href="#aebd0daab184ba503b801be16d5077eb7">bucket_count</a>, const Hash &amp;hash, const Allocator &amp;alloc)</td></tr>
<tr class="memitem:ae4bc1495e4ea36f2cb429b058e847122" id="r_ae4bc1495e4ea36f2cb429b058e847122"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae4bc1495e4ea36f2cb429b058e847122">hopscotch_map</a> (const Allocator &amp;alloc)</td></tr>
<tr class="memitem:a7b4b191e8bea5b17ddded13a532eded7" id="r_a7b4b191e8bea5b17ddded13a532eded7"><td class="memTemplParams" colspan="2">template&lt;class InputIt&gt; </td></tr>
<tr class="memitem:a7b4b191e8bea5b17ddded13a532eded7 template"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b4b191e8bea5b17ddded13a532eded7">hopscotch_map</a> (InputIt first, InputIt last, <a class="el" href="#a2ac3b2278e6f731cdf4ac9b12ad62a71">size_type</a> <a class="el" href="#aebd0daab184ba503b801be16d5077eb7">bucket_count</a>=<a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#a3b4d20d3ff76dd7e703bb18368332368">ht::DEFAULT_INIT_BUCKETS_SIZE</a>, const Hash &amp;hash=Hash(), const KeyEqual &amp;equal=KeyEqual(), const Allocator &amp;alloc=Allocator())</td></tr>
<tr class="memitem:a00bd9fdd26e3984602b456aa0e50ba67" id="r_a00bd9fdd26e3984602b456aa0e50ba67"><td class="memTemplParams" colspan="2">template&lt;class InputIt&gt; </td></tr>
<tr class="memitem:a00bd9fdd26e3984602b456aa0e50ba67 template"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a00bd9fdd26e3984602b456aa0e50ba67">hopscotch_map</a> (InputIt first, InputIt last, <a class="el" href="#a2ac3b2278e6f731cdf4ac9b12ad62a71">size_type</a> <a class="el" href="#aebd0daab184ba503b801be16d5077eb7">bucket_count</a>, const Allocator &amp;alloc)</td></tr>
<tr class="memitem:a4db9d26abc385eebc73c380a6cf95242" id="r_a4db9d26abc385eebc73c380a6cf95242"><td class="memTemplParams" colspan="2">template&lt;class InputIt&gt; </td></tr>
<tr class="memitem:a4db9d26abc385eebc73c380a6cf95242 template"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4db9d26abc385eebc73c380a6cf95242">hopscotch_map</a> (InputIt first, InputIt last, <a class="el" href="#a2ac3b2278e6f731cdf4ac9b12ad62a71">size_type</a> <a class="el" href="#aebd0daab184ba503b801be16d5077eb7">bucket_count</a>, const Hash &amp;hash, const Allocator &amp;alloc)</td></tr>
<tr class="memitem:a7eb86e389b533f4eec6b7d0a77847881" id="r_a7eb86e389b533f4eec6b7d0a77847881"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7eb86e389b533f4eec6b7d0a77847881">hopscotch_map</a> (std::initializer_list&lt; <a class="el" href="#aa8775b4f4ca37f0ba1226b6ac8cf37b4">value_type</a> &gt; init, <a class="el" href="#a2ac3b2278e6f731cdf4ac9b12ad62a71">size_type</a> <a class="el" href="#aebd0daab184ba503b801be16d5077eb7">bucket_count</a>=<a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#a3b4d20d3ff76dd7e703bb18368332368">ht::DEFAULT_INIT_BUCKETS_SIZE</a>, const Hash &amp;hash=Hash(), const KeyEqual &amp;equal=KeyEqual(), const Allocator &amp;alloc=Allocator())</td></tr>
<tr class="memitem:ac09cc7d50fcaae8a841672b8f6054e29" id="r_ac09cc7d50fcaae8a841672b8f6054e29"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac09cc7d50fcaae8a841672b8f6054e29">hopscotch_map</a> (std::initializer_list&lt; <a class="el" href="#aa8775b4f4ca37f0ba1226b6ac8cf37b4">value_type</a> &gt; init, <a class="el" href="#a2ac3b2278e6f731cdf4ac9b12ad62a71">size_type</a> <a class="el" href="#aebd0daab184ba503b801be16d5077eb7">bucket_count</a>, const Allocator &amp;alloc)</td></tr>
<tr class="memitem:a9f411a4dfd00bcbefcd6ca0542b16ee8" id="r_a9f411a4dfd00bcbefcd6ca0542b16ee8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9f411a4dfd00bcbefcd6ca0542b16ee8">hopscotch_map</a> (std::initializer_list&lt; <a class="el" href="#aa8775b4f4ca37f0ba1226b6ac8cf37b4">value_type</a> &gt; init, <a class="el" href="#a2ac3b2278e6f731cdf4ac9b12ad62a71">size_type</a> <a class="el" href="#aebd0daab184ba503b801be16d5077eb7">bucket_count</a>, const Hash &amp;hash, const Allocator &amp;alloc)</td></tr>
<tr class="memitem:aaf79f1726428647a5644d875b0e586f8" id="r_aaf79f1726428647a5644d875b0e586f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1hopscotch__map.html">hopscotch_map</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaf79f1726428647a5644d875b0e586f8">operator=</a> (std::initializer_list&lt; <a class="el" href="#aa8775b4f4ca37f0ba1226b6ac8cf37b4">value_type</a> &gt; ilist)</td></tr>
<tr class="memitem:adff56f4907ab6625b61c64fbf7df92bd" id="r_adff56f4907ab6625b61c64fbf7df92bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#aa1029454117f4dc02a2f8c565fd923ce">allocator_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adff56f4907ab6625b61c64fbf7df92bd">get_allocator</a> () const</td></tr>
<tr class="memitem:a427075830599fc53bcd649b4a14d5bde" id="r_a427075830599fc53bcd649b4a14d5bde"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a60f52fac14aebb6fa6a86264d0973db2">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a427075830599fc53bcd649b4a14d5bde">begin</a> () noexcept</td></tr>
<tr class="memitem:a441ea957f3a7fe842867a289742c3d0f" id="r_a441ea957f3a7fe842867a289742c3d0f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a441ea957f3a7fe842867a289742c3d0f">begin</a> () const noexcept</td></tr>
<tr class="memitem:a4406ad14b90cd52b766d551029e88cb7" id="r_a4406ad14b90cd52b766d551029e88cb7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4406ad14b90cd52b766d551029e88cb7">cbegin</a> () const noexcept</td></tr>
<tr class="memitem:a2e3f3585aa1f4c830ff7e8eced1e8a6f" id="r_a2e3f3585aa1f4c830ff7e8eced1e8a6f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a60f52fac14aebb6fa6a86264d0973db2">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2e3f3585aa1f4c830ff7e8eced1e8a6f">end</a> () noexcept</td></tr>
<tr class="memitem:a43571f72a4b43740ea45b1e219da3013" id="r_a43571f72a4b43740ea45b1e219da3013"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a43571f72a4b43740ea45b1e219da3013">end</a> () const noexcept</td></tr>
<tr class="memitem:a0e27dbe412d061b26576a36936825949" id="r_a0e27dbe412d061b26576a36936825949"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0e27dbe412d061b26576a36936825949">cend</a> () const noexcept</td></tr>
<tr class="memitem:ae41b459d21ab54d516812206a481806b" id="r_ae41b459d21ab54d516812206a481806b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae41b459d21ab54d516812206a481806b">empty</a> () const noexcept</td></tr>
<tr class="memitem:a4927ca3c49b36756a1d4ade22ac4c59f" id="r_a4927ca3c49b36756a1d4ade22ac4c59f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a2ac3b2278e6f731cdf4ac9b12ad62a71">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4927ca3c49b36756a1d4ade22ac4c59f">size</a> () const noexcept</td></tr>
<tr class="memitem:ae004c2c0b10d1fb1942d5d78b7461aee" id="r_ae004c2c0b10d1fb1942d5d78b7461aee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a2ac3b2278e6f731cdf4ac9b12ad62a71">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae004c2c0b10d1fb1942d5d78b7461aee">max_size</a> () const noexcept</td></tr>
<tr class="memitem:a1aa591920de994ce89ec87cf0be5b84b" id="r_a1aa591920de994ce89ec87cf0be5b84b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1aa591920de994ce89ec87cf0be5b84b">clear</a> () noexcept</td></tr>
<tr class="memitem:a2c0811c3e9706fab4208bd4269db1d19" id="r_a2c0811c3e9706fab4208bd4269db1d19"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="#a60f52fac14aebb6fa6a86264d0973db2">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c0811c3e9706fab4208bd4269db1d19">insert</a> (const <a class="el" href="#aa8775b4f4ca37f0ba1226b6ac8cf37b4">value_type</a> &amp;value)</td></tr>
<tr class="memitem:ae46e7a33531b477b2d2477d264ee772e" id="r_ae46e7a33531b477b2d2477d264ee772e"><td class="memTemplParams" colspan="2">template&lt;class P, typename std::enable_if&lt; std::is_constructible&lt; <a class="el" href="#aa8775b4f4ca37f0ba1226b6ac8cf37b4">value_type</a>, P &amp;&amp; &gt;::value &gt;::type * = nullptr&gt; </td></tr>
<tr class="memitem:ae46e7a33531b477b2d2477d264ee772e template"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="#a60f52fac14aebb6fa6a86264d0973db2">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae46e7a33531b477b2d2477d264ee772e">insert</a> (P &amp;&amp;value)</td></tr>
<tr class="memitem:a6a6c4f61eeac7999fd94c5f3fe8646a7" id="r_a6a6c4f61eeac7999fd94c5f3fe8646a7"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="#a60f52fac14aebb6fa6a86264d0973db2">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6a6c4f61eeac7999fd94c5f3fe8646a7">insert</a> (<a class="el" href="#aa8775b4f4ca37f0ba1226b6ac8cf37b4">value_type</a> &amp;&amp;value)</td></tr>
<tr class="memitem:a11dd9d1f9df86cceb2b4b910de7b959e" id="r_a11dd9d1f9df86cceb2b4b910de7b959e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a60f52fac14aebb6fa6a86264d0973db2">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a11dd9d1f9df86cceb2b4b910de7b959e">insert</a> (<a class="el" href="#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a> hint, const <a class="el" href="#aa8775b4f4ca37f0ba1226b6ac8cf37b4">value_type</a> &amp;value)</td></tr>
<tr class="memitem:ab34c3cdf30912908d289fde716cd1892" id="r_ab34c3cdf30912908d289fde716cd1892"><td class="memTemplParams" colspan="2">template&lt;class P, typename std::enable_if&lt; std::is_constructible&lt; <a class="el" href="#aa8775b4f4ca37f0ba1226b6ac8cf37b4">value_type</a>, P &amp;&amp; &gt;::value &gt;::type * = nullptr&gt; </td></tr>
<tr class="memitem:ab34c3cdf30912908d289fde716cd1892 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a60f52fac14aebb6fa6a86264d0973db2">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab34c3cdf30912908d289fde716cd1892">insert</a> (<a class="el" href="#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a> hint, P &amp;&amp;value)</td></tr>
<tr class="memitem:ac194248ad6b5d71478beb5867b0e7f56" id="r_ac194248ad6b5d71478beb5867b0e7f56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a60f52fac14aebb6fa6a86264d0973db2">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac194248ad6b5d71478beb5867b0e7f56">insert</a> (<a class="el" href="#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a> hint, <a class="el" href="#aa8775b4f4ca37f0ba1226b6ac8cf37b4">value_type</a> &amp;&amp;value)</td></tr>
<tr class="memitem:a50df14a0a6829e7b8bf4cf96287cd7fa" id="r_a50df14a0a6829e7b8bf4cf96287cd7fa"><td class="memTemplParams" colspan="2">template&lt;class InputIt&gt; </td></tr>
<tr class="memitem:a50df14a0a6829e7b8bf4cf96287cd7fa template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a50df14a0a6829e7b8bf4cf96287cd7fa">insert</a> (InputIt first, InputIt last)</td></tr>
<tr class="memitem:a13fcf313641cc7af76b1457867c16fe6" id="r_a13fcf313641cc7af76b1457867c16fe6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a13fcf313641cc7af76b1457867c16fe6">insert</a> (std::initializer_list&lt; <a class="el" href="#aa8775b4f4ca37f0ba1226b6ac8cf37b4">value_type</a> &gt; ilist)</td></tr>
<tr class="memitem:a97f7b5bb64c9758a156dbb6b43f67a41" id="r_a97f7b5bb64c9758a156dbb6b43f67a41"><td class="memTemplParams" colspan="2">template&lt;class M&gt; </td></tr>
<tr class="memitem:a97f7b5bb64c9758a156dbb6b43f67a41 template"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="#a60f52fac14aebb6fa6a86264d0973db2">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a97f7b5bb64c9758a156dbb6b43f67a41">insert_or_assign</a> (const <a class="el" href="#a2eae39b540085051068d2c94d3054dd9">key_type</a> &amp;k, M &amp;&amp;obj)</td></tr>
<tr class="memitem:a8cdcf51e4bbf7ec455f24c1298c8f6e5" id="r_a8cdcf51e4bbf7ec455f24c1298c8f6e5"><td class="memTemplParams" colspan="2">template&lt;class M&gt; </td></tr>
<tr class="memitem:a8cdcf51e4bbf7ec455f24c1298c8f6e5 template"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="#a60f52fac14aebb6fa6a86264d0973db2">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8cdcf51e4bbf7ec455f24c1298c8f6e5">insert_or_assign</a> (<a class="el" href="#a2eae39b540085051068d2c94d3054dd9">key_type</a> &amp;&amp;k, M &amp;&amp;obj)</td></tr>
<tr class="memitem:a30d6b3065037c40dabf7d415b1ca1d7d" id="r_a30d6b3065037c40dabf7d415b1ca1d7d"><td class="memTemplParams" colspan="2">template&lt;class M&gt; </td></tr>
<tr class="memitem:a30d6b3065037c40dabf7d415b1ca1d7d template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a60f52fac14aebb6fa6a86264d0973db2">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a30d6b3065037c40dabf7d415b1ca1d7d">insert_or_assign</a> (<a class="el" href="#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a> hint, const <a class="el" href="#a2eae39b540085051068d2c94d3054dd9">key_type</a> &amp;k, M &amp;&amp;obj)</td></tr>
<tr class="memitem:a5df8328a9edf3f97fc25023a8462f6e1" id="r_a5df8328a9edf3f97fc25023a8462f6e1"><td class="memTemplParams" colspan="2">template&lt;class M&gt; </td></tr>
<tr class="memitem:a5df8328a9edf3f97fc25023a8462f6e1 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a60f52fac14aebb6fa6a86264d0973db2">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5df8328a9edf3f97fc25023a8462f6e1">insert_or_assign</a> (<a class="el" href="#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a> hint, <a class="el" href="#a2eae39b540085051068d2c94d3054dd9">key_type</a> &amp;&amp;k, M &amp;&amp;obj)</td></tr>
<tr class="memitem:ac2a164e64fe903a19c9433bbc3c97993" id="r_ac2a164e64fe903a19c9433bbc3c97993"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:ac2a164e64fe903a19c9433bbc3c97993 template"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="#a60f52fac14aebb6fa6a86264d0973db2">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac2a164e64fe903a19c9433bbc3c97993">emplace</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memitem:a8e19112ef0f633a107ce3fa6d6a4b3ae" id="r_a8e19112ef0f633a107ce3fa6d6a4b3ae"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a8e19112ef0f633a107ce3fa6d6a4b3ae template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a60f52fac14aebb6fa6a86264d0973db2">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8e19112ef0f633a107ce3fa6d6a4b3ae">emplace_hint</a> (<a class="el" href="#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a> hint, Args &amp;&amp;...args)</td></tr>
<tr class="memitem:a08910966619e06befc115231e42c4b97" id="r_a08910966619e06befc115231e42c4b97"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a08910966619e06befc115231e42c4b97 template"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="#a60f52fac14aebb6fa6a86264d0973db2">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a08910966619e06befc115231e42c4b97">try_emplace</a> (const <a class="el" href="#a2eae39b540085051068d2c94d3054dd9">key_type</a> &amp;k, Args &amp;&amp;...args)</td></tr>
<tr class="memitem:ab7decfabbefd86390736adfe9e3a4c51" id="r_ab7decfabbefd86390736adfe9e3a4c51"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:ab7decfabbefd86390736adfe9e3a4c51 template"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="#a60f52fac14aebb6fa6a86264d0973db2">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab7decfabbefd86390736adfe9e3a4c51">try_emplace</a> (<a class="el" href="#a2eae39b540085051068d2c94d3054dd9">key_type</a> &amp;&amp;k, Args &amp;&amp;...args)</td></tr>
<tr class="memitem:abd207994b368fb2d3e6c2e191e6f3de6" id="r_abd207994b368fb2d3e6c2e191e6f3de6"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:abd207994b368fb2d3e6c2e191e6f3de6 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a60f52fac14aebb6fa6a86264d0973db2">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abd207994b368fb2d3e6c2e191e6f3de6">try_emplace</a> (<a class="el" href="#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a> hint, const <a class="el" href="#a2eae39b540085051068d2c94d3054dd9">key_type</a> &amp;k, Args &amp;&amp;...args)</td></tr>
<tr class="memitem:a6476b1ccca8e5f1621dfe7b8674568fb" id="r_a6476b1ccca8e5f1621dfe7b8674568fb"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a6476b1ccca8e5f1621dfe7b8674568fb template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a60f52fac14aebb6fa6a86264d0973db2">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6476b1ccca8e5f1621dfe7b8674568fb">try_emplace</a> (<a class="el" href="#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a> hint, <a class="el" href="#a2eae39b540085051068d2c94d3054dd9">key_type</a> &amp;&amp;k, Args &amp;&amp;...args)</td></tr>
<tr class="memitem:a26ee0d0bff7224e9e130150ff183bdeb" id="r_a26ee0d0bff7224e9e130150ff183bdeb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a60f52fac14aebb6fa6a86264d0973db2">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a26ee0d0bff7224e9e130150ff183bdeb">erase</a> (<a class="el" href="#a60f52fac14aebb6fa6a86264d0973db2">iterator</a> pos)</td></tr>
<tr class="memitem:a2e4ba064d2ead6b7e9d20e9f4902a1ca" id="r_a2e4ba064d2ead6b7e9d20e9f4902a1ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a60f52fac14aebb6fa6a86264d0973db2">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2e4ba064d2ead6b7e9d20e9f4902a1ca">erase</a> (<a class="el" href="#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a> pos)</td></tr>
<tr class="memitem:a3416ddb5a149fffa931c10439a074d41" id="r_a3416ddb5a149fffa931c10439a074d41"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a60f52fac14aebb6fa6a86264d0973db2">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3416ddb5a149fffa931c10439a074d41">erase</a> (<a class="el" href="#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a> first, <a class="el" href="#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a> last)</td></tr>
<tr class="memitem:a0e093bee93337aa1e89a610d53764824" id="r_a0e093bee93337aa1e89a610d53764824"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a2ac3b2278e6f731cdf4ac9b12ad62a71">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0e093bee93337aa1e89a610d53764824">erase</a> (const <a class="el" href="#a2eae39b540085051068d2c94d3054dd9">key_type</a> &amp;key)</td></tr>
<tr class="memitem:a2826de34d69c27b61432113e7c241c1b" id="r_a2826de34d69c27b61432113e7c241c1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a2ac3b2278e6f731cdf4ac9b12ad62a71">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2826de34d69c27b61432113e7c241c1b">erase</a> (const <a class="el" href="#a2eae39b540085051068d2c94d3054dd9">key_type</a> &amp;key, std::size_t precalculated_hash)</td></tr>
<tr class="memitem:a741fb9bd476e91d66237c27e9260d464" id="r_a741fb9bd476e91d66237c27e9260d464"><td class="memTemplParams" colspan="2">template&lt;class K, class KE = KeyEqual, typename std::enable_if&lt; <a class="el" href="#ad704d9c5b38b382aa4ce5c9acb962055">has_is_transparent</a>&lt; KE &gt;::value &gt;::type * = nullptr&gt; </td></tr>
<tr class="memitem:a741fb9bd476e91d66237c27e9260d464 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a2ac3b2278e6f731cdf4ac9b12ad62a71">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a741fb9bd476e91d66237c27e9260d464">erase</a> (const K &amp;key)</td></tr>
<tr class="memitem:a96c4d38aaa226f95006c28a69f8b7748" id="r_a96c4d38aaa226f95006c28a69f8b7748"><td class="memTemplParams" colspan="2">template&lt;class K, class KE = KeyEqual, typename std::enable_if&lt; <a class="el" href="#ad704d9c5b38b382aa4ce5c9acb962055">has_is_transparent</a>&lt; KE &gt;::value &gt;::type * = nullptr&gt; </td></tr>
<tr class="memitem:a96c4d38aaa226f95006c28a69f8b7748 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a2ac3b2278e6f731cdf4ac9b12ad62a71">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a96c4d38aaa226f95006c28a69f8b7748">erase</a> (const K &amp;key, std::size_t precalculated_hash)</td></tr>
<tr class="memitem:a51f88bfcbc06111a158ed7afbe004a7b" id="r_a51f88bfcbc06111a158ed7afbe004a7b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a51f88bfcbc06111a158ed7afbe004a7b">swap</a> (<a class="el" href="classtsl_1_1hopscotch__map.html">hopscotch_map</a> &amp;other)</td></tr>
<tr class="memitem:ad0375313463327f66099eb7e3fc17758" id="r_ad0375313463327f66099eb7e3fc17758"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad0375313463327f66099eb7e3fc17758">at</a> (const Key &amp;key)</td></tr>
<tr class="memitem:aa5cd8fc477ecd692404a98efde039d76" id="r_aa5cd8fc477ecd692404a98efde039d76"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa5cd8fc477ecd692404a98efde039d76">at</a> (const Key &amp;key, std::size_t precalculated_hash)</td></tr>
<tr class="memitem:a4a731129ba4ead23c1144cfce0ab9fc2" id="r_a4a731129ba4ead23c1144cfce0ab9fc2"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4a731129ba4ead23c1144cfce0ab9fc2">at</a> (const Key &amp;key) const</td></tr>
<tr class="memitem:a976efddd6fef23b11bc6288cc8cb74ec" id="r_a976efddd6fef23b11bc6288cc8cb74ec"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a976efddd6fef23b11bc6288cc8cb74ec">at</a> (const Key &amp;key, std::size_t precalculated_hash) const</td></tr>
<tr class="memitem:a553a35b5c3a2421534fdc9984b54692b" id="r_a553a35b5c3a2421534fdc9984b54692b"><td class="memTemplParams" colspan="2">template&lt;class K, class KE = KeyEqual, typename std::enable_if&lt; <a class="el" href="#ad704d9c5b38b382aa4ce5c9acb962055">has_is_transparent</a>&lt; KE &gt;::value &gt;::type * = nullptr&gt; </td></tr>
<tr class="memitem:a553a35b5c3a2421534fdc9984b54692b template"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a553a35b5c3a2421534fdc9984b54692b">at</a> (const K &amp;key)</td></tr>
<tr class="memitem:a695930b6f2e98e1d92f5481c73584d67" id="r_a695930b6f2e98e1d92f5481c73584d67"><td class="memTemplParams" colspan="2">template&lt;class K, class KE = KeyEqual, typename std::enable_if&lt; <a class="el" href="#ad704d9c5b38b382aa4ce5c9acb962055">has_is_transparent</a>&lt; KE &gt;::value &gt;::type * = nullptr&gt; </td></tr>
<tr class="memitem:a695930b6f2e98e1d92f5481c73584d67 template"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a695930b6f2e98e1d92f5481c73584d67">at</a> (const K &amp;key, std::size_t precalculated_hash)</td></tr>
<tr class="memitem:a1d44c2749c6135804307168eb6034408" id="r_a1d44c2749c6135804307168eb6034408"><td class="memTemplParams" colspan="2">template&lt;class K, class KE = KeyEqual, typename std::enable_if&lt; <a class="el" href="#ad704d9c5b38b382aa4ce5c9acb962055">has_is_transparent</a>&lt; KE &gt;::value &gt;::type * = nullptr&gt; </td></tr>
<tr class="memitem:a1d44c2749c6135804307168eb6034408 template"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1d44c2749c6135804307168eb6034408">at</a> (const K &amp;key) const</td></tr>
<tr class="memitem:a25b9d072a4e6f40ef62d994a90462f02" id="r_a25b9d072a4e6f40ef62d994a90462f02"><td class="memTemplParams" colspan="2">template&lt;class K, class KE = KeyEqual, typename std::enable_if&lt; <a class="el" href="#ad704d9c5b38b382aa4ce5c9acb962055">has_is_transparent</a>&lt; KE &gt;::value &gt;::type * = nullptr&gt; </td></tr>
<tr class="memitem:a25b9d072a4e6f40ef62d994a90462f02 template"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a25b9d072a4e6f40ef62d994a90462f02">at</a> (const K &amp;key, std::size_t precalculated_hash) const</td></tr>
<tr class="memitem:a66b1af51a5bd60733c2d826379c5843d" id="r_a66b1af51a5bd60733c2d826379c5843d"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a66b1af51a5bd60733c2d826379c5843d">operator[]</a> (const Key &amp;key)</td></tr>
<tr class="memitem:a0cfddf9b6813db5dc8050e09ecd011ee" id="r_a0cfddf9b6813db5dc8050e09ecd011ee"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0cfddf9b6813db5dc8050e09ecd011ee">operator[]</a> (Key &amp;&amp;key)</td></tr>
<tr class="memitem:a0a88790c4f7555a99e2abc12a562bd34" id="r_a0a88790c4f7555a99e2abc12a562bd34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a2ac3b2278e6f731cdf4ac9b12ad62a71">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0a88790c4f7555a99e2abc12a562bd34">count</a> (const Key &amp;key) const</td></tr>
<tr class="memitem:adf3c1b1905c8a12f9cff07f105459e58" id="r_adf3c1b1905c8a12f9cff07f105459e58"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a2ac3b2278e6f731cdf4ac9b12ad62a71">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adf3c1b1905c8a12f9cff07f105459e58">count</a> (const Key &amp;key, std::size_t precalculated_hash) const</td></tr>
<tr class="memitem:ae9a31a7772dfe4f6085e8d87ba423c33" id="r_ae9a31a7772dfe4f6085e8d87ba423c33"><td class="memTemplParams" colspan="2">template&lt;class K, class KE = KeyEqual, typename std::enable_if&lt; <a class="el" href="#ad704d9c5b38b382aa4ce5c9acb962055">has_is_transparent</a>&lt; KE &gt;::value &gt;::type * = nullptr&gt; </td></tr>
<tr class="memitem:ae9a31a7772dfe4f6085e8d87ba423c33 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a2ac3b2278e6f731cdf4ac9b12ad62a71">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae9a31a7772dfe4f6085e8d87ba423c33">count</a> (const K &amp;key) const</td></tr>
<tr class="memitem:a9adb70f22857b567dbb0627d32e49b02" id="r_a9adb70f22857b567dbb0627d32e49b02"><td class="memTemplParams" colspan="2">template&lt;class K, class KE = KeyEqual, typename std::enable_if&lt; <a class="el" href="#ad704d9c5b38b382aa4ce5c9acb962055">has_is_transparent</a>&lt; KE &gt;::value &gt;::type * = nullptr&gt; </td></tr>
<tr class="memitem:a9adb70f22857b567dbb0627d32e49b02 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a2ac3b2278e6f731cdf4ac9b12ad62a71">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9adb70f22857b567dbb0627d32e49b02">count</a> (const K &amp;key, std::size_t precalculated_hash) const</td></tr>
<tr class="memitem:afd20a86de3dbedd12c68e62703067138" id="r_afd20a86de3dbedd12c68e62703067138"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a60f52fac14aebb6fa6a86264d0973db2">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afd20a86de3dbedd12c68e62703067138">find</a> (const Key &amp;key)</td></tr>
<tr class="memitem:a74d83c67c50bc8385bb11f78142eaa86" id="r_a74d83c67c50bc8385bb11f78142eaa86"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a60f52fac14aebb6fa6a86264d0973db2">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a74d83c67c50bc8385bb11f78142eaa86">find</a> (const Key &amp;key, std::size_t precalculated_hash)</td></tr>
<tr class="memitem:aa09cbacc3b8fb8c99a06814df0b86c4b" id="r_aa09cbacc3b8fb8c99a06814df0b86c4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa09cbacc3b8fb8c99a06814df0b86c4b">find</a> (const Key &amp;key) const</td></tr>
<tr class="memitem:ae6657238499a01a4ce1d6b9357b60eeb" id="r_ae6657238499a01a4ce1d6b9357b60eeb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae6657238499a01a4ce1d6b9357b60eeb">find</a> (const Key &amp;key, std::size_t precalculated_hash) const</td></tr>
<tr class="memitem:aecc9cfa53edaae65f26aa35e1aa6b7d6" id="r_aecc9cfa53edaae65f26aa35e1aa6b7d6"><td class="memTemplParams" colspan="2">template&lt;class K, class KE = KeyEqual, typename std::enable_if&lt; <a class="el" href="#ad704d9c5b38b382aa4ce5c9acb962055">has_is_transparent</a>&lt; KE &gt;::value &gt;::type * = nullptr&gt; </td></tr>
<tr class="memitem:aecc9cfa53edaae65f26aa35e1aa6b7d6 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a60f52fac14aebb6fa6a86264d0973db2">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aecc9cfa53edaae65f26aa35e1aa6b7d6">find</a> (const K &amp;key)</td></tr>
<tr class="memitem:a1b223caffda7b47d565572425b1f3ea3" id="r_a1b223caffda7b47d565572425b1f3ea3"><td class="memTemplParams" colspan="2">template&lt;class K, class KE = KeyEqual, typename std::enable_if&lt; <a class="el" href="#ad704d9c5b38b382aa4ce5c9acb962055">has_is_transparent</a>&lt; KE &gt;::value &gt;::type * = nullptr&gt; </td></tr>
<tr class="memitem:a1b223caffda7b47d565572425b1f3ea3 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a60f52fac14aebb6fa6a86264d0973db2">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1b223caffda7b47d565572425b1f3ea3">find</a> (const K &amp;key, std::size_t precalculated_hash)</td></tr>
<tr class="memitem:aec9ad2d6a7584d98ad2e06e5b880d0d8" id="r_aec9ad2d6a7584d98ad2e06e5b880d0d8"><td class="memTemplParams" colspan="2">template&lt;class K, class KE = KeyEqual, typename std::enable_if&lt; <a class="el" href="#ad704d9c5b38b382aa4ce5c9acb962055">has_is_transparent</a>&lt; KE &gt;::value &gt;::type * = nullptr&gt; </td></tr>
<tr class="memitem:aec9ad2d6a7584d98ad2e06e5b880d0d8 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aec9ad2d6a7584d98ad2e06e5b880d0d8">find</a> (const K &amp;key) const</td></tr>
<tr class="memitem:a55394bfd3c779b1bdde87fd18876f411" id="r_a55394bfd3c779b1bdde87fd18876f411"><td class="memTemplParams" colspan="2">template&lt;class K, class KE = KeyEqual, typename std::enable_if&lt; <a class="el" href="#ad704d9c5b38b382aa4ce5c9acb962055">has_is_transparent</a>&lt; KE &gt;::value &gt;::type * = nullptr&gt; </td></tr>
<tr class="memitem:a55394bfd3c779b1bdde87fd18876f411 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a55394bfd3c779b1bdde87fd18876f411">find</a> (const K &amp;key, std::size_t precalculated_hash) const</td></tr>
<tr class="memitem:a69f1bd19068900061d5a5a551481465e" id="r_a69f1bd19068900061d5a5a551481465e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a69f1bd19068900061d5a5a551481465e">contains</a> (const Key &amp;key) const</td></tr>
<tr class="memitem:ab83e5e6a0c35d64c5d50d6356b0d0e2e" id="r_ab83e5e6a0c35d64c5d50d6356b0d0e2e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab83e5e6a0c35d64c5d50d6356b0d0e2e">contains</a> (const Key &amp;key, std::size_t precalculated_hash) const</td></tr>
<tr class="memitem:a0255617434505dfc064ce49c1bfe7ac0" id="r_a0255617434505dfc064ce49c1bfe7ac0"><td class="memTemplParams" colspan="2">template&lt;class K, class KE = KeyEqual, typename std::enable_if&lt; <a class="el" href="#ad704d9c5b38b382aa4ce5c9acb962055">has_is_transparent</a>&lt; KE &gt;::value &gt;::type * = nullptr&gt; </td></tr>
<tr class="memitem:a0255617434505dfc064ce49c1bfe7ac0 template"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0255617434505dfc064ce49c1bfe7ac0">contains</a> (const K &amp;key) const</td></tr>
<tr class="memitem:a5f816462a64e868612e8a571eec98e34" id="r_a5f816462a64e868612e8a571eec98e34"><td class="memTemplParams" colspan="2">template&lt;class K, class KE = KeyEqual, typename std::enable_if&lt; <a class="el" href="#ad704d9c5b38b382aa4ce5c9acb962055">has_is_transparent</a>&lt; KE &gt;::value &gt;::type * = nullptr&gt; </td></tr>
<tr class="memitem:a5f816462a64e868612e8a571eec98e34 template"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5f816462a64e868612e8a571eec98e34">contains</a> (const K &amp;key, std::size_t precalculated_hash) const</td></tr>
<tr class="memitem:a7cda8ef0abd9543c7caecf34692b3f09" id="r_a7cda8ef0abd9543c7caecf34692b3f09"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="#a60f52fac14aebb6fa6a86264d0973db2">iterator</a>, <a class="el" href="#a60f52fac14aebb6fa6a86264d0973db2">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7cda8ef0abd9543c7caecf34692b3f09">equal_range</a> (const Key &amp;key)</td></tr>
<tr class="memitem:a3327e41731e9fe4dc30dd19fd52341c3" id="r_a3327e41731e9fe4dc30dd19fd52341c3"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="#a60f52fac14aebb6fa6a86264d0973db2">iterator</a>, <a class="el" href="#a60f52fac14aebb6fa6a86264d0973db2">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3327e41731e9fe4dc30dd19fd52341c3">equal_range</a> (const Key &amp;key, std::size_t precalculated_hash)</td></tr>
<tr class="memitem:abff7564061f3d5be473e620fe93b1787" id="r_abff7564061f3d5be473e620fe93b1787"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a>, <a class="el" href="#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abff7564061f3d5be473e620fe93b1787">equal_range</a> (const Key &amp;key) const</td></tr>
<tr class="memitem:afc1499fbdda0eb52be0cedd9e91b77a2" id="r_afc1499fbdda0eb52be0cedd9e91b77a2"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a>, <a class="el" href="#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afc1499fbdda0eb52be0cedd9e91b77a2">equal_range</a> (const Key &amp;key, std::size_t precalculated_hash) const</td></tr>
<tr class="memitem:aba04a4f687160d347d1ea3fb8333db08" id="r_aba04a4f687160d347d1ea3fb8333db08"><td class="memTemplParams" colspan="2">template&lt;class K, class KE = KeyEqual, typename std::enable_if&lt; <a class="el" href="#ad704d9c5b38b382aa4ce5c9acb962055">has_is_transparent</a>&lt; KE &gt;::value &gt;::type * = nullptr&gt; </td></tr>
<tr class="memitem:aba04a4f687160d347d1ea3fb8333db08 template"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="#a60f52fac14aebb6fa6a86264d0973db2">iterator</a>, <a class="el" href="#a60f52fac14aebb6fa6a86264d0973db2">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aba04a4f687160d347d1ea3fb8333db08">equal_range</a> (const K &amp;key)</td></tr>
<tr class="memitem:a17989802955657e7b4b94cefa44e6559" id="r_a17989802955657e7b4b94cefa44e6559"><td class="memTemplParams" colspan="2">template&lt;class K, class KE = KeyEqual, typename std::enable_if&lt; <a class="el" href="#ad704d9c5b38b382aa4ce5c9acb962055">has_is_transparent</a>&lt; KE &gt;::value &gt;::type * = nullptr&gt; </td></tr>
<tr class="memitem:a17989802955657e7b4b94cefa44e6559 template"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="#a60f52fac14aebb6fa6a86264d0973db2">iterator</a>, <a class="el" href="#a60f52fac14aebb6fa6a86264d0973db2">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a17989802955657e7b4b94cefa44e6559">equal_range</a> (const K &amp;key, std::size_t precalculated_hash)</td></tr>
<tr class="memitem:a741514742fcee1d0770ec77d1b37bec2" id="r_a741514742fcee1d0770ec77d1b37bec2"><td class="memTemplParams" colspan="2">template&lt;class K, class KE = KeyEqual, typename std::enable_if&lt; <a class="el" href="#ad704d9c5b38b382aa4ce5c9acb962055">has_is_transparent</a>&lt; KE &gt;::value &gt;::type * = nullptr&gt; </td></tr>
<tr class="memitem:a741514742fcee1d0770ec77d1b37bec2 template"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a>, <a class="el" href="#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a741514742fcee1d0770ec77d1b37bec2">equal_range</a> (const K &amp;key) const</td></tr>
<tr class="memitem:ae258779e8b37d097691ff6f2ed3713a9" id="r_ae258779e8b37d097691ff6f2ed3713a9"><td class="memTemplParams" colspan="2">template&lt;class K, class KE = KeyEqual, typename std::enable_if&lt; <a class="el" href="#ad704d9c5b38b382aa4ce5c9acb962055">has_is_transparent</a>&lt; KE &gt;::value &gt;::type * = nullptr&gt; </td></tr>
<tr class="memitem:ae258779e8b37d097691ff6f2ed3713a9 template"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a>, <a class="el" href="#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae258779e8b37d097691ff6f2ed3713a9">equal_range</a> (const K &amp;key, std::size_t precalculated_hash) const</td></tr>
<tr class="memitem:aebd0daab184ba503b801be16d5077eb7" id="r_aebd0daab184ba503b801be16d5077eb7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a2ac3b2278e6f731cdf4ac9b12ad62a71">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aebd0daab184ba503b801be16d5077eb7">bucket_count</a> () const</td></tr>
<tr class="memitem:ae391a0f4c83b6ab9c7503b4ca335b370" id="r_ae391a0f4c83b6ab9c7503b4ca335b370"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a2ac3b2278e6f731cdf4ac9b12ad62a71">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae391a0f4c83b6ab9c7503b4ca335b370">max_bucket_count</a> () const</td></tr>
<tr class="memitem:ac2674047296b5b925d24c80df8e35bd0" id="r_ac2674047296b5b925d24c80df8e35bd0"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac2674047296b5b925d24c80df8e35bd0">load_factor</a> () const</td></tr>
<tr class="memitem:aa48f17ccd7760fde3b2a666823741142" id="r_aa48f17ccd7760fde3b2a666823741142"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa48f17ccd7760fde3b2a666823741142">max_load_factor</a> () const</td></tr>
<tr class="memitem:ab4a2b90171e6152f5fd534cbf510ea40" id="r_ab4a2b90171e6152f5fd534cbf510ea40"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab4a2b90171e6152f5fd534cbf510ea40">max_load_factor</a> (float ml)</td></tr>
<tr class="memitem:a9cf26b6774ca9814d28736f9788eb9b7" id="r_a9cf26b6774ca9814d28736f9788eb9b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9cf26b6774ca9814d28736f9788eb9b7">rehash</a> (<a class="el" href="#a2ac3b2278e6f731cdf4ac9b12ad62a71">size_type</a> count_)</td></tr>
<tr class="memitem:a54ba37be9c5369753020524dd4f8b516" id="r_a54ba37be9c5369753020524dd4f8b516"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a54ba37be9c5369753020524dd4f8b516">reserve</a> (<a class="el" href="#a2ac3b2278e6f731cdf4ac9b12ad62a71">size_type</a> count_)</td></tr>
<tr class="memitem:a22024c61aa478aff2b9dc601801f3047" id="r_a22024c61aa478aff2b9dc601801f3047"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a45612102bc640807c27d9111b6b84888">hasher</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a22024c61aa478aff2b9dc601801f3047">hash_function</a> () const</td></tr>
<tr class="memitem:a6b7236bc7221f302284165e0ab4e2c2c" id="r_a6b7236bc7221f302284165e0ab4e2c2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a71848c7a83bde13a664d81ab29cfe009">key_equal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b7236bc7221f302284165e0ab4e2c2c">key_eq</a> () const</td></tr>
<tr class="memitem:afb2e4a5595a63ec7984fcf2e496c939b" id="r_afb2e4a5595a63ec7984fcf2e496c939b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a60f52fac14aebb6fa6a86264d0973db2">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afb2e4a5595a63ec7984fcf2e496c939b">mutable_iterator</a> (<a class="el" href="#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a> pos)</td></tr>
<tr class="memitem:af540aaceecfd3809d0c8d42d6fd2a4d7" id="r_af540aaceecfd3809d0c8d42d6fd2a4d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a2ac3b2278e6f731cdf4ac9b12ad62a71">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af540aaceecfd3809d0c8d42d6fd2a4d7">overflow_size</a> () const noexcept</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pri-types" class="groupheader"><a id="pri-types" name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:ad704d9c5b38b382aa4ce5c9acb962055" id="r_ad704d9c5b38b382aa4ce5c9acb962055"><td class="memTemplParams" colspan="2">template&lt;typename U&gt; </td></tr>
<tr class="memitem:ad704d9c5b38b382aa4ce5c9acb962055 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad704d9c5b38b382aa4ce5c9acb962055">has_is_transparent</a> = <a class="el" href="structtsl_1_1detail__hopscotch__hash_1_1has__is__transparent.html">tsl::detail_hopscotch_hash::has_is_transparent</a>&lt;U&gt;</td></tr>
<tr class="memitem:aff8ca660a7daf914b2fd804f968e8657" id="r_aff8ca660a7daf914b2fd804f968e8657"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff8ca660a7daf914b2fd804f968e8657">overflow_container_type</a> = std::list&lt;std::pair&lt;Key, T&gt;, Allocator&gt;</td></tr>
<tr class="memitem:a8b9a997423fc6ea10c27637614b7f5af" id="r_a8b9a997423fc6ea10c27637614b7f5af"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b9a997423fc6ea10c27637614b7f5af">ht</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pri-attribs" class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a1c018c7720fbeec1a31ffb531000d410" id="r_a1c018c7720fbeec1a31ffb531000d410"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a8b9a997423fc6ea10c27637614b7f5af">ht</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1c018c7720fbeec1a31ffb531000d410">m_ht</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-friends" class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a998b5b063e0895c40a81de5e54034a0f" id="r_a998b5b063e0895c40a81de5e54034a0f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a998b5b063e0895c40a81de5e54034a0f">operator==</a> (const <a class="el" href="classtsl_1_1hopscotch__map.html">hopscotch_map</a> &amp;lhs, const <a class="el" href="classtsl_1_1hopscotch__map.html">hopscotch_map</a> &amp;rhs)</td></tr>
<tr class="memitem:a448d662876f88352fe68f0461d997e35" id="r_a448d662876f88352fe68f0461d997e35"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a448d662876f88352fe68f0461d997e35">operator!=</a> (const <a class="el" href="classtsl_1_1hopscotch__map.html">hopscotch_map</a> &amp;lhs, const <a class="el" href="classtsl_1_1hopscotch__map.html">hopscotch_map</a> &amp;rhs)</td></tr>
<tr class="memitem:ae939cc5e813994c09fa4e5cd687e1f5c" id="r_ae939cc5e813994c09fa4e5cd687e1f5c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae939cc5e813994c09fa4e5cd687e1f5c">swap</a> (<a class="el" href="classtsl_1_1hopscotch__map.html">hopscotch_map</a> &amp;lhs, <a class="el" href="classtsl_1_1hopscotch__map.html">hopscotch_map</a> &amp;rhs)</td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt;<br />
class tsl::hopscotch_map&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;</div><p>Implementation of a hash map using the hopscotch hashing algorithm.</p>
<p>The Key and the value T must be either nothrow move-constructible, copy-constructible or both.</p>
<p>The size of the neighborhood (NeighborhoodSize) must be &gt; 0 and &lt;= 62 if StoreHash is false. When StoreHash is true, 32-bits of the hash will be stored alongside the neighborhood limiting the NeighborhoodSize to &lt;= 30. There is no memory usage difference between 'NeighborhoodSize 62; StoreHash false' and 'NeighborhoodSize 30; StoreHash true'.</p>
<p>Storing the hash may improve performance on insert during the rehash process if the hash takes time to compute. It may also improve read performance if the KeyEqual function takes time (or incurs a cache-miss). If used with simple Hash and KeyEqual it may slow things down.</p>
<p>StoreHash can only be set if the GrowthPolicy is set to tsl::power_of_two_growth_policy.</p>
<p>GrowthPolicy defines how the map grows and consequently how a hash value is mapped to a bucket. By default the map uses tsl::power_of_two_growth_policy. This policy keeps the number of buckets to a power of two and uses a mask to map the hash to a bucket instead of the slow modulo. You may define your own growth policy, check tsl::power_of_two_growth_policy for the interface.</p>
<p>If the destructors of Key or T throw an exception, behaviour of the class is undefined.</p>
<p>Iterators invalidation:</p><ul>
<li>clear, operator=, reserve, rehash: always invalidate the iterators.</li>
<li>insert, emplace, emplace_hint, operator[]: if there is an effective insert, invalidate the iterators if a displacement is needed to resolve a collision (which mean that most of the time, insert will invalidate the iterators). Or if there is a rehash.</li>
<li>erase: iterator on the erased element is the only one which become invalid. </li>
</ul>
</div><a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Member Typedef Documentation</h2>
<a id="aa1029454117f4dc02a2f8c565fd923ce" name="aa1029454117f4dc02a2f8c565fd923ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1029454117f4dc02a2f8c565fd923ce">&#9670;&#160;</a></span>allocator_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::allocator_type = typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#a8af583783f638a3faac62c52b876aa67">ht::allocator_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab1f7dbb7b85f2d41b9bf81ab7d5b474f" name="ab1f7dbb7b85f2d41b9bf81ab7d5b474f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">&#9670;&#160;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::const_iterator = typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#a2af6f88c2b254b2c9ff83c70eea7c952">ht::const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6ce17bf22290aead159b36b3fc54e78b" name="a6ce17bf22290aead159b36b3fc54e78b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ce17bf22290aead159b36b3fc54e78b">&#9670;&#160;</a></span>const_pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::const_pointer = typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#a85e8fb0e24e28aef2c0ec4ce9e3f9d01">ht::const_pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5f8b308813e7b74a4dab48858e961110" name="a5f8b308813e7b74a4dab48858e961110"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f8b308813e7b74a4dab48858e961110">&#9670;&#160;</a></span>const_reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::const_reference = typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#ae45966f2a709f1d7f03d42cd19fb29ea">ht::const_reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a746e99af4d2728c0284519b9d2beea88" name="a746e99af4d2728c0284519b9d2beea88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a746e99af4d2728c0284519b9d2beea88">&#9670;&#160;</a></span>difference_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::difference_type = typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#a3a8a8e910088e7bdbfe63be530d31956">ht::difference_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad704d9c5b38b382aa4ce5c9acb962055" name="ad704d9c5b38b382aa4ce5c9acb962055"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad704d9c5b38b382aa4ce5c9acb962055">&#9670;&#160;</a></span>has_is_transparent</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::has_is_transparent = <a class="el" href="structtsl_1_1detail__hopscotch__hash_1_1has__is__transparent.html">tsl::detail_hopscotch_hash::has_is_transparent</a>&lt;U&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a45612102bc640807c27d9111b6b84888" name="a45612102bc640807c27d9111b6b84888"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45612102bc640807c27d9111b6b84888">&#9670;&#160;</a></span>hasher</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::hasher = typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#a0ffe6a6aaa0794dcf4979fc23e583462">ht::hasher</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8b9a997423fc6ea10c27637614b7f5af" name="a8b9a997423fc6ea10c27637614b7f5af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b9a997423fc6ea10c27637614b7f5af">&#9670;&#160;</a></span>ht</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::ht</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">        <a class="code hl_class" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html">detail_hopscotch_hash::hopscotch_hash&lt;std::pair&lt;Key, T&gt;</a>, <a class="code hl_class" href="classtsl_1_1bhopscotch__map_1_1KeySelect.html">KeySelect</a>, <a class="code hl_class" href="classtsl_1_1bhopscotch__map_1_1ValueSelect.html">ValueSelect</a>, Hash,</div>
<div class="line">                                              KeyEqual, Allocator, NeighborhoodSize, StoreHash,</div>
<div class="line">                                              GrowthPolicy, <a class="code hl_typedef" href="classtsl_1_1bhopscotch__map.html#aff58a60c5e700602737ad0f2c5401631">overflow_container_type</a>&gt;</div>
<div class="ttc" id="aclasstsl_1_1bhopscotch__map_1_1KeySelect_html"><div class="ttname"><a href="classtsl_1_1bhopscotch__map_1_1KeySelect.html">tsl::bhopscotch_map::KeySelect</a></div><div class="ttdef"><b>Definition</b> bhopscotch_map.h:67</div></div>
<div class="ttc" id="aclasstsl_1_1bhopscotch__map_1_1ValueSelect_html"><div class="ttname"><a href="classtsl_1_1bhopscotch__map_1_1ValueSelect.html">tsl::bhopscotch_map::ValueSelect</a></div><div class="ttdef"><b>Definition</b> bhopscotch_map.h:80</div></div>
<div class="ttc" id="aclasstsl_1_1bhopscotch__map_html_aff58a60c5e700602737ad0f2c5401631"><div class="ttname"><a href="classtsl_1_1bhopscotch__map.html#aff58a60c5e700602737ad0f2c5401631">tsl::bhopscotch_map::overflow_container_type</a></div><div class="ttdeci">std::map&lt; Key, T, Compare, Allocator &gt; overflow_container_type</div><div class="ttdef"><b>Definition</b> bhopscotch_map.h:95</div></div>
<div class="ttc" id="aclasstsl_1_1detail__hopscotch__hash_1_1hopscotch__hash_html"><div class="ttname"><a href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html">tsl::detail_hopscotch_hash::hopscotch_hash</a></div><div class="ttdef"><b>Definition</b> hopscotch_hash.h:431</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a60f52fac14aebb6fa6a86264d0973db2" name="a60f52fac14aebb6fa6a86264d0973db2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60f52fac14aebb6fa6a86264d0973db2">&#9670;&#160;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::iterator = typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#ab697c644e6dec536d6ab028ba085b591">ht::iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a71848c7a83bde13a664d81ab29cfe009" name="a71848c7a83bde13a664d81ab29cfe009"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71848c7a83bde13a664d81ab29cfe009">&#9670;&#160;</a></span>key_equal</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::key_equal = typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#a69a00efe0c98e7d89d3eeb8ef5e43190">ht::key_equal</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2eae39b540085051068d2c94d3054dd9" name="a2eae39b540085051068d2c94d3054dd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eae39b540085051068d2c94d3054dd9">&#9670;&#160;</a></span>key_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::key_type = typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#ac2da7bb97307e334553fe9cba15d0689">ht::key_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a115c1d91228c4e0f67571f449b323794" name="a115c1d91228c4e0f67571f449b323794"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a115c1d91228c4e0f67571f449b323794">&#9670;&#160;</a></span>mapped_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::mapped_type = T</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aff8ca660a7daf914b2fd804f968e8657" name="aff8ca660a7daf914b2fd804f968e8657"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff8ca660a7daf914b2fd804f968e8657">&#9670;&#160;</a></span>overflow_container_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::overflow_container_type = std::list&lt;std::pair&lt;Key, T&gt;, Allocator&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a10beb351b4ff9c9702a13b6e5df659f7" name="a10beb351b4ff9c9702a13b6e5df659f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10beb351b4ff9c9702a13b6e5df659f7">&#9670;&#160;</a></span>pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::pointer = typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#a31276a8ba5b00732857fd0267a5b6fdd">ht::pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a148a927cbaa479eeb208e72f65a7cc6a" name="a148a927cbaa479eeb208e72f65a7cc6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a148a927cbaa479eeb208e72f65a7cc6a">&#9670;&#160;</a></span>reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::reference = typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#a257bb0ff019c2756bc2c192e76f31ce5">ht::reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2ac3b2278e6f731cdf4ac9b12ad62a71" name="a2ac3b2278e6f731cdf4ac9b12ad62a71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ac3b2278e6f731cdf4ac9b12ad62a71">&#9670;&#160;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::size_type = typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#a0f2a8dda76d11a1531be2c2e7fb82061">ht::size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa8775b4f4ca37f0ba1226b6ac8cf37b4" name="aa8775b4f4ca37f0ba1226b6ac8cf37b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8775b4f4ca37f0ba1226b6ac8cf37b4">&#9670;&#160;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::value_type = typename <a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#afed3e1f425ac47050c9d8b96c2c5e319">ht::value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a447530a7b92ad7ed2e902302e10e91b6" name="a447530a7b92ad7ed2e902302e10e91b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a447530a7b92ad7ed2e902302e10e91b6">&#9670;&#160;</a></span>hopscotch_map() <span class="overload">[1/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::hopscotch_map </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5b3b5f0e68b9f92d2732c3fa74cdcd22" name="a5b3b5f0e68b9f92d2732c3fa74cdcd22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b3b5f0e68b9f92d2732c3fa74cdcd22">&#9670;&#160;</a></span>hopscotch_map() <span class="overload">[2/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::hopscotch_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a2ac3b2278e6f731cdf4ac9b12ad62a71">size_type</a></td>          <td class="paramname"><span class="paramname"><em>bucket_count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Hash &amp;</td>          <td class="paramname"><span class="paramname"><em>hash</em></span><span class="paramdefsep"> = </span><span class="paramdefval">Hash()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyEqual &amp;</td>          <td class="paramname"><span class="paramname"><em>equal</em></span><span class="paramdefsep"> = </span><span class="paramdefval">KeyEqual()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span><span class="paramdefsep"> = </span><span class="paramdefval">Allocator()</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7a370299f055b767aa8bd2e884f6f78a" name="a7a370299f055b767aa8bd2e884f6f78a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a370299f055b767aa8bd2e884f6f78a">&#9670;&#160;</a></span>hopscotch_map() <span class="overload">[3/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::hopscotch_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a2ac3b2278e6f731cdf4ac9b12ad62a71">size_type</a></td>          <td class="paramname"><span class="paramname"><em>bucket_count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac49f9a4593db3799f30691547f12569c" name="ac49f9a4593db3799f30691547f12569c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac49f9a4593db3799f30691547f12569c">&#9670;&#160;</a></span>hopscotch_map() <span class="overload">[4/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::hopscotch_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a2ac3b2278e6f731cdf4ac9b12ad62a71">size_type</a></td>          <td class="paramname"><span class="paramname"><em>bucket_count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Hash &amp;</td>          <td class="paramname"><span class="paramname"><em>hash</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae4bc1495e4ea36f2cb429b058e847122" name="ae4bc1495e4ea36f2cb429b058e847122"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4bc1495e4ea36f2cb429b058e847122">&#9670;&#160;</a></span>hopscotch_map() <span class="overload">[5/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::hopscotch_map </td>
          <td>(</td>
          <td class="paramtype">const Allocator &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7b4b191e8bea5b17ddded13a532eded7" name="a7b4b191e8bea5b17ddded13a532eded7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b4b191e8bea5b17ddded13a532eded7">&#9670;&#160;</a></span>hopscotch_map() <span class="overload">[6/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::hopscotch_map </td>
          <td>(</td>
          <td class="paramtype">InputIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a2ac3b2278e6f731cdf4ac9b12ad62a71">size_type</a></td>          <td class="paramname"><span class="paramname"><em>bucket_count</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#a3b4d20d3ff76dd7e703bb18368332368">ht::DEFAULT_INIT_BUCKETS_SIZE</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Hash &amp;</td>          <td class="paramname"><span class="paramname"><em>hash</em></span><span class="paramdefsep"> = </span><span class="paramdefval">Hash()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyEqual &amp;</td>          <td class="paramname"><span class="paramname"><em>equal</em></span><span class="paramdefsep"> = </span><span class="paramdefval">KeyEqual()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span><span class="paramdefsep"> = </span><span class="paramdefval">Allocator()</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a00bd9fdd26e3984602b456aa0e50ba67" name="a00bd9fdd26e3984602b456aa0e50ba67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00bd9fdd26e3984602b456aa0e50ba67">&#9670;&#160;</a></span>hopscotch_map() <span class="overload">[7/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::hopscotch_map </td>
          <td>(</td>
          <td class="paramtype">InputIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a2ac3b2278e6f731cdf4ac9b12ad62a71">size_type</a></td>          <td class="paramname"><span class="paramname"><em>bucket_count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4db9d26abc385eebc73c380a6cf95242" name="a4db9d26abc385eebc73c380a6cf95242"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4db9d26abc385eebc73c380a6cf95242">&#9670;&#160;</a></span>hopscotch_map() <span class="overload">[8/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::hopscotch_map </td>
          <td>(</td>
          <td class="paramtype">InputIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a2ac3b2278e6f731cdf4ac9b12ad62a71">size_type</a></td>          <td class="paramname"><span class="paramname"><em>bucket_count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Hash &amp;</td>          <td class="paramname"><span class="paramname"><em>hash</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7eb86e389b533f4eec6b7d0a77847881" name="a7eb86e389b533f4eec6b7d0a77847881"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eb86e389b533f4eec6b7d0a77847881">&#9670;&#160;</a></span>hopscotch_map() <span class="overload">[9/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::hopscotch_map </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="#aa8775b4f4ca37f0ba1226b6ac8cf37b4">value_type</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>init</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a2ac3b2278e6f731cdf4ac9b12ad62a71">size_type</a></td>          <td class="paramname"><span class="paramname"><em>bucket_count</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classtsl_1_1detail__hopscotch__hash_1_1hopscotch__hash.html#a3b4d20d3ff76dd7e703bb18368332368">ht::DEFAULT_INIT_BUCKETS_SIZE</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Hash &amp;</td>          <td class="paramname"><span class="paramname"><em>hash</em></span><span class="paramdefsep"> = </span><span class="paramdefval">Hash()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyEqual &amp;</td>          <td class="paramname"><span class="paramname"><em>equal</em></span><span class="paramdefsep"> = </span><span class="paramdefval">KeyEqual()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span><span class="paramdefsep"> = </span><span class="paramdefval">Allocator()</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac09cc7d50fcaae8a841672b8f6054e29" name="ac09cc7d50fcaae8a841672b8f6054e29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac09cc7d50fcaae8a841672b8f6054e29">&#9670;&#160;</a></span>hopscotch_map() <span class="overload">[10/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::hopscotch_map </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="#aa8775b4f4ca37f0ba1226b6ac8cf37b4">value_type</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>init</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a2ac3b2278e6f731cdf4ac9b12ad62a71">size_type</a></td>          <td class="paramname"><span class="paramname"><em>bucket_count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9f411a4dfd00bcbefcd6ca0542b16ee8" name="a9f411a4dfd00bcbefcd6ca0542b16ee8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f411a4dfd00bcbefcd6ca0542b16ee8">&#9670;&#160;</a></span>hopscotch_map() <span class="overload">[11/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::hopscotch_map </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="#aa8775b4f4ca37f0ba1226b6ac8cf37b4">value_type</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>init</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a2ac3b2278e6f731cdf4ac9b12ad62a71">size_type</a></td>          <td class="paramname"><span class="paramname"><em>bucket_count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Hash &amp;</td>          <td class="paramname"><span class="paramname"><em>hash</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="a553a35b5c3a2421534fdc9984b54692b" name="a553a35b5c3a2421534fdc9984b54692b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a553a35b5c3a2421534fdc9984b54692b">&#9670;&#160;</a></span>at() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class K, class KE = KeyEqual, typename std::enable_if&lt; <a class="el" href="#ad704d9c5b38b382aa4ce5c9acb962055">has_is_transparent</a>&lt; KE &gt;::value &gt;::type * = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const K &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. If so, K must be hashable and comparable to Key. </p>

</div>
</div>
<a id="a1d44c2749c6135804307168eb6034408" name="a1d44c2749c6135804307168eb6034408"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d44c2749c6135804307168eb6034408">&#9670;&#160;</a></span>at() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class K, class KE = KeyEqual, typename std::enable_if&lt; <a class="el" href="#ad704d9c5b38b382aa4ce5c9acb962055">has_is_transparent</a>&lt; KE &gt;::value &gt;::type * = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const K &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a695930b6f2e98e1d92f5481c73584d67" name="a695930b6f2e98e1d92f5481c73584d67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a695930b6f2e98e1d92f5481c73584d67">&#9670;&#160;</a></span>at() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class K, class KE = KeyEqual, typename std::enable_if&lt; <a class="el" href="#ad704d9c5b38b382aa4ce5c9acb962055">has_is_transparent</a>&lt; KE &gt;::value &gt;::type * = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const K &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>precalculated_hash</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="#a22024c61aa478aff2b9dc601801f3047">hash_function()</a>(key). Useful to speed-up the lookup if you already have the hash. </p>

</div>
</div>
<a id="a25b9d072a4e6f40ef62d994a90462f02" name="a25b9d072a4e6f40ef62d994a90462f02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25b9d072a4e6f40ef62d994a90462f02">&#9670;&#160;</a></span>at() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class K, class KE = KeyEqual, typename std::enable_if&lt; <a class="el" href="#ad704d9c5b38b382aa4ce5c9acb962055">has_is_transparent</a>&lt; KE &gt;::value &gt;::type * = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const K &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>precalculated_hash</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad0375313463327f66099eb7e3fc17758" name="ad0375313463327f66099eb7e3fc17758"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0375313463327f66099eb7e3fc17758">&#9670;&#160;</a></span>at() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4a731129ba4ead23c1144cfce0ab9fc2" name="a4a731129ba4ead23c1144cfce0ab9fc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a731129ba4ead23c1144cfce0ab9fc2">&#9670;&#160;</a></span>at() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa5cd8fc477ecd692404a98efde039d76" name="aa5cd8fc477ecd692404a98efde039d76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5cd8fc477ecd692404a98efde039d76">&#9670;&#160;</a></span>at() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>precalculated_hash</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="#a22024c61aa478aff2b9dc601801f3047">hash_function()</a>(key). Useful to speed-up the lookup if you already have the hash. </p>

</div>
</div>
<a id="a976efddd6fef23b11bc6288cc8cb74ec" name="a976efddd6fef23b11bc6288cc8cb74ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a976efddd6fef23b11bc6288cc8cb74ec">&#9670;&#160;</a></span>at() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>precalculated_hash</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a441ea957f3a7fe842867a289742c3d0f" name="a441ea957f3a7fe842867a289742c3d0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a441ea957f3a7fe842867a289742c3d0f">&#9670;&#160;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a> <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::begin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a427075830599fc53bcd649b4a14d5bde" name="a427075830599fc53bcd649b4a14d5bde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a427075830599fc53bcd649b4a14d5bde">&#9670;&#160;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a60f52fac14aebb6fa6a86264d0973db2">iterator</a> <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::begin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aebd0daab184ba503b801be16d5077eb7" name="aebd0daab184ba503b801be16d5077eb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebd0daab184ba503b801be16d5077eb7">&#9670;&#160;</a></span>bucket_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a2ac3b2278e6f731cdf4ac9b12ad62a71">size_type</a> <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::bucket_count </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4406ad14b90cd52b766d551029e88cb7" name="a4406ad14b90cd52b766d551029e88cb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4406ad14b90cd52b766d551029e88cb7">&#9670;&#160;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a> <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0e27dbe412d061b26576a36936825949" name="a0e27dbe412d061b26576a36936825949"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e27dbe412d061b26576a36936825949">&#9670;&#160;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a> <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::cend </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1aa591920de994ce89ec87cf0be5b84b" name="a1aa591920de994ce89ec87cf0be5b84b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1aa591920de994ce89ec87cf0be5b84b">&#9670;&#160;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::clear </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0255617434505dfc064ce49c1bfe7ac0" name="a0255617434505dfc064ce49c1bfe7ac0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0255617434505dfc064ce49c1bfe7ac0">&#9670;&#160;</a></span>contains() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class K, class KE = KeyEqual, typename std::enable_if&lt; <a class="el" href="#ad704d9c5b38b382aa4ce5c9acb962055">has_is_transparent</a>&lt; KE &gt;::value &gt;::type * = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const K &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. If so, K must be hashable and comparable to Key. </p>

</div>
</div>
<a id="a5f816462a64e868612e8a571eec98e34" name="a5f816462a64e868612e8a571eec98e34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f816462a64e868612e8a571eec98e34">&#9670;&#160;</a></span>contains() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class K, class KE = KeyEqual, typename std::enable_if&lt; <a class="el" href="#ad704d9c5b38b382aa4ce5c9acb962055">has_is_transparent</a>&lt; KE &gt;::value &gt;::type * = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const K &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>precalculated_hash</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="#a22024c61aa478aff2b9dc601801f3047">hash_function()</a>(key). Useful to speed-up the lookup if you already have the hash. </p>

</div>
</div>
<a id="a69f1bd19068900061d5a5a551481465e" name="a69f1bd19068900061d5a5a551481465e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69f1bd19068900061d5a5a551481465e">&#9670;&#160;</a></span>contains() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab83e5e6a0c35d64c5d50d6356b0d0e2e" name="ab83e5e6a0c35d64c5d50d6356b0d0e2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab83e5e6a0c35d64c5d50d6356b0d0e2e">&#9670;&#160;</a></span>contains() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>precalculated_hash</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="#a22024c61aa478aff2b9dc601801f3047">hash_function()</a>(key). Useful to speed-up the lookup if you already have the hash. </p>

</div>
</div>
<a id="ae9a31a7772dfe4f6085e8d87ba423c33" name="ae9a31a7772dfe4f6085e8d87ba423c33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9a31a7772dfe4f6085e8d87ba423c33">&#9670;&#160;</a></span>count() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class K, class KE = KeyEqual, typename std::enable_if&lt; <a class="el" href="#ad704d9c5b38b382aa4ce5c9acb962055">has_is_transparent</a>&lt; KE &gt;::value &gt;::type * = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a2ac3b2278e6f731cdf4ac9b12ad62a71">size_type</a> <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const K &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. If so, K must be hashable and comparable to Key. </p>

</div>
</div>
<a id="a9adb70f22857b567dbb0627d32e49b02" name="a9adb70f22857b567dbb0627d32e49b02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9adb70f22857b567dbb0627d32e49b02">&#9670;&#160;</a></span>count() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class K, class KE = KeyEqual, typename std::enable_if&lt; <a class="el" href="#ad704d9c5b38b382aa4ce5c9acb962055">has_is_transparent</a>&lt; KE &gt;::value &gt;::type * = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a2ac3b2278e6f731cdf4ac9b12ad62a71">size_type</a> <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const K &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>precalculated_hash</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="#a22024c61aa478aff2b9dc601801f3047">hash_function()</a>(key). Useful to speed-up the lookup if you already have the hash. </p>

</div>
</div>
<a id="a0a88790c4f7555a99e2abc12a562bd34" name="a0a88790c4f7555a99e2abc12a562bd34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a88790c4f7555a99e2abc12a562bd34">&#9670;&#160;</a></span>count() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a2ac3b2278e6f731cdf4ac9b12ad62a71">size_type</a> <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adf3c1b1905c8a12f9cff07f105459e58" name="adf3c1b1905c8a12f9cff07f105459e58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf3c1b1905c8a12f9cff07f105459e58">&#9670;&#160;</a></span>count() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a2ac3b2278e6f731cdf4ac9b12ad62a71">size_type</a> <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>precalculated_hash</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="#a22024c61aa478aff2b9dc601801f3047">hash_function()</a>(key). Useful to speed-up the lookup if you already have the hash. </p>

</div>
</div>
<a id="ac2a164e64fe903a19c9433bbc3c97993" name="ac2a164e64fe903a19c9433bbc3c97993"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2a164e64fe903a19c9433bbc3c97993">&#9670;&#160;</a></span>emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="#a60f52fac14aebb6fa6a86264d0973db2">iterator</a>, bool &gt; <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Due to the way elements are stored, emplace will need to move or copy the key-value once. The method is equivalent to insert(<a class="el" href="#aa8775b4f4ca37f0ba1226b6ac8cf37b4">value_type(std::forward&lt;Args&gt;(args)...)</a>);</p>
<p>Mainly here for compatibility with the std::unordered_map interface. </p>

</div>
</div>
<a id="a8e19112ef0f633a107ce3fa6d6a4b3ae" name="a8e19112ef0f633a107ce3fa6d6a4b3ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e19112ef0f633a107ce3fa6d6a4b3ae">&#9670;&#160;</a></span>emplace_hint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a60f52fac14aebb6fa6a86264d0973db2">iterator</a> <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::emplace_hint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a></td>          <td class="paramname"><span class="paramname"><em>hint</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Due to the way elements are stored, emplace_hint will need to move or copy the key-value once. The method is equivalent to insert(hint, <a class="el" href="#aa8775b4f4ca37f0ba1226b6ac8cf37b4">value_type(std::forward&lt;Args&gt;(args)...)</a>);</p>
<p>Mainly here for compatibility with the std::unordered_map interface. </p>

</div>
</div>
<a id="ae41b459d21ab54d516812206a481806b" name="ae41b459d21ab54d516812206a481806b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae41b459d21ab54d516812206a481806b">&#9670;&#160;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::empty </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a43571f72a4b43740ea45b1e219da3013" name="a43571f72a4b43740ea45b1e219da3013"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43571f72a4b43740ea45b1e219da3013">&#9670;&#160;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a> <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::end </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2e3f3585aa1f4c830ff7e8eced1e8a6f" name="a2e3f3585aa1f4c830ff7e8eced1e8a6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e3f3585aa1f4c830ff7e8eced1e8a6f">&#9670;&#160;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a60f52fac14aebb6fa6a86264d0973db2">iterator</a> <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::end </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aba04a4f687160d347d1ea3fb8333db08" name="aba04a4f687160d347d1ea3fb8333db08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba04a4f687160d347d1ea3fb8333db08">&#9670;&#160;</a></span>equal_range() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class K, class KE = KeyEqual, typename std::enable_if&lt; <a class="el" href="#ad704d9c5b38b382aa4ce5c9acb962055">has_is_transparent</a>&lt; KE &gt;::value &gt;::type * = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="#a60f52fac14aebb6fa6a86264d0973db2">iterator</a>, <a class="el" href="#a60f52fac14aebb6fa6a86264d0973db2">iterator</a> &gt; <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const K &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. If so, K must be hashable and comparable to Key. </p>

</div>
</div>
<a id="a741514742fcee1d0770ec77d1b37bec2" name="a741514742fcee1d0770ec77d1b37bec2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a741514742fcee1d0770ec77d1b37bec2">&#9670;&#160;</a></span>equal_range() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class K, class KE = KeyEqual, typename std::enable_if&lt; <a class="el" href="#ad704d9c5b38b382aa4ce5c9acb962055">has_is_transparent</a>&lt; KE &gt;::value &gt;::type * = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a>, <a class="el" href="#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a> &gt; <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const K &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a17989802955657e7b4b94cefa44e6559" name="a17989802955657e7b4b94cefa44e6559"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17989802955657e7b4b94cefa44e6559">&#9670;&#160;</a></span>equal_range() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class K, class KE = KeyEqual, typename std::enable_if&lt; <a class="el" href="#ad704d9c5b38b382aa4ce5c9acb962055">has_is_transparent</a>&lt; KE &gt;::value &gt;::type * = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="#a60f52fac14aebb6fa6a86264d0973db2">iterator</a>, <a class="el" href="#a60f52fac14aebb6fa6a86264d0973db2">iterator</a> &gt; <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const K &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>precalculated_hash</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="#a22024c61aa478aff2b9dc601801f3047">hash_function()</a>(key). Useful to speed-up the lookup if you already have the hash. </p>

</div>
</div>
<a id="ae258779e8b37d097691ff6f2ed3713a9" name="ae258779e8b37d097691ff6f2ed3713a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae258779e8b37d097691ff6f2ed3713a9">&#9670;&#160;</a></span>equal_range() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class K, class KE = KeyEqual, typename std::enable_if&lt; <a class="el" href="#ad704d9c5b38b382aa4ce5c9acb962055">has_is_transparent</a>&lt; KE &gt;::value &gt;::type * = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a>, <a class="el" href="#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a> &gt; <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const K &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>precalculated_hash</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7cda8ef0abd9543c7caecf34692b3f09" name="a7cda8ef0abd9543c7caecf34692b3f09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cda8ef0abd9543c7caecf34692b3f09">&#9670;&#160;</a></span>equal_range() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="#a60f52fac14aebb6fa6a86264d0973db2">iterator</a>, <a class="el" href="#a60f52fac14aebb6fa6a86264d0973db2">iterator</a> &gt; <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abff7564061f3d5be473e620fe93b1787" name="abff7564061f3d5be473e620fe93b1787"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abff7564061f3d5be473e620fe93b1787">&#9670;&#160;</a></span>equal_range() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a>, <a class="el" href="#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a> &gt; <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3327e41731e9fe4dc30dd19fd52341c3" name="a3327e41731e9fe4dc30dd19fd52341c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3327e41731e9fe4dc30dd19fd52341c3">&#9670;&#160;</a></span>equal_range() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="#a60f52fac14aebb6fa6a86264d0973db2">iterator</a>, <a class="el" href="#a60f52fac14aebb6fa6a86264d0973db2">iterator</a> &gt; <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>precalculated_hash</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="#a22024c61aa478aff2b9dc601801f3047">hash_function()</a>(key). Useful to speed-up the lookup if you already have the hash. </p>

</div>
</div>
<a id="afc1499fbdda0eb52be0cedd9e91b77a2" name="afc1499fbdda0eb52be0cedd9e91b77a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc1499fbdda0eb52be0cedd9e91b77a2">&#9670;&#160;</a></span>equal_range() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a>, <a class="el" href="#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a> &gt; <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>precalculated_hash</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a741fb9bd476e91d66237c27e9260d464" name="a741fb9bd476e91d66237c27e9260d464"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a741fb9bd476e91d66237c27e9260d464">&#9670;&#160;</a></span>erase() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class K, class KE = KeyEqual, typename std::enable_if&lt; <a class="el" href="#ad704d9c5b38b382aa4ce5c9acb962055">has_is_transparent</a>&lt; KE &gt;::value &gt;::type * = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a2ac3b2278e6f731cdf4ac9b12ad62a71">size_type</a> <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const K &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. If so, K must be hashable and comparable to Key. </p>

</div>
</div>
<a id="a96c4d38aaa226f95006c28a69f8b7748" name="a96c4d38aaa226f95006c28a69f8b7748"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96c4d38aaa226f95006c28a69f8b7748">&#9670;&#160;</a></span>erase() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class K, class KE = KeyEqual, typename std::enable_if&lt; <a class="el" href="#ad704d9c5b38b382aa4ce5c9acb962055">has_is_transparent</a>&lt; KE &gt;::value &gt;::type * = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a2ac3b2278e6f731cdf4ac9b12ad62a71">size_type</a> <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const K &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>precalculated_hash</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="#a22024c61aa478aff2b9dc601801f3047">hash_function()</a>(key). Useful to speed-up the lookup to the value if you already have the hash. </p>

</div>
</div>
<a id="a0e093bee93337aa1e89a610d53764824" name="a0e093bee93337aa1e89a610d53764824"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e093bee93337aa1e89a610d53764824">&#9670;&#160;</a></span>erase() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a2ac3b2278e6f731cdf4ac9b12ad62a71">size_type</a> <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a2eae39b540085051068d2c94d3054dd9">key_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2826de34d69c27b61432113e7c241c1b" name="a2826de34d69c27b61432113e7c241c1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2826de34d69c27b61432113e7c241c1b">&#9670;&#160;</a></span>erase() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a2ac3b2278e6f731cdf4ac9b12ad62a71">size_type</a> <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a2eae39b540085051068d2c94d3054dd9">key_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>precalculated_hash</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="#a22024c61aa478aff2b9dc601801f3047">hash_function()</a>(key). Useful to speed-up the lookup to the value if you already have the hash. </p>

</div>
</div>
<a id="a3416ddb5a149fffa931c10439a074d41" name="a3416ddb5a149fffa931c10439a074d41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3416ddb5a149fffa931c10439a074d41">&#9670;&#160;</a></span>erase() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a60f52fac14aebb6fa6a86264d0973db2">iterator</a> <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2e4ba064d2ead6b7e9d20e9f4902a1ca" name="a2e4ba064d2ead6b7e9d20e9f4902a1ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e4ba064d2ead6b7e9d20e9f4902a1ca">&#9670;&#160;</a></span>erase() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a60f52fac14aebb6fa6a86264d0973db2">iterator</a> <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a></td>          <td class="paramname"><span class="paramname"><em>pos</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a26ee0d0bff7224e9e130150ff183bdeb" name="a26ee0d0bff7224e9e130150ff183bdeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26ee0d0bff7224e9e130150ff183bdeb">&#9670;&#160;</a></span>erase() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a60f52fac14aebb6fa6a86264d0973db2">iterator</a> <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a60f52fac14aebb6fa6a86264d0973db2">iterator</a></td>          <td class="paramname"><span class="paramname"><em>pos</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aecc9cfa53edaae65f26aa35e1aa6b7d6" name="aecc9cfa53edaae65f26aa35e1aa6b7d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecc9cfa53edaae65f26aa35e1aa6b7d6">&#9670;&#160;</a></span>find() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class K, class KE = KeyEqual, typename std::enable_if&lt; <a class="el" href="#ad704d9c5b38b382aa4ce5c9acb962055">has_is_transparent</a>&lt; KE &gt;::value &gt;::type * = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a60f52fac14aebb6fa6a86264d0973db2">iterator</a> <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const K &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. If so, K must be hashable and comparable to Key. </p>

</div>
</div>
<a id="aec9ad2d6a7584d98ad2e06e5b880d0d8" name="aec9ad2d6a7584d98ad2e06e5b880d0d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec9ad2d6a7584d98ad2e06e5b880d0d8">&#9670;&#160;</a></span>find() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class K, class KE = KeyEqual, typename std::enable_if&lt; <a class="el" href="#ad704d9c5b38b382aa4ce5c9acb962055">has_is_transparent</a>&lt; KE &gt;::value &gt;::type * = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a> <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const K &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1b223caffda7b47d565572425b1f3ea3" name="a1b223caffda7b47d565572425b1f3ea3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b223caffda7b47d565572425b1f3ea3">&#9670;&#160;</a></span>find() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class K, class KE = KeyEqual, typename std::enable_if&lt; <a class="el" href="#ad704d9c5b38b382aa4ce5c9acb962055">has_is_transparent</a>&lt; KE &gt;::value &gt;::type * = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a60f52fac14aebb6fa6a86264d0973db2">iterator</a> <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const K &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>precalculated_hash</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="#a22024c61aa478aff2b9dc601801f3047">hash_function()</a>(key). Useful to speed-up the lookup if you already have the hash. </p>

</div>
</div>
<a id="a55394bfd3c779b1bdde87fd18876f411" name="a55394bfd3c779b1bdde87fd18876f411"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55394bfd3c779b1bdde87fd18876f411">&#9670;&#160;</a></span>find() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class K, class KE = KeyEqual, typename std::enable_if&lt; <a class="el" href="#ad704d9c5b38b382aa4ce5c9acb962055">has_is_transparent</a>&lt; KE &gt;::value &gt;::type * = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a> <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const K &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>precalculated_hash</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="#a22024c61aa478aff2b9dc601801f3047">hash_function()</a>(key). Useful to speed-up the lookup if you already have the hash. </p>

</div>
</div>
<a id="afd20a86de3dbedd12c68e62703067138" name="afd20a86de3dbedd12c68e62703067138"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd20a86de3dbedd12c68e62703067138">&#9670;&#160;</a></span>find() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a60f52fac14aebb6fa6a86264d0973db2">iterator</a> <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa09cbacc3b8fb8c99a06814df0b86c4b" name="aa09cbacc3b8fb8c99a06814df0b86c4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa09cbacc3b8fb8c99a06814df0b86c4b">&#9670;&#160;</a></span>find() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a> <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a74d83c67c50bc8385bb11f78142eaa86" name="a74d83c67c50bc8385bb11f78142eaa86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74d83c67c50bc8385bb11f78142eaa86">&#9670;&#160;</a></span>find() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a60f52fac14aebb6fa6a86264d0973db2">iterator</a> <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>precalculated_hash</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="#a22024c61aa478aff2b9dc601801f3047">hash_function()</a>(key). Useful to speed-up the lookup if you already have the hash. </p>

</div>
</div>
<a id="ae6657238499a01a4ce1d6b9357b60eeb" name="ae6657238499a01a4ce1d6b9357b60eeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6657238499a01a4ce1d6b9357b60eeb">&#9670;&#160;</a></span>find() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a> <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>precalculated_hash</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adff56f4907ab6625b61c64fbf7df92bd" name="adff56f4907ab6625b61c64fbf7df92bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adff56f4907ab6625b61c64fbf7df92bd">&#9670;&#160;</a></span>get_allocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#aa1029454117f4dc02a2f8c565fd923ce">allocator_type</a> <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a22024c61aa478aff2b9dc601801f3047" name="a22024c61aa478aff2b9dc601801f3047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22024c61aa478aff2b9dc601801f3047">&#9670;&#160;</a></span>hash_function()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a45612102bc640807c27d9111b6b84888">hasher</a> <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::hash_function </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2c0811c3e9706fab4208bd4269db1d19" name="a2c0811c3e9706fab4208bd4269db1d19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c0811c3e9706fab4208bd4269db1d19">&#9670;&#160;</a></span>insert() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="#a60f52fac14aebb6fa6a86264d0973db2">iterator</a>, bool &gt; <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#aa8775b4f4ca37f0ba1226b6ac8cf37b4">value_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a11dd9d1f9df86cceb2b4b910de7b959e" name="a11dd9d1f9df86cceb2b4b910de7b959e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11dd9d1f9df86cceb2b4b910de7b959e">&#9670;&#160;</a></span>insert() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a60f52fac14aebb6fa6a86264d0973db2">iterator</a> <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a></td>          <td class="paramname"><span class="paramname"><em>hint</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#aa8775b4f4ca37f0ba1226b6ac8cf37b4">value_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab34c3cdf30912908d289fde716cd1892" name="ab34c3cdf30912908d289fde716cd1892"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab34c3cdf30912908d289fde716cd1892">&#9670;&#160;</a></span>insert() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class P, typename std::enable_if&lt; std::is_constructible&lt; <a class="el" href="#aa8775b4f4ca37f0ba1226b6ac8cf37b4">value_type</a>, P &amp;&amp; &gt;::value &gt;::type * = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a60f52fac14aebb6fa6a86264d0973db2">iterator</a> <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a></td>          <td class="paramname"><span class="paramname"><em>hint</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac194248ad6b5d71478beb5867b0e7f56" name="ac194248ad6b5d71478beb5867b0e7f56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac194248ad6b5d71478beb5867b0e7f56">&#9670;&#160;</a></span>insert() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a60f52fac14aebb6fa6a86264d0973db2">iterator</a> <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a></td>          <td class="paramname"><span class="paramname"><em>hint</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aa8775b4f4ca37f0ba1226b6ac8cf37b4">value_type</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a50df14a0a6829e7b8bf4cf96287cd7fa" name="a50df14a0a6829e7b8bf4cf96287cd7fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50df14a0a6829e7b8bf4cf96287cd7fa">&#9670;&#160;</a></span>insert() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">InputIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae46e7a33531b477b2d2477d264ee772e" name="ae46e7a33531b477b2d2477d264ee772e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae46e7a33531b477b2d2477d264ee772e">&#9670;&#160;</a></span>insert() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class P, typename std::enable_if&lt; std::is_constructible&lt; <a class="el" href="#aa8775b4f4ca37f0ba1226b6ac8cf37b4">value_type</a>, P &amp;&amp; &gt;::value &gt;::type * = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="#a60f52fac14aebb6fa6a86264d0973db2">iterator</a>, bool &gt; <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">P &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a13fcf313641cc7af76b1457867c16fe6" name="a13fcf313641cc7af76b1457867c16fe6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13fcf313641cc7af76b1457867c16fe6">&#9670;&#160;</a></span>insert() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="#aa8775b4f4ca37f0ba1226b6ac8cf37b4">value_type</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>ilist</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6a6c4f61eeac7999fd94c5f3fe8646a7" name="a6a6c4f61eeac7999fd94c5f3fe8646a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a6c4f61eeac7999fd94c5f3fe8646a7">&#9670;&#160;</a></span>insert() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="#a60f52fac14aebb6fa6a86264d0973db2">iterator</a>, bool &gt; <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#aa8775b4f4ca37f0ba1226b6ac8cf37b4">value_type</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a97f7b5bb64c9758a156dbb6b43f67a41" name="a97f7b5bb64c9758a156dbb6b43f67a41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97f7b5bb64c9758a156dbb6b43f67a41">&#9670;&#160;</a></span>insert_or_assign() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class M&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="#a60f52fac14aebb6fa6a86264d0973db2">iterator</a>, bool &gt; <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::insert_or_assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a2eae39b540085051068d2c94d3054dd9">key_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>k</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>obj</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a30d6b3065037c40dabf7d415b1ca1d7d" name="a30d6b3065037c40dabf7d415b1ca1d7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30d6b3065037c40dabf7d415b1ca1d7d">&#9670;&#160;</a></span>insert_or_assign() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class M&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a60f52fac14aebb6fa6a86264d0973db2">iterator</a> <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::insert_or_assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a></td>          <td class="paramname"><span class="paramname"><em>hint</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a2eae39b540085051068d2c94d3054dd9">key_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>k</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>obj</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5df8328a9edf3f97fc25023a8462f6e1" name="a5df8328a9edf3f97fc25023a8462f6e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5df8328a9edf3f97fc25023a8462f6e1">&#9670;&#160;</a></span>insert_or_assign() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class M&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a60f52fac14aebb6fa6a86264d0973db2">iterator</a> <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::insert_or_assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a></td>          <td class="paramname"><span class="paramname"><em>hint</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a2eae39b540085051068d2c94d3054dd9">key_type</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>k</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>obj</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8cdcf51e4bbf7ec455f24c1298c8f6e5" name="a8cdcf51e4bbf7ec455f24c1298c8f6e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cdcf51e4bbf7ec455f24c1298c8f6e5">&#9670;&#160;</a></span>insert_or_assign() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class M&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="#a60f52fac14aebb6fa6a86264d0973db2">iterator</a>, bool &gt; <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::insert_or_assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a2eae39b540085051068d2c94d3054dd9">key_type</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>k</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>obj</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6b7236bc7221f302284165e0ab4e2c2c" name="a6b7236bc7221f302284165e0ab4e2c2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b7236bc7221f302284165e0ab4e2c2c">&#9670;&#160;</a></span>key_eq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a71848c7a83bde13a664d81ab29cfe009">key_equal</a> <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::key_eq </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac2674047296b5b925d24c80df8e35bd0" name="ac2674047296b5b925d24c80df8e35bd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2674047296b5b925d24c80df8e35bd0">&#9670;&#160;</a></span>load_factor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::load_factor </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae391a0f4c83b6ab9c7503b4ca335b370" name="ae391a0f4c83b6ab9c7503b4ca335b370"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae391a0f4c83b6ab9c7503b4ca335b370">&#9670;&#160;</a></span>max_bucket_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a2ac3b2278e6f731cdf4ac9b12ad62a71">size_type</a> <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::max_bucket_count </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa48f17ccd7760fde3b2a666823741142" name="aa48f17ccd7760fde3b2a666823741142"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa48f17ccd7760fde3b2a666823741142">&#9670;&#160;</a></span>max_load_factor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::max_load_factor </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab4a2b90171e6152f5fd534cbf510ea40" name="ab4a2b90171e6152f5fd534cbf510ea40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4a2b90171e6152f5fd534cbf510ea40">&#9670;&#160;</a></span>max_load_factor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::max_load_factor </td>
          <td>(</td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>ml</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae004c2c0b10d1fb1942d5d78b7461aee" name="ae004c2c0b10d1fb1942d5d78b7461aee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae004c2c0b10d1fb1942d5d78b7461aee">&#9670;&#160;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a2ac3b2278e6f731cdf4ac9b12ad62a71">size_type</a> <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afb2e4a5595a63ec7984fcf2e496c939b" name="afb2e4a5595a63ec7984fcf2e496c939b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb2e4a5595a63ec7984fcf2e496c939b">&#9670;&#160;</a></span>mutable_iterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a60f52fac14aebb6fa6a86264d0973db2">iterator</a> <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::mutable_iterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a></td>          <td class="paramname"><span class="paramname"><em>pos</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert a <a class="el" href="#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a> to an iterator. </p>

</div>
</div>
<a id="aaf79f1726428647a5644d875b0e586f8" name="aaf79f1726428647a5644d875b0e586f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf79f1726428647a5644d875b0e586f8">&#9670;&#160;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1hopscotch__map.html">hopscotch_map</a> &amp; <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="#aa8775b4f4ca37f0ba1226b6ac8cf37b4">value_type</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>ilist</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a66b1af51a5bd60733c2d826379c5843d" name="a66b1af51a5bd60733c2d826379c5843d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66b1af51a5bd60733c2d826379c5843d">&#9670;&#160;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0cfddf9b6813db5dc8050e09ecd011ee" name="a0cfddf9b6813db5dc8050e09ecd011ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cfddf9b6813db5dc8050e09ecd011ee">&#9670;&#160;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">Key &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af540aaceecfd3809d0c8d42d6fd2a4d7" name="af540aaceecfd3809d0c8d42d6fd2a4d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af540aaceecfd3809d0c8d42d6fd2a4d7">&#9670;&#160;</a></span>overflow_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a2ac3b2278e6f731cdf4ac9b12ad62a71">size_type</a> <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::overflow_size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9cf26b6774ca9814d28736f9788eb9b7" name="a9cf26b6774ca9814d28736f9788eb9b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cf26b6774ca9814d28736f9788eb9b7">&#9670;&#160;</a></span>rehash()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::rehash </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a2ac3b2278e6f731cdf4ac9b12ad62a71">size_type</a></td>          <td class="paramname"><span class="paramname"><em>count_</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a54ba37be9c5369753020524dd4f8b516" name="a54ba37be9c5369753020524dd4f8b516"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54ba37be9c5369753020524dd4f8b516">&#9670;&#160;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a2ac3b2278e6f731cdf4ac9b12ad62a71">size_type</a></td>          <td class="paramname"><span class="paramname"><em>count_</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4927ca3c49b36756a1d4ade22ac4c59f" name="a4927ca3c49b36756a1d4ade22ac4c59f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4927ca3c49b36756a1d4ade22ac4c59f">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a2ac3b2278e6f731cdf4ac9b12ad62a71">size_type</a> <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a51f88bfcbc06111a158ed7afbe004a7b" name="a51f88bfcbc06111a158ed7afbe004a7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51f88bfcbc06111a158ed7afbe004a7b">&#9670;&#160;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1hopscotch__map.html">hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a08910966619e06befc115231e42c4b97" name="a08910966619e06befc115231e42c4b97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08910966619e06befc115231e42c4b97">&#9670;&#160;</a></span>try_emplace() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="#a60f52fac14aebb6fa6a86264d0973db2">iterator</a>, bool &gt; <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::try_emplace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a2eae39b540085051068d2c94d3054dd9">key_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>k</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abd207994b368fb2d3e6c2e191e6f3de6" name="abd207994b368fb2d3e6c2e191e6f3de6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd207994b368fb2d3e6c2e191e6f3de6">&#9670;&#160;</a></span>try_emplace() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a60f52fac14aebb6fa6a86264d0973db2">iterator</a> <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::try_emplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a></td>          <td class="paramname"><span class="paramname"><em>hint</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a2eae39b540085051068d2c94d3054dd9">key_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>k</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6476b1ccca8e5f1621dfe7b8674568fb" name="a6476b1ccca8e5f1621dfe7b8674568fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6476b1ccca8e5f1621dfe7b8674568fb">&#9670;&#160;</a></span>try_emplace() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a60f52fac14aebb6fa6a86264d0973db2">iterator</a> <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::try_emplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ab1f7dbb7b85f2d41b9bf81ab7d5b474f">const_iterator</a></td>          <td class="paramname"><span class="paramname"><em>hint</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a2eae39b540085051068d2c94d3054dd9">key_type</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>k</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab7decfabbefd86390736adfe9e3a4c51" name="ab7decfabbefd86390736adfe9e3a4c51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7decfabbefd86390736adfe9e3a4c51">&#9670;&#160;</a></span>try_emplace() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="#a60f52fac14aebb6fa6a86264d0973db2">iterator</a>, bool &gt; <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::try_emplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a2eae39b540085051068d2c94d3054dd9">key_type</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>k</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a name="doc-related-members" id="doc-related-members"></a><h2 id="header-doc-related-members" class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="a448d662876f88352fe68f0461d997e35" name="a448d662876f88352fe68f0461d997e35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a448d662876f88352fe68f0461d997e35">&#9670;&#160;</a></span>operator!=</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtsl_1_1hopscotch__map.html">hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtsl_1_1hopscotch__map.html">hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel friend">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a998b5b063e0895c40a81de5e54034a0f" name="a998b5b063e0895c40a81de5e54034a0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a998b5b063e0895c40a81de5e54034a0f">&#9670;&#160;</a></span>operator==</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtsl_1_1hopscotch__map.html">hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtsl_1_1hopscotch__map.html">hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel friend">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae939cc5e813994c09fa4e5cd687e1f5c" name="ae939cc5e813994c09fa4e5cd687e1f5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae939cc5e813994c09fa4e5cd687e1f5c">&#9670;&#160;</a></span>swap</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1hopscotch__map.html">hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtsl_1_1hopscotch__map.html">hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel friend">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a name="doc-variable-members" id="doc-variable-members"></a><h2 id="header-doc-variable-members" class="groupheader">Member Data Documentation</h2>
<a id="a1c018c7720fbeec1a31ffb531000d410" name="a1c018c7720fbeec1a31ffb531000d410"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c018c7720fbeec1a31ffb531000d410">&#9670;&#160;</a></span>m_ht</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;, unsigned int NeighborhoodSize = 62, bool StoreHash = false, class GrowthPolicy = tsl::hh::power_of_two_growth_policy&lt;2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a8b9a997423fc6ea10c27637614b7f5af">ht</a> <a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>&lt; Key, T, Hash, KeyEqual, Allocator, NeighborhoodSize, StoreHash, GrowthPolicy &gt;::m_ht</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/<a class="el" href="hopscotch__map_8h_source.html">hopscotch_map.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="namespacetsl.html">tsl</a></li><li class="navelem"><a href="classtsl_1_1hopscotch__map.html">hopscotch_map</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
